\rSec0[dcl.dcl]{Declarations}%
\indextext{declaration|(}

%gram: \rSec1[gram.dcl.dcl]{Declarations}
%gram:

\indextext{linkage specification|see{specification, linkage}}

\pnum
Declarations specify how names are to be interpreted. Declarations have
the form

\begin{bnf}
\nontermdef{declaration-seq}\br
    declaration\br
    declaration-seq declaration
\end{bnf}

\begin{bnf}
\nontermdef{declaration}\br
    block-declaration\br
    function-definition\br
    template-declaration\br
    explicit-instantiation\br
    explicit-specialization\br
    linkage-specification\br
    namespace-definition
\end{bnf}

\begin{bnf}
\nontermdef{block-declaration}\br
    simple-declaration\br
    asm-definition\br
    namespace-alias-definition\br
    using-declaration\br
    using-directive
\end{bnf}

\begin{bnf}
\nontermdef{simple-declaration}\br
    decl-specifier-seq\opt init-declarator-list\opt \terminal{;}
\end{bnf}

\enternote
\grammarterm{asm-definition}{s} are described in~\ref{dcl.asm}, and
\grammarterm{linkage-specification}{s} are described in~\ref{dcl.link}.
\grammarterm{Function-definition}{s} are described in~\ref{dcl.fct.def} and
\grammarterm{template-declaration}{s} are described in clause~\ref{temp}.
\grammarterm{Namespace-definition}{s} are described in~\ref{namespace.def},
\grammarterm{using-declaration}{s} are described in~\ref{namespace.udecl} and
\grammarterm{using-directive}{s} are described in~\ref{namespace.udir}.
\exitnote 
The \grammarterm{simple-declaration}

\begin{ncsimplebnf}
decl-specifier-seq\opt init-declarator-list\opt \terminal{;}
\end{ncsimplebnf}

is divided into two parts: \grammarterm{decl-specifier}{s}, the components of
a \grammarterm{decl-specifier-seq}, are described in~\ref{dcl.spec}.
\grammarterm{declarator}{s}, the components of an
\grammarterm{init-declarator-list}, are described in clause~\ref{dcl.decl}.

\pnum
\indextext{declaration}%
\indextext{scope}%
A declaration occurs in a scope~(\ref{basic.scope}); the scope rules are
summarized in~\ref{basic.lookup}. A declaration that declares a function
or defines a class, namespace, template, or function also has one or
more scopes nested within it. These nested scopes, in turn, can have
declarations nested within them. Unless otherwise stated, utterances in
clause~\ref{dcl.dcl} about components in, of, or contained by a
declaration or subcomponent thereof refer only to those components of
the declaration that are \emph{not} nested within scopes nested within
the declaration.

\pnum
\indextext{identifier}%
\indextext{declarator}%
In a \grammarterm{simple-declaration}, the optional
\grammarterm{init-declarator-list} can be omitted only when declaring a
class (clause~\ref{class}) or enumeration~(\ref{dcl.enum}), that is,
when the \grammarterm{decl-specifier-seq} contains either a
\grammarterm{class-specifier}, an \grammarterm{elaborated-type-specifier} with
a \grammarterm{class-key}~(\ref{class.name}), or an
\grammarterm{enum-specifier}. In these cases and whenever a
\grammarterm{class-specifier} or \grammarterm{enum-specifier} is present in
the \grammarterm{decl-specifier-seq}, the identifiers in these specifiers
are among the names being declared by the declaration (as
\grammarterm{class-names}, \grammarterm{enum-names}, or
\grammarterm{enumerators}, depending on the syntax). In such cases, and
except for the declaration of an unnamed bit-field~(\ref{class.bit}),
the \grammarterm{decl-specifier-seq} shall introduce one or more names into
the program, or shall redeclare a name introduced by a previous
declaration.
\enterexample

\begin{codeblock}
enum { };			// ill-formed
typedef class { };		// ill-formed
\end{codeblock}
\exitexampleb

\pnum
Each \grammarterm{init-declarator} in the \grammarterm{init-declarator-list}
contains exactly one \grammarterm{declarator-id}, which is the name
declared by that \grammarterm{init-declarator} and hence one of the names
declared by the declaration. The
\grammarterm{type-specifiers}~(\ref{dcl.type}) in the
\grammarterm{decl-specifier-seq} and the recursive \grammarterm{declarator}
structure of the \grammarterm{init-declarator} describe a
type~(\ref{dcl.meaning}), which is then associated with the name being
declared by the \grammarterm{init-declarator}.

\pnum
If the \grammarterm{decl-specifier-seq} contains the \tcode{typedef}
specifier, the declaration is called a \term{typedef declaration} and the name
of each \grammarterm{init-declarator}
is declared to be a \grammarterm{typedef-name}, synonymous with its
associated type~(\ref{dcl.typedef}). If the
\grammarterm{decl-specifier-seq} contains no \tcode{typedef} specifier, the
declaration is called a \term{function declaration} if
the type associated with the name is a function type~(\ref{dcl.fct}) and
an \term{object declaration} otherwise.

\pnum
\indextext{definition!declaration~as}%
Syntactic components beyond those found in the general form of
declaration are added to a function declaration to make a
\grammarterm{function-definition}. An object declaration, however, is also
a definition unless it contains the \tcode{extern} specifier and has no
initializer~(\ref{basic.def}).
\indextext{initialization!definition~and}%
A
definition causes the appropriate amount of storage to be reserved and
any appropriate initialization~(\ref{dcl.init}) to be done.

\pnum
Only in function declarations for constructors, destructors, and type
conversions can the \grammarterm{decl-specifier-seq} be omitted.\footnote{The
``implicit int'' rule of C is no longer supported.}

\rSec1[dcl.spec]{Specifiers}%
\indextext{specifier|(}

\pnum
\indextext{specifier!declaration}%
The specifiers that can be used in a declaration are

\begin{bnf}
\nontermdef{decl-specifier}\br
    storage-class-specifier\br
    type-specifier\br
    function-specifier\br
    \terminal{friend}\br
    \terminal{typedef}
\end{bnf}

\begin{bnf}
\nontermdef{decl-specifier-seq}\br
    decl-specifier-seq\opt decl-specifier
\end{bnf}

\pnum
\indextext{ambiguity!declaration type}%
The longest sequence of \grammarterm{decl-specifier}{s} that could possibly
be a type name is taken as the \grammarterm{decl-specifier-seq} of a
\grammarterm{declaration}. The sequence shall be self-consistent as
described below.
\enterexample

\begin{codeblock}
typedef char* Pc;
static Pc;                      // error: name missing
\end{codeblock}

Here, the declaration \tcode{static} \tcode{Pc} is ill-formed because no
name was specified for the static variable of type \tcode{Pc}. To get a
variable called \tcode{Pc}, a \grammarterm{type-specifier} (other than
\tcode{const} or \tcode{volatile}) has to be present to indicate that
the \grammarterm{typedef-name} \tcode{Pc} is the name being (re)declared,
rather than being part of the \grammarterm{decl-specifier} sequence. For
another example,

\begin{codeblock}
void f(const Pc);               // \tcode{void f(char* const)} (not \tcode{const char*})
void g(const int Pc);           // \tcode{void g(const int)}
\end{codeblock}
\exitexampleb

\pnum
\indextext{\idxcode{signed}!typedef@\tcode{typedef}~and}%
\indextext{\idxcode{unsigned}!typedef@\tcode{typedef}~and}%
\indextext{\idxcode{long}!typedef@\tcode{typedef}~and}%
\indextext{\idxcode{short}!typedef@\tcode{typedef}~and}%
\enternote
since \tcode{signed}, \tcode{unsigned}, \tcode{long}, and \tcode{short}
by default imply \tcode{int}, a \grammarterm{type-name} appearing after one
of those specifiers is treated as the name being (re)declared.
\enterexample

\begin{codeblock}
void h(unsigned Pc);            // \tcode{void h(unsigned int)}
void k(unsigned int Pc);        // \tcode{void k(unsigned int)}
\end{codeblock}
\exitexampleb
\exitnoteb

\rSec2[dcl.stc]{Storage class specifiers}%
\indextext{specifier!storage~class}%
\indextext{declaration!storage~class}%
\indextext{\idxcode{auto}}%
\indextext{\idxcode{register}}%
\indextext{\idxcode{static}}%
\indextext{\idxcode{extern}}%
\indextext{\idxcode{mutable}}

\pnum
The storage class specifiers are

\begin{bnf}
\nontermdef{storage-class-specifier}\br
    \terminal{auto}\br
    \terminal{register}\br
    \terminal{static}\br
    \terminal{extern}\br
    \terminal{mutable}
\end{bnf}

At most one \grammarterm{storage-class-specifier} shall appear in a given
\grammarterm{decl-specifier-seq}. If a \grammarterm{storage-class-specifier}
appears in a \grammarterm{decl-specifier-seq}, there can be no
\tcode{typedef} specifier in the same \grammarterm{decl-specifier-seq} and
the \grammarterm{init-declarator-list} of the declaration shall not be
empty (except for global anonymous unions, which shall be declared
\indextext{specifier!\idxcode{static}}%
\tcode{static}~(\ref{class.union})). The
\grammarterm{storage-class-specifier} applies to the name declared by each
\grammarterm{init-declarator} in the list and not to any names declared by
other specifiers. A \grammarterm{storage-class-specifier} shall not be
specified in an explicit specialization~(\ref{temp.expl.spec}) or an
explicit instantiation~(\ref{temp.explicit}) directive.

\pnum
\indextext{restriction!\idxcode{auto}}%
\indextext{restriction!\idxcode{register}}%
The \tcode{auto} or \tcode{register} specifier can be applied only to
names of objects declared in a block~(\ref{stmt.block}) or to function
parameters~(\ref{dcl.fct.def}). They specify that the named object has
automatic storage duration~(\ref{basic.stc.auto}). An object declared
without a \grammarterm{storage-class-specifier} at block scope or declared
as a function parameter has automatic storage duration by default.
\enternote
hence, the \tcode{auto} specifier is almost always redundant and not
often used; one use of \tcode{auto} is to distinguish a
\grammarterm{declaration-statement} from an
\grammarterm{expression-statement}~(\ref{stmt.ambig}) explicitly.
\exitnoteb

\pnum
\indextext{declaration!\idxcode{register}}%
A \tcode{register} specifier has the same semantics as an \tcode{auto}
specifier together with a hint to the implementation that the object
so declared will be heavily used.
\enternote
the hint can be ignored and in most implementations it will be ignored
if the address of the object is taken.
\exitnoteb

\pnum
\indextext{restriction!\idxcode{static}}%
The \tcode{static} specifier can be applied only to names of objects and
functions and to anonymous unions~(\ref{class.union}). There can be no
\tcode{static} function declarations within a block, nor any
\tcode{static} function parameters. A \tcode{static} specifier used in
the declaration of an object declares the object to have static storage
duration~(\ref{basic.stc.static}). A \tcode{static} specifier can be
used in declarations of class members;~\ref{class.static} describes its
effect.
\indextext{\idxcode{static}!linkage~of}%
For the linkage of a name declared with a \tcode{static} specifier,
see~\ref{basic.link}.

\pnum
\indextext{restriction!\idxcode{extern}}%
The \tcode{extern} specifier can be applied only to the names of objects
and functions. The \tcode{extern} specifier cannot be used in the
declaration of class members or function parameters.
\indextext{\idxcode{extern}!linkage~of}%
\indextext{consistency!linkage}%
For the linkage of a name declared with an \tcode{extern} specifier,
see~\ref{basic.link}.

\pnum
\indextext{\idxcode{const}!linkage~of}%
\indextext{specifier!missing storage~class}%
A name declared in a namespace scope without a
\grammarterm{storage-class-specifier} has external linkage unless it has
internal linkage because of a previous declaration and provided it is
not declared \tcode{const}. Objects declared \tcode{const} and not
explicitly declared \tcode{extern} have internal linkage.

\pnum
The linkages implied by successive declarations for a given entity shall
agree. That is, within a given scope, each declaration declaring the
same object name or the same overloading of a function name shall imply
the same linkage. Each function in a given set of overloaded functions
can have a different linkage, however.
\enterexample
\indextext{example!linkage consistency}%

\begin{codeblock}
static char* f();               // \tcode{f()} has internal linkage
char* f()                       // \tcode{f()} still has internal linkage
    { /* ... */ }

char* g();                      // \tcode{g()} has external linkage
static char* g()                // error: inconsistent linkage
    { /* ... */ }

void h();
inline void h();                // external linkage

inline void l();
void l();                       // external linkage

inline void m();
extern void m();                // external linkage

static void n();
inline void n();                // internal linkage

static int a;                   // \tcode{a} has internal linkage
int a;                          // error: two definitions

static int b;                   // \tcode{b} has internal linkage
extern int b;                   // \tcode{b} still has internal linkage

int c;                          // \tcode{c} has external linkage
static int c;                   // error: inconsistent linkage

extern int d;                   // \tcode{d} has external linkage
static int d;                   // error: inconsistent linkage
\end{codeblock}
\exitexampleb

\pnum
\indextext{declaration!forward}%
The name of a declared but undefined class can be used in an
\tcode{extern} declaration. Such a declaration can only be used in ways
that do not require a complete class type.
\enterexample

\begin{codeblock}
struct S;
extern S a;
extern S f();
extern void g(S);

void h()
{
    g(a);                       // error: \tcode{S} is incomplete
    f();			// error: \tcode{S} is incomplete
}
\end{codeblock}
\exitexampleb
The \tcode{mutable} specifier can be applied only to names of class data
members~(\ref{class.mem}) and cannot be applied to names declared
\tcode{const} or \tcode{static}, and cannot be applied to reference
members.
\enterexample

\begin{codeblock}
class X {
	mutable const int* p;   // OK
	mutable int* const q;   // ill-formed
};
\end{codeblock}
\exitexampleb

\pnum
The \tcode{mutable} specifier on a class data member nullifies a
\tcode{const} specifier applied to the containing class object and
permits modification of the mutable class member even though the rest of
the object is \term{const}~(\ref{dcl.type.cv}).

\rSec2[dcl.fct.spec]{Function specifiers}%
\indextext{specifier!function}%
\indextext{function|seealso{friend function; member~function; inline~function; virtual~function}}

\pnum
\grammarterm{Function-specifiers}
can be used only in function declarations.

\begin{bnf}
\nontermdef{function-specifier}\br
    \terminal{inline}\br
    \terminal{virtual}\br
    \terminal{explicit}
\end{bnf}

\pnum
\indextext{specifier!\idxcode{inline}}%
\indextext{inline~function}%
A function declaration~(\ref{dcl.fct},~\ref{class.mfct},
\ref{class.friend}) with an \tcode{inline} specifier declares an
\term{inline function}. The inline specifier indicates to
the implementation that inline substitution of the function body at the
point of call is to be preferred to the usual function call mechanism.
An implementation is not required to perform this inline substitution at
the point of call; however, even if this inline substitution is omitted,
the other rules for inline functions defined by~\ref{dcl.fct.spec} shall
still be respected.

\pnum
A function defined within a class definition is an inline function. The
\tcode{inline} specifier shall not appear on a block scope function
declaration.\footnote{The inline keyword has no effect on the linkage of a function.}

\pnum
An inline function shall be defined in every translation unit in which
it is used and shall have exactly the same definition in every
case~(\ref{basic.def.odr}).
\enternote
a call to the inline function may be encountered before its definition
appears in the translation unit.
\exitnote
If a function with external linkage is declared inline in one translation
unit, it shall be declared inline in all translation units in which it
appears; no diagnostic is required. An \tcode{inline} function with external
linkage shall have the same address in all translation units. A
\tcode{static} local variable in an \tcode{extern} \tcode{inline}
function always refers to the same object. A string literal in an
\tcode{extern} \tcode{inline} function is the same object in
different translation units.

\pnum
\indextext{specifier!\idxcode{virtual}}%
The \tcode{virtual} specifier shall only be used in declarations of
nonstatic class member function that appear within a
\grammarterm{member-specification} of a class declaration;
see~\ref{class.virtual}.

\pnum
\indextext{specifier!\idxcode{explicit}}%
The \tcode{explicit} specifier shall be used only in the declaration of
constructors within a class declaration; see~\ref{class.conv.ctor}.

\rSec2[dcl.typedef]{The \tcode{typedef} specifier}%
\indextext{specifier!\idxcode{typedef}}

\pnum
Declarations containing the \grammarterm{decl-specifier} \tcode{typedef}
declare identifiers that can be used later for naming
fundamental~(\ref{basic.fundamental}) or compound~(\ref{basic.compound})
types. The \tcode{typedef} specifier shall not be used in a
\grammarterm{function-definition}~(\ref{dcl.fct.def}), and it shall
not be combined in a \grammarterm{decl-specifier-seq} with any other
kind of specifier except a \grammarterm{type-specifier}.

\begin{bnf}
\nontermdef{typedef-name}\br
    identifier
\end{bnf}

A name declared with the \tcode{typedef} specifier becomes a
\grammarterm{typedef-name}. Within the scope of its declaration, a
\grammarterm{typedef-name} is syntactically equivalent to a keyword and
names the type associated with the identifier in the way described in
clause~\ref{dcl.decl}.
\indextext{declaration!typedef@\tcode{typedef}~as type}%
\indextext{equivalence!type}%
\indextext{synonym!type~name~as}%
A \grammarterm{typedef-name} is thus a synonym for another type. A
\grammarterm{typedef-name} does not introduce a new type the way a class
declaration~(\ref{class.name}) or enum declaration does.
\enterexample
\indextext{example!\idxcode{typedef}}%
after

\begin{codeblock}
typedef int MILES, *KLICKSP;
\end{codeblock}

the constructions

\begin{codeblock}
MILES distance;
extern KLICKSP metricp;
\end{codeblock}

are all correct declarations; the type of \tcode{distance} is
\tcode{int}; that of \tcode{metricp} is ``pointer to \tcode{int}.''
\exitexample

\pnum
\indextext{redefinition!\idxcode{typedef}}%
In a given non-class scope, a \tcode{typedef} specifier can be used to
redefine the name of any type declared in that scope to refer to the
type to which it already refers.
\enterexample

\begin{codeblock}
typedef struct s { /* ... */ } s;
typedef int I;
typedef int I;
typedef I I;
\end{codeblock}
\exitexampleb

\pnum
In a given scope, a \tcode{typedef} specifier shall not be used to
redefine the name of any type declared in that scope to refer to a
different type.
\enterexample

\begin{codeblock}
class complex { /* ... */ };
typedef int complex;            // error: redefinition
\end{codeblock}

\exitexampleb
Similarly, in a given scope, a class or enumeration shall not be
declared with the same name as a \grammarterm{typedef-name} that is
declared in that scope and refers to a type other than the class or
enumeration itself.
\enterexample

\begin{codeblock}
typedef int complex;
class complex @\tcode{\{ /* ... */ \}}@;   // error: redefinition
\end{codeblock}
\exitexampleb

\pnum
\indextext{class~name!\idxcode{typedef}}%
A \grammarterm{typedef-name} that names a class is a
\grammarterm{class-name}~(\ref{class.name}). If
a \grammarterm{typedef-name} is used following the \grammarterm{class-key}
in an \grammarterm{elaborated-type-specifier}~(\ref{dcl.type.elab})
or in the \grammarterm{class-head} of a class declaration~(\ref{class}),
or is used as the \grammarterm{identifier} in the declarator for a
constructor or destructor declaration~(\ref{class.ctor}, \ref{class.dtor}),
the program is ill-formed.
\enterexample

\begin{codeblock}
struct S {
    S();
    ~S();
};

typedef struct S T;

S a = T();                      // OK
struct T * p;                   // error
\end{codeblock}
\exitexampleb

\pnum
\indextext{class~name!\idxcode{typedef}}%
\indextext{enum~name!\idxcode{typedef}}%
\indextext{class!unnamed}%
If the typedef declaration defines an unnamed class (or enum), the first
\grammarterm{typedef-name} declared by the declaration to be that class
type (or enum type) is used to denote the class type (or enum type) for
linkage purposes only~(\ref{basic.link}).
\enterexample

\begin{codeblock}
typedef struct { } *ps, S;      // \tcode{S} is the class name for linkage purposes
\end{codeblock}

\exitexampleb
\enternote
if the \grammarterm{typedef-name} is used where a \grammarterm{class-name}
(or \grammarterm{enum-name}) is required, the program is ill-formed.
For example,

\begin{codeblock}
typedef struct {
    S();			// error: requires a return type because \tcode{S} is
				// an ordinary member function, not a constructor
} S;
\end{codeblock}
\exitnoteb

\rSec2[dcl.friend]{The \tcode{friend} specifier}%
\indextext{specifier!\idxcode{friend}}

\pnum
The \tcode{friend} specifier is used to specify access to class members;
see~\ref{class.friend}.

\rSec2[dcl.type]{Type specifiers}%
\indextext{specifier!type|see{type~specifier}}

\pnum
The type-specifiers are

\indextext{type!\idxcode{const}}%
\indextext{type!\idxcode{volatile}}%
%
\begin{bnf}
\nontermdef{type-specifier}\br
    simple-type-specifier\br
    class-specifier\br
    enum-specifier\br
    elaborated-type-specifier\br
    cv-qualifier
\end{bnf}

As a general rule, at most one \grammarterm{type-specifier} is allowed in
the complete \grammarterm{decl-specifier-seq} of a \grammarterm{declaration}.
The only exceptions to this rule are the following:

\begin{itemize}
\item \tcode{const} or \tcode{volatile} can be combined with any other
\grammarterm{type-specifier}. However, redundant cv-qualifiers are
prohibited except when introduced through the use of
typedefs~(\ref{dcl.typedef}) or template type arguments~(\ref{temp.arg}),
in which case the redundant cv-qualifiers are ignored.

\item \tcode{signed} or \tcode{unsigned} can be combined with
\tcode{char}, \tcode{long}, \tcode{short}, or \tcode{int}.

\item \tcode{short} or \tcode{long} can be combined with \tcode{int}.

\item \tcode{long} can be combined with \tcode{double}.
\end{itemize}

\pnum
At least one \grammarterm{type-specifier} that is not a
\grammarterm{cv-qualifier} is required in a declaration unless it declares
a constructor, destructor or conversion function.\footnote{There is no special
provision for a \grammarterm{decl-specifier-seq} that
lacks a \grammarterm{type-specifier} or that has a
\grammarterm{type-specifier} that only specifies \grammarterm{cv-qualifier}{s}.
The ``implicit int'' rule of C is no longer supported.}

\pnum
\enternote
\grammarterm{class-specifier}{s} and \grammarterm{enum-specifier}{s} are
discussed in clause~\ref{class} and \ref{dcl.enum}, respectively. The remaining
\grammarterm{type-specifier}{s} are discussed in the rest of this section.
\exitnote

\rSec3[dcl.type.cv]{The \grammarterm{cv-qualifiers}}%
\indextext{specifier!cv-qualifier}%
\indextext{initialization!\idxcode{const}}%
\indextext{type specifier!\idxcode{const}}%
\indextext{type specifier!\idxcode{volatile}}

\pnum
There are two \grammarterm{cv-qualifiers}, \tcode{const} and
\tcode{volatile}. If a \grammarterm{cv-qualifier} appears in a
\grammarterm{decl-specifier-seq}, the \grammarterm{init-declarator-list} of
the declaration shall not be empty.
\enternote
\ref{basic.type.qualifier} describe how cv-qualifiers affect object and
function types.
\exitnote

\pnum
An object declared in namespace scope with a const-qualified type has
internal linkage unless it is explicitly declared \tcode{extern} or
unless it was previously declared to have external linkage. A variable of
non-volatile const-qualified integral or enumeration type initialized by
an integral constant expression can be used in integral constant
expressions~(\ref{expr.const}).
\enternote
as described in~\ref{dcl.init}, the definition of an object or subobject
of const-qualified type must specify an initializer or be subject to
default-initialization.
\exitnote

\pnum
A pointer or reference to a cv-qualified type need not actually point or
refer to a cv-qualified object, but it is treated as if it does; a
const-qualified access path cannot be used to modify an object even if
the object referenced is a non-const object and can be modified through
some other access path.
\enternote
cv-qualifiers are supported by the type system so that they cannot be
subverted without casting~(\ref{expr.const.cast}).
\exitnote

\pnum
\indextext{const~object@\tcode{const}-object!undefined change~to}%
Except that any class member declared \tcode{mutable}~(\ref{dcl.stc})
can be modified, any attempt to modify a \tcode{const} object during its
lifetime~(\ref{basic.life}) results in undefined behavior.

\pnum
\enterexample

\begin{codeblock}
const int ci = 3;               // cv-qualified (initialized as required)
ci = 4;                         // ill-formed: attempt to modify \tcode{const}

int i = 2;                      // not cv-qualified
const int* cip;                 // pointer to \tcode{const int}
cip = &i;                       // OK: cv-qualified access path to unqualified
*cip = 4;                       // ill-formed: attempt to modify through ptr to \tcode{const}

int* ip;
ip = const_cast<int*>(cip);     // cast needed to convert \tcode{const int*} to \tcode{int*}
*ip = 4;                        // defined: \tcode{*ip} points to \tcode{i}, a non-\tcode{const} object

const int* ciq = new const int (3);     // initialized as required
int* iq = const_cast<int*>(ciq);        // cast required
*iq = 4;                                // undefined: modifies a \tcode{const} object
\end{codeblock}

\pnum
For another example

\begin{codeblock}
class X {
    public:
	mutable int i;
	int j;
};
class Y {
    public:
	X x;
	Y();
};

const Y y;
y.x.i++;                        // well-formed: \tcode{mutable} member can be modified
y.x.j++;                        // ill-formed: \tcode{const}-qualified member modified
Y* p = const_cast<Y*>(&y);      // cast away const-ness of \tcode{y}
p->x.i = 99;                    // well-formed: \tcode{mutable} member can be modified
p->x.j = 99;                    // undefined: modifies a \tcode{const} member
\end{codeblock}
\exitexampleb

\pnum
If an attempt is made to refer to an object defined with a
volatile-qualified type through the use of an lvalue with a
non-volatile-qualified type, the program behavior is undefined.

\pnum
\indextext{type~specifier!\idxcode{volatile}}%
\indextext{\idxcode{volatile}!implementation-defined}%
\enternote
\tcode{volatile} is a hint to the implementation to avoid aggressive
optimization involving the object because the value of the object might
be changed by means undetectable by an implementation.
See~\ref{intro.execution} for detailed semantics. In general, the
semantics of \tcode{volatile} are intended to be the same in \Cpp as
they are in C.
\exitnote

\rSec3[dcl.type.simple]{Simple type specifiers}%
\indextext{type specifier!simple}

\pnum
The simple type specifiers are

\begin{bnf}
\nontermdef{simple-type-specifier}\br
    \terminal{::}\opt nested-name-specifier\opt type-name\br
    \terminal{::}\opt nested-name-specifier \terminal{template} template-id\br
    \terminal{char}\br
    \terminal{wchar_t}\br
    \terminal{bool}\br
    \terminal{short}\br
    \terminal{int}\br
    \terminal{long}\br
    \terminal{signed}\br
    \terminal{unsigned}\br
    \terminal{float}\br
    \terminal{double}\br
    \terminal{void}
\end{bnf}

\begin{bnf}
\nontermdef{type-name}\br
    class-name\br
    enum-name\br
    typedef-name
\end{bnf}

\indextext{type~specifier!\idxcode{char}}%
\indextext{type-specifier!\idxcode{wchar_t}}%
\indextext{type-specifier!\idxcode{bool}}%
\indextext{type~specifier!\idxcode{short}}%
\indextext{type~specifier!\idxcode{int}}%
\indextext{type~specifier!\idxcode{long}}%
\indextext{type~specifier!\idxcode{signed}}%
\indextext{type~specifier!\idxcode{unsigned}}%
\indextext{type~specifier!\idxcode{float}}%
\indextext{type~specifier!\idxcode{double}}%
\indextext{type~specifier!\idxcode{void}}%
\indextext{\idxgram{type-name}}%
The \grammarterm{simple-type-specifier}{s}
specify either a previously-declared user-defined type or one of the
fundamental types~(\ref{basic.fundamental}).
Table~\ref{tab:simple.type.specifiers}
 summarizes the valid combinations of
\grammarterm{simple-type-specifier}{s}
and the types they specify.

\begin{simpletypetable}
{\grammarterm{simple-type-specifier}{s} and the types they specify}
{tab:simple.type.specifiers}
{ll}
\topline
Specifier(s)                    &   Type                 \\ \capsep
\grammarterm{type-name}         &   the type named          \\
char                            &   ``char''                \\
unsigned char                   &   ``unsigned char''       \\
signed char                     &   ``signed char''         \\
bool                            &   ``bool''                \\
unsigned                        &   ``unsigned int''        \\
unsigned int                    &   ``unsigned int''        \\
signed                          &   ``int''                 \\
signed int                      &   ``int''                 \\
int                             &   ``int''                 \\
unsigned short int              &   ``unsigned short int''  \\
unsigned short                  &   ``unsigned short int''  \\
unsigned long int               &   ``unsigned long int''   \\
unsigned long                   &   ``unsigned long int''   \\
signed long int                 &   ``long int''            \\
signed long                     &   ``long int''            \\
long int                        &   ``long int''            \\
long                            &   ``long int''            \\
signed short int                &   ``short int''           \\
signed short                    &   ``short int''           \\
short int                       &   ``short int''           \\
short                           &   ``short int''           \\
wchar_t                         &   ``wchar_t''             \\
float                           &   ``float''               \\
double                          &   ``double''              \\
long double                     &   ``long double''         \\
void                            &   ``void''                \\
\end{simpletypetable}

When multiple \grammarterm{simple-type-specifiers} are allowed, they can be
freely intermixed with other \grammarterm{decl-specifiers} in any order.
It is implementation-defined whether bit-fields and objects of \tcode{char}
type are represented as signed or
unsigned quantities. The \tcode{signed} specifier forces \tcode{char}
objects and bit-fields to be signed; it is redundant with other integral types.
%\clearpage

\rSec3[dcl.type.elab]{Elaborated type specifiers}%
\indextext{type specifier!elaborated}%
\indextext{\idxcode{typename}}%
\indextext{type~specifier!\idxcode{enum}}

\begin{bnf}
\nontermdef{elaborated-type-specifier}\br
    class-key \terminal{::}\opt nested-name-specifier\opt identifier\br
    class-key \terminal{::}\opt nested-name-specifier\opt \terminal{template}\opt template-id\br
    \terminal{enum} \terminal{::}\opt nested-name-specifier\opt identifier\br
    typename \terminal{::}\opt nested-name-specifier identifier\br
    typename \terminal{::}\opt nested-name-specifier \terminal{template}\opt template-id
\end{bnf}

\pnum
\indextext{class~name!elaborated}%
\indextext{name!elaborated!\idxcode{enum}}%
If an \grammarterm{elaborated-type-specifier} is the sole constituent of a
declaration, the declaration is ill-formed unless it is an explicit
specialization~(\ref{temp.expl.spec}), an explicit
instantiation~(\ref{temp.explicit}) or it has one of the following
forms:

\begin{ncsimplebnf}
class-key identifier \terminal{;}\br
\terminal{friend} class-key \terminal{::\opt} identifier \terminal{;}\br
\terminal{friend} class-key \terminal{::\opt} template-id \terminal{;}\br
\terminal{friend} class-key \terminal{::\opt} nested-name-specifier identifier \terminal{;}\br
\terminal{friend} class-key \terminal{::\opt} nested-name-specifier \terminal{template\opt} template-id \terminal{;}
\end{ncsimplebnf}

\pnum
\ref{basic.lookup.elab} describes how name lookup proceeds for the
\grammarterm{identifier} in an \grammarterm{elaborated-type-specifier}. If the
\grammarterm{identifier} resolves to a \grammarterm{class-name} or
\grammarterm{enum-name}, the \grammarterm{elaborated-type-specifier}
introduces it into the declaration the same way a
\grammarterm{simple-type-specifier} introduces its \grammarterm{type-name}. If
the \grammarterm{identifier} resolves to a
\grammarterm{typedef-name} or a template \grammarterm{type-parameter},
the \grammarterm{elaborated-type-specifier} is ill-formed.
\enternote
this implies that, within a class template with a template
\grammarterm{type-parameter} \tcode{T}, the declaration

\begin{codeblock}
friend class T;
\end{codeblock}

is ill-formed.
\exitnote
If name lookup does not find a declaration for the name, the
\grammarterm{elaborated-type-specifier} is ill-formed unless it is of the
simple form \grammarterm{class-key} \grammarterm{identifier} in which case
the \grammarterm{identifier} is declared as described in
\ref{basic.scope.pdecl}.

\pnum
The \grammarterm{class-key} or \tcode{enum} keyword
present in the
\grammarterm{elaborated-type-specifier} shall agree in kind with the
declaration to which the name in the
\grammarterm{elaborated-type-specifier} refers. This rule also applies to
the form of \grammarterm{elaborated-type-specifier} that declares a
\grammarterm{class-name} or \tcode{friend} class since it can be construed
as referring to the definition of the class. Thus, in any
\grammarterm{elaborated-type-specifier}, the \tcode{enum} keyword
shall be
used to refer to an enumeration~(\ref{dcl.enum}), the \tcode{union}
\grammarterm{class-key} shall be used to refer to a union
(clause~\ref{class}), and either the \tcode{class} or \tcode{struct}
\grammarterm{class-key} shall be used to refer to a class
(clause~\ref{class}) declared using the \tcode{class} or \tcode{struct}
\grammarterm{class-key}.

\rSec1[dcl.enum]{Enumeration declarations}%
\indextext{enumeration}%
\indextext{\idxcode{\{\}}!enum declaration@\tcode{enum} declaration}%
\indextext{\idxcode{enum}!type~of}

\pnum
An enumeration is a distinct type~(\ref{basic.compound}) with named
constants. Its name becomes an \grammarterm{enum-name}, within its scope.

\begin{bnf}
\nontermdef{enum-name}\br
    identifier
\end{bnf}

\begin{bnf}
\nontermdef{enum-specifier}\br
    \terminal{enum} identifier\opt \terminal{\{} enumerator-list\opt \terminal{\}}
\end{bnf}

\begin{bnf}
\nontermdef{enumerator-list}\br
    enumerator-definition\br
    enumerator-list \terminal{,} enumerator-definition
\end{bnf}

\begin{bnf}
\nontermdef{enumerator-definition}\br
    enumerator\br
    enumerator \terminal{=} constant-expression
\end{bnf}

\begin{bnf}
\nontermdef{enumerator}\br
    identifier
\end{bnf}

\indextext{constant!enumeration}%
\indextext{enumeration}%
The identifiers in an \grammarterm{enumerator-list} are declared as
constants, and can appear wherever constants are required.
\indextext{enumerator!value~of}%
An \grammarterm{enumerator-definition} with \tcode{=} gives the associated
\grammarterm{enumerator} the value indicated by the
\grammarterm{constant-expression}. The \grammarterm{constant-expression}
shall be of integral or enumeration type. If the first
\grammarterm{enumerator} has no \grammarterm{initializer}, the value of
the corresponding constant is zero. An \grammarterm{enumerator-definition}
without an \grammarterm{initializer} gives the \grammarterm{enumerator}
the value obtained by increasing the value of the previous
\grammarterm{enumerator} by one.

\pnum
\enterexample

\begin{codeblock}
enum { a, b, c=0 };
enum { d, e, f=e+2 };
\end{codeblock}

defines \tcode{a}, \tcode{c}, and \tcode{d} to be zero, \tcode{b} and
\tcode{e} to be \tcode{1}, and \tcode{f} to be \tcode{3}.
\exitexample

\pnum
The point of declaration for an enumerator is immediately after its
\grammarterm{enumerator-definition}.
\enterexample

\begin{codeblock}
const int x = 12;
{ enum { x = x }; }
\end{codeblock}

Here, the enumerator \tcode{x} is initialized with the value of the
constant \tcode{x}, namely \tcode{12}.
\exitexample

\pnum
\indextext{\idxcode{enum}!type~of}%
\indextext{\idxcode{enum}!underlying~type}%
Each enumeration defines a type that is different from all other types.
Following the closing brace of an \grammarterm{enum-specifier}, each
enumerator has the type of its enumeration. Prior to the closing brace,
the type of each enumerator is the type of its initializing value. If an
initializer is specified for an enumerator, the initializing value has
the same type as the expression. If no initializer is specified for the
first enumerator, the type is an unspecified integral type. Otherwise
the type is the same as the type of the initializing value of the
preceding enumerator unless the incremented value is not representable
in that type, in which case the type is an unspecified integral type
sufficient to contain the incremented value.

\pnum
\indextext{type!enumeration underlying}%
The \term{underlying type} of an enumeration is an integral type that
can represent all the enumerator values defined in the enumeration.
It is \impldef{underlying type for enumeration}
which integral type is used as the underlying type for an enumeration
except that the underlying type shall not be larger than \tcode{int}
unless the value of an enumerator cannot fit in an \tcode{int} or
\tcode{unsigned int}. If the \grammarterm{enumerator-list} is empty, the
underlying type is as if the enumeration had a single enumerator with
value 0. The value of \tcode{sizeof()} applied to an enumeration type,
an object of enumeration type, or an enumerator, is the value of
\tcode{sizeof()} applied to the underlying type.

\pnum
For an enumeration where $e_\mathit{min}$ is the smallest enumerator and
$e_\mathit{max}$ is the largest, the values of the enumeration are the
values of the underlying type in the range $b_{min}$ to $b_{max}$, where
$b_{min}$ and $b_{max}$ are, respectively, the smallest and largest values
of the smallest bit-field that can store $e_{min}$ and $e_{max}$.%
\footnote{On a two's-complement machine, $b_{max}$ is the smallest value
greater than or equal to $max(abs(e_{min})-1,abs(e_{max}))$ of the form
$2^M-1$; $b_{min}$ is zero if $e_{min}$ is non-negative and $-(b_{max}+1)$
otherwise.}
It is possible to define an enumeration that has values not defined by
any of its enumerators.

\pnum
\indextext{layout-compatible type}%
Two enumeration types are layout-compatible if they have the same
\term{underlying type}.

\pnum
The value of an enumerator or an object of an enumeration type is
converted to an integer by integral promotion~(\ref{conv.prom}).
\enterexample

\indextext{example!enumeration}%
\begin{codeblock}
	enum color { red, yellow, green=20, blue };
	color col = red;
	color* cp = &col;
	if (*cp == blue)        // ...
\end{codeblock}

makes \tcode{color} a type describing various colors, and then declares
\tcode{col} as an object of that type, and \tcode{cp} as a pointer to an
object of that type. The possible values of an object of type
\tcode{color} are \tcode{red}, \tcode{yellow}, \tcode{green},
\tcode{blue}; these values can be converted to the integral values
\tcode{0}, \tcode{1}, \tcode{20}, and \tcode{21}. Since enumerations are
distinct types, objects of type \tcode{color} can be assigned only
values of type \tcode{color}.

\begin{codeblock}
color c = 1;                    // error: type mismatch,
                                // no conversion from \tcode{int} to \tcode{color}

int i = yellow;                 // OK: \tcode{yellow} converted to integral value \tcode{1}
                                // integral promotion
\end{codeblock}

\exitexampleb

\pnum
An expression of arithmetic or enumeration type can be converted to an
enumeration type explicitly. The value is unchanged if it is in the range
of enumeration values of the enumeration type; otherwise the resulting
enumeration value is unspecified.

\pnum
\indextext{class!scope~of enumerator}%
The enum-name and each enumerator declared by an enum-specifier is declared
in the scope that immediately contains the enum-specifier.
These names obey the scope rules defined for all names
in~(\ref{basic.scope}) and~(\ref{basic.lookup}).
\indextext{member!enumerator}%
An enumerator declared in class scope can be referred to using the class
member access operators (\tcode{::}, \tcode{.} (dot) and \tcode{->}
(arrow)), see~\ref{expr.ref}.
\enterexample

\begin{codeblock}
class X {
public:
    enum direction { left='l', right='r' };
    int f(int i)
	{ return i==left ? 0 : i==right ? 1 : 2; }
};

void g(X* p)
{
    direction d;                // error: \tcode{direction} not in scope
    int i;
    i = p->f(left);             // error: \tcode{left} not in scope
    i = p->f(X::right);         // OK
    i = p->f(p->left);          // OK
    // ...
}
\end{codeblock}
\exitexampleb

\rSec1[basic.namespace]{Namespaces}%
\indextext{namespaces|(}

\pnum
A namespace is an optionally-named declarative region. The name of a
namespace can be used to access entities declared in that namespace;
that is, the members of the namespace. Unlike other declarative regions,
the definition of a namespace can be split over several parts of one or
more translation units.

\pnum
The outermost declarative region of a translation unit is a namespace;
see~\ref{basic.scope.namespace}.

\rSec2[namespace.def]{Namespace definition}%
\indextext{definition!namespace}%
\indextext{namespace!definition}

\pnum
The grammar for a
\grammarterm{namespace-definition}
is

\begin{bnf}
\nontermdef{namespace-name}\br
        original-namespace-name\br
        namespace-alias
\end{bnf}

\begin{bnf}
\nontermdef{original-namespace-name}\br
        identifier
\end{bnf}

\begin{bnf}
\nontermdef{namespace-definition}\br
        named-namespace-definition\br
        unnamed-namespace-definition
\end{bnf}

\begin{bnf}
\nontermdef{named-namespace-definition}\br
        original-namespace-definition\br
        extension-namespace-definition
\end{bnf}

\begin{bnf}
\nontermdef{original-namespace-definition}\br
        \terminal{namespace} identifier \terminal{\{} namespace-body \terminal{\}}
\end{bnf}

\begin{bnf}
\nontermdef{extension-namespace-definition}\br
        \terminal{namespace} original-namespace-name \terminal{\{} namespace-body \terminal{\}}
\end{bnf}

\begin{bnf}
\nontermdef{unnamed-namespace-definition}\br
        \terminal{namespace \{} namespace-body \terminal{\}}
\end{bnf}

\begin{bnf}
\nontermdef{namespace-body}\br
        declaration-seq\opt
\end{bnf}

\pnum
The \grammarterm{identifier} in an \grammarterm{original-namespace-definition}
shall not have been previously defined in the declarative region in
which the \grammarterm{original-namespace-definition} appears. The
\grammarterm{identifier} in an \grammarterm{original-namespace-definition} is
the name of the namespace. Subsequently in that declarative region, it
is treated as an \grammarterm{original-namespace-name}.

\pnum
The \grammarterm{original-namespace-name} in an
\grammarterm{extension-namespace-definition} shall have previously been
defined in an \grammarterm{original-namespace-definition} in the same
declarative region.

\pnum
Every \grammarterm{namespace-definition} shall appear in the global scope
or in a namespace scope~(\ref{basic.scope.namespace}).

\pnum
Because a \grammarterm{namespace-definition} contains
\grammarterm{declaration}{s} in its \grammarterm{namespace-body} and a
\grammarterm{namespace-definition} is itself a \grammarterm{declaration}, it
follows that \grammarterm{namespace-definitions} can be nested.
\enterexample

\begin{codeblock}
namespace Outer {
	int i;
	namespace Inner {
		void f() { i++; }       // \tcode{Outer::i}
		int i;
		void g() { i++; }       // \tcode{Inner::i}
	}
}
\end{codeblock}
\exitexampleb

\rSec3[namespace.unnamed]{Unnamed namespaces}%
\indextext{namespace!unnamed}

\pnum
An \grammarterm{unnamed-namespace-definition} behaves as if it were
replaced by

\begin{ncsimplebnf}
\terminal{namespace} \uniquens \terminal{\{ /* empty body */ \}}\br
\terminal{using namespace} \uniquens \terminal{;}\br
\terminal{namespace} \uniquens \terminal{\{} namespace-body \terminal{\}}
\end{ncsimplebnf}

where all occurrences of \uniquens in a translation unit are replaced by
the same identifier and this identifier differs from all other
identifiers in the entire program.\footnote{Although entities in an unnamed
namespace might have external linkage,
they are effectively qualified by a name unique to their translation
unit and therefore can never be seen from any other translation unit.}
\enterexample

\begin{codeblock}
namespace { int i; }            // \uniquens \tcode{::i}
void f() { i++; }               // \uniquens \tcode{::i++}

namespace A {
	namespace {
		int i;          // \tcode{A::} \uniquens \tcode{::i}
		int j;          // \tcode{A::} \uniquens \tcode{::j}
	}
	void g() { i++; }       // \tcode{A::} \uniquens \tcode{::i++}
}

using namespace A;
void h() {
	i++;                    // error: \uniquens \tcode{::i} or \tcode{A::} \uniquens \tcode{::i}
	A::i++;                 // \tcode{A::} \uniquens \tcode{::i}
	j++;                    // \tcode{A::} \uniquens \tcode{::j}
}
\end{codeblock}
\exitexampleb

\pnum
The use of the \tcode{static} keyword is deprecated when declarating
objects in a namespace scope (see annex~\ref{depr}); the
\grammarterm{unnamed-namespace} provides a superior alternative.

\rSec3[namespace.memdef]{Namespace member definitions}%
\indextext{namespace!member definition}

\pnum
Members of a namespace can be defined within that namespace.
\enterexample

\begin{codeblock}
namespace X {
	void f() { /* ... */ }
}
\end{codeblock}
\exitexampleb

\pnum
Members of a named namespace can also be
defined outside that namespace by explicit
qualification~(\ref{namespace.qual}) of the name being defined, provided
that the entity being defined was already declared in the namespace and
the definition appears after the point of declaration in a namespace
that encloses the declaration's namespace.
\enterexample

\begin{codeblock}
namespace Q {
	namespace V {
		void f();
	}
	void V::f() { @/* ... */@ }	// OK
	void V::g() { @/* ... */@ }	// error: \tcode{g()} is not yet a member of \tcode{V}
	namespace V {
		void g();
	}
}

namespace R {
	void Q::V::g() { @/* ... */@ }	// error: \tcode{R} doesn't enclose \tcode{Q}
}
\end{codeblock}
\exitexampleb

\pnum
Every name first declared in a namespace is a member of that namespace.
If a \tcode{friend} declaration in a non-local class first declares a
class or function\footnote{this implies that the name of the class or function is unqualified.}
the friend class or function is a member of the innermost enclosing
namespace. The name of the friend is not found by simple name lookup
until a matching declaration is provided in that namespace scope (either
before or after the class declaration granting friendship). If a friend
function is called, its name may be found by the name lookup that
considers functions from namespaces and classes associated with the
types of the function arguments~(\ref{basic.lookup.koenig}). When looking
for a prior declaration of a class or a function declared as a
\tcode{friend}, and when the name of the \tcode{friend} class or function
is neither a qualified name nor a \grammarterm{template-id}, scopes
outside the innermost enclosing namespace scope are not considered.
\enterexample

\begin{codeblock}
// Assume \tcode{f} and \tcode{g} have not yet been defined.
void h(int);
template <class T> void f2(T);
namespace A {
	class X {
		friend void f(X);       // \tcode{A::f(X)} is a friend
		class Y {
			friend void g();        // \tcode{A::g} is a friend
			friend void h(int);     // \tcode{A::h} is a friend
						// \tcode{::h} not considered
			friend void f2<>(int);  // \tcode{::f2<>(int)} is a friend
		};
	};

	// \tcode{A::f}, \tcode{A::g} and \tcode{A::h} are not visible here
	X x;
	void g() { f(x); }		// definition of \tcode{A::g}
	void f(X) @\tcode{\{ /* ... */\}}@	   // definition of \tcode{A::f}
	void h(int) @\tcode{\{ /* ... */ \}}@      // definition of \tcode{A::h}
	// \tcode{A::f}, \tcode{A::g} and \tcode{A::h} are visible here and known to be friends
}

using A::x;

void h()
{
	A::f(x);
	A::X::f(x);             // error: \tcode{f} is not a member of \tcode{A::X}
	A::X::Y::g();           // error: \tcode{g} is not a member of \tcode{A::X::Y}
}
\end{codeblock}
\exitexampleb

\rSec2[namespace.alias]{Namespace alias}%
\indextext{namespace!alias}%
\indextext{alias!namespace}%
\indextext{synonym}

\pnum
A \grammarterm{namespace-alias-definition} declares an alternate name for a
namespace according to the following grammar:

\begin{bnf}
\nontermdef{namespace-alias}\br
        identifier
\end{bnf}

\begin{bnf}
\nontermdef{namespace-alias-definition}\br
        \terminal{namespace} identifier \terminal{=} qualified-namespace-specifier \terminal{;}
\end{bnf}

\begin{bnf}
\nontermdef{qualified-namespace-specifier}\br
	\terminal{::}\opt nested-name-specifier\opt namespace-name
\end{bnf}

\pnum
The \grammarterm{identifier} in a \grammarterm{namespace-alias-definition} is
a synonym for the name of the namespace denoted by the
\grammarterm{qualified-namespace-specifier} and becomes a
\grammarterm{namespace-alias}.
\enternote
when looking up a \grammarterm{namespace-name} in a
\grammarterm{namespace-alias-definition}, only namespace names are
considered, see~\ref{basic.lookup.udir}.
\exitnote

\pnum
In a declarative region, a \grammarterm{namespace-alias-definition} can be
used to redefine a \grammarterm{namespace-alias} declared in that
declarative region to refer only to the namespace to which it already
refers.
\enterexample
the following declarations are well-formed:

\begin{codeblock}
namespace Company_with_very_long_name { /* ... */ }
namespace CWVLN = Company_with_very_long_name;
namespace CWVLN = Company_with_very_long_name;          // OK: duplicate
namespace CWVLN = CWVLN;
\end{codeblock}
\exitexampleb

\pnum
A \grammarterm{namespace-name} or \grammarterm{namespace-alias} shall not be
declared as the name of any other entity in the same declarative region.
A \grammarterm{namespace-name} defined at global scope shall not be
declared as the name of any other entity in any global scope of the
program. No diagnostic is required for a violation of this rule by
declarations in different translation units.

\rSec2[namespace.udecl]{The \tcode{using} declaration}%
\indextext{using-declaration|(}

\pnum
A \grammarterm{using-declaration} introduces a name into the declarative
region in which the \grammarterm{using-declaration} appears. That name is
a synonym for the name of some entity declared elsewhere.

\begin{bnf}
\nontermdef{using-declaration}\br
    \terminal{using typename\opt ::\opt} nested-name-specifier unqualified-id \terminal{;}\br
    \terminal{using ::} unqualified-id \terminal{;}
\end{bnf}

\pnum
The member name specified in a \grammarterm{using-declaration} is declared
in the declarative region in which the \grammarterm{using-declaration}
appears. \enternote only the specified name is so declared; specifying
an enumeration name in a \grammarterm{using-declaration} does not declare
its enumerators in the \grammarterm{using-declaration}'s declarative
region.
\exitnote

\pnum
Every \grammarterm{using-declaration} is a \grammarterm{declaration} and a
\grammarterm{member-declaration} and so can be used in a class definition.
\enterexample

\begin{codeblock}
struct B {
	void f(char);
	void g(char);
	enum E { e };
	union { int x; };
};

struct D : B {
	using B::f;
	void f(int) { f('c'); }		// calls \tcode{B::f(char)}
	void g(int) { g('c'); }		// recursively calls \tcode{D::g(int)}
};
\end{codeblock}
\exitexampleb

\pnum
A \grammarterm{using-declaration} used as a \grammarterm{member-declaration}
shall refer to a member of a base class of the class being defined, shall
refer to a member of an anonymous union that is a member of a base class
of the class being defined, or shall refer to an enumerator for an
enumeration type that is a member of a base class of the class being defined.
\enterexample

\begin{codeblock}
class C {
	int g();
};

class D2 : public B {
	using B::f;             // OK: \tcode{B} is a base of \tcode{D2}
	using B::e;             // OK: \tcode{e} is an enumerator of base \tcode{B}
	using B::x;             // OK: \tcode{x} is a union member of base \tcode{B}
	using C::g;		// error: \tcode{C} isn't a base of \tcode{D2}
};
\end{codeblock}
\exitexampleb
\enternote
since constructors and destructors do not have names, a
\grammarterm{using-declaration} cannot refer to a constructor or a
destructor for a base class. Since specializations of member templates
for conversion functions are not found by name lookup, they are not
considered when a \grammarterm{using-declaration} specifies a conversion
function~(\ref{temp.mem}).
\exitnote
If an assignment operator brought from a base class into a derived class
scope has the signature of a copy-assignment operator for the derived
class~(\ref{class.copy}), the \grammarterm{using-declaration} does not by
itself suppress the implicit declaration of the derived class
copy-assignment operator; the copy-assignment operator from the base
class is hidden or overridden by the implicitly-declared
copy-assignment operator of the derived class, as described below.

\pnum
A \grammarterm{using-declaration} shall not name a \grammarterm{template-id}.
\enterexample

\begin{codeblock}
class A {
public:
	template <class T> void f(T);
	template <class T> struct X { };
};
class B : public A {
public:
	using A::f<double>;     // ill-formed
	using A::X<int>;        // ill-formed
};
\end{codeblock}
\exitexampleb

\pnum
A \grammarterm{using-declaration} for a class member shall be a
\grammarterm{member-declaration}.
\enterexample

\begin{codeblock}
struct X {
	int i;
	static int s;
};

void f()
{
	using X::i;		// error: \tcode{X::i} is a class member
				// and this is not a member declaration.
	using X::s;		// error: \tcode{X::s} is a class member
				// and this is not a member declaration.
}
\end{codeblock}
\exitexampleb

\pnum
Members declared by a \grammarterm{using-declaration} can be referred to by
explicit qualification just like other member
names~(\ref{namespace.qual}). In a \grammarterm{using-declaration}, a
prefix \tcode{::} refers to the global namespace.
\enterexample

\begin{codeblock}
void f();

namespace A {
	void g();
}

namespace X {
	using ::f;		// global \tcode{f}
	using A::g;		// \tcode{A}'s \tcode{g}
}

void h()
{
	X::f();			// calls \tcode{::f}
	X::g();			// calls \tcode{A::g}
}
\end{codeblock}
\exitexampleb

\pnum
A \grammarterm{using-declaration} is a \grammarterm{declaration} and can
therefore be used repeatedly where (and only where) multiple
declarations are allowed.
\enterexample

\begin{codeblock}
namespace A {
	int i;
}

namespace A1 {
	using A::i;
	using A::i;		// OK: double declaration
}

void f()
{
	using A::i;
	using A::i;		// error: double declaration
}

class B {
public:
	int i;
};

class X : public B {
	using B::i;
	using B::i;		// error: double member declaration
};
\end{codeblock}
\exitexampleb

\pnum
The entity declared by a \grammarterm{using-declaration} shall be known in
the context using it according to its definition at the point of the
\grammarterm{using-declaration}. Definitions added to the namespace after
the \grammarterm{using-declaration} are not considered when a use of the
name is made.
\enterexample

\begin{codeblock}
namespace A {
	void f(int);
}

using A::f;			// \tcode{f} is a synonym for \tcode{A::f};
				// that is, for \tcode{A::f(int)}.
namespace A {
	void f(char);
}

void foo()
{
	f('a');			// calls \tcode{f(int)},
}				// even though \tcode{f(char)} exists.

void bar()
{
	using A::f;		// \tcode{f} is a synonym for \tcode{A::f};
				// that is, for \tcode{A::f(int)} and \tcode{A::f(char)}.
	f('a');			// calls \tcode{f(char)}
}
\end{codeblock}
\exitexampleb
\enternote
partial specializations of class templates are found by looking up the
primary class template and then considering all partial specializations
of that template. If a \grammarterm{using-declaration} names a class
template, partial specializations introduced after the
\grammarterm{using-declaration} are effectively visible because the primary
template is visible~(\ref{temp.class.spec}).
\exitnote

\pnum
Since a \grammarterm{using-declaration} is a declaration, the restrictions
on declarations of the same name in the same declarative
region~(\ref{basic.scope}) also apply to \grammarterm{using-declaration}{s}.
\enterexample

\begin{codeblock}
namespace A {
	int x;
}

namespace B {
	int i;
	struct g { };
	struct x { };
	void f(int);
	void f(double);
	void g(char);		// OK: hides \tcode{struct g}
}

void func()
{
	int i;
	using B::i;		// error: \tcode{i} declared twice
	void f(char);
	using B::f;		// OK: each \tcode{f} is a function
	f(3.5);			// calls \tcode{B::f(double)}
	using B::g;
	g('a');			// calls \tcode{B::g(char)}
	struct g g1;		// \tcode{g1} has class type \tcode{B::g}
	using B::x;
	using A::x;		// OK: hides \tcode{struct B::x}
	x = 99;			// assigns to \tcode{A::x}
	struct x x1;		// \tcode{x1} has class type \tcode{B::x}
}
\end{codeblock}
\exitexampleb

\pnum
If a function declaration in namespace scope or block scope has the same
name and the same parameter types as a function introduced by a
\grammarterm{using-declaration}, and the declarations do not declare the
same function, the program is ill-formed.
\enternote
two \grammarterm{using-declaration}{s} may introduce functions with the same
name and the same parameter types. If, for a call to an unqualified
function name, function overload resolution selects the functions
introduced by such \grammarterm{using-declaration}{s}, the function call is
ill-formed.\\
\enterexample

\begin{codeblock}
namespace B {
	void f(int);
	void f(double);
}
namespace C {
	void f(int);
	void f(double);
	void f(char);
}

void h()
{
	using B::f;		// \tcode{B::f(int)} and \tcode{B::f(double)}
	using C::f;		// \tcode{C::f(int)}, \tcode{C::f(double)}, and \tcode{C::f(char)}
	f('h');			// calls \tcode{C::f(char)}
	f(1);			// error: ambiguous: \tcode{B::f(int)} or \tcode{C::f(int)}?
	void f(int);		// error:
				// \tcode{f(int)} conflicts with \tcode{C::f(int)} and \tcode{B::f(int)}
}
\end{codeblock}
\exitexampleb
\exitnote

\pnum
\indextext{name hiding!using-declaration and}%
When a \grammarterm{using-declaration} brings names from a base class into
a derived class scope, member functions in the derived class override
and/or hide member functions with the same name and parameter types in a base
class (rather than conflicting).
\enterexample

\begin{codeblock}
struct B {
	virtual void f(int);
	virtual void f(char);
	void g(int);
	void h(int);
};

struct D : B {
	using B::f;
	void f(int);		// OK: \tcode{D::f(int)} overrides \tcode{B::f(int)};

	using B::g;
	void g(char);		// OK

	using B::h;
	void h(int);		// OK: \tcode{D::h(int)} hides \tcode{B::h(int)}
};

void k(D* p)
{
	p->f(1);		// calls \tcode{D::f(int)}
	p->f('a');		// calls \tcode{B::f(char)}
	p->g(1);		// calls \tcode{B::g(int)}
	p->g('a');		// calls \tcode{D::g(char)}
}
\end{codeblock}
\exitexampleb
\enternote
two \grammarterm{using-declaration}{s} may introduce functions with the
same name and the same parameter types. If, for a call to an unqualified
function name, function overload resolution selects the functions introduced
by such \grammarterm{using-declaration}{s}, the function call is ill-formed.
\exitnote

\pnum
\indextext{overloading!using-declaration and}%
For the purpose of overload resolution, the functions which are
introduced by a \grammarterm{using-declaration} into a derived class will
be treated as though they were members of the derived class. In
particular, the implicit \tcode{this} parameter shall be treated as if
it were a pointer to the derived class rather than to the base class.
This has no effect on the type of the function, and in all other
respects the function remains a member of the base class.

\pnum
\indextext{access control!using-declaration and}%
All instances of the name mentioned in a \grammarterm{using-declaration}
shall be accessible. In particular, if a derived class uses a
\grammarterm{using-declaration} to access a member of a base class, the
member name shall be accessible. If the name is that of an overloaded
member function, then all functions named shall be accessible. The base
class members mentioned by a \grammarterm{using-declaration} shall be
visible in the scope of at least one of the direct base classes of the
class where the \grammarterm{using-declaration} is specified. \enternote
because a \grammarterm{using-declaration} designates a base class member
(and not a member subobject or a member function of a base class
subobject), a \grammarterm{using-declaration} cannot be used to resolve
inherited member ambiguities. For example,

\begin{codeblock}
struct A { int x(); };
struct B : A { };
struct C : A {
    using A::x;
    int x(int);
};

struct D : B, C {
    using C::x;
    int x(double);
};
int f(D* d) {
    return d->x();		// ambiguous: \tcode{B::x} or \tcode{C::x}
}
\end{codeblock}
\exitnote

\pnum
The alias created by the \grammarterm{using-declaration} has the usual
accessibility for a \grammarterm{member-declaration}.
\enterexample

\begin{codeblock}
class A {
private:
	void f(char);
public:
	void f(int);
protected:
	void g();
};

class B : public A {
	using A::f;		// error: \tcode{A::f(char)} is inaccessible
public:
	using A::g;		// \tcode{B::g} is a public synonym for \tcode{A::g}
};
\end{codeblock}
\exitexampleb

\pnum
\enternote
use of \grammarterm{access-declarations}~(\ref{class.access.dcl}) is
deprecated; member \grammarterm{using-declaration}{s} provide a better
alternative.
\exitnote
\indextext{using-declaration|)}

\rSec2[namespace.udir]{Using directive}%
\indextext{using-directive|(}

\begin{bnf}
\nontermdef{using-directive}\br
    \terminal{using  namespace ::\opt} nested-name-specifier\opt namespace-name \terminal{;}
\end{bnf}

A \grammarterm{using-directive} shall not appear in class scope, but may
appear in namespace scope or in block scope.
\enternote
when looking up a \grammarterm{namespace-name} in a
\grammarterm{using-directive}, only namespace names are considered,
see~\ref{basic.lookup.udir}.
\exitnote

\pnum
A \grammarterm{using-directive} specifies that the names in the nominated
namespace can be used in the scope in which the
\grammarterm{using-directive} appears after the \grammarterm{using-directive}.
During unqualified name lookup~(\ref{basic.lookup.unqual}), the names
appear as if they were declared in the nearest enclosing namespace which
contains both the \grammarterm{using-directive} and the nominated
namespace.
\enternote
in this context, ``contains'' means ``contains directly or indirectly''.
\exitnote

A \grammarterm{using-directive} does not add any members to the declarative
region in which it appears.
\enterexample

\begin{codeblock}
namespace A {
	int i;
	namespace B {
		namespace C {
			int i;
		}
		using namespace A::B::C;
		void f1() {
			i = 5;		// OK, \tcode{C::i} visible in \tcode{B} and hides \tcode{A::i}
		}
	}
	namespace D {
		using namespace B;
		using namespace C;
		void f2() {
			i = 5;		// ambiguous, \tcode{B::C::i} or \tcode{A::i}?
		}
	}
	void f3() {
		i = 5;		// uses \tcode{A::i}
	}
}
void f4() {
	i = 5;			// ill-formed; neither \tcode{i} is visible
}
\end{codeblock}
\exitexample

\pnum
The \grammarterm{using-directive} is transitive: if a scope contains a
\grammarterm{using-directive} that nominates a second namespace that itself
contains \grammarterm{using-directive}{s}, the effect is as if the
\grammarterm{using-directive}{s} from the second namespace also appeared in
the first.
\enterexample

\begin{codeblock}
namespace M {
	int i;
}

namespace N {
	int i;
	using namespace M;
}

void f()
{
	using namespace N;
	i = 7;			// error: both \tcode{M::i} and \tcode{N::i} are visible
}
\end{codeblock}

For another example,

\begin{codeblock}
namespace A {
	int i;
}
namespace B {
	int i;
	int j;
	namespace C {
		namespace D {
			using namespace A;
			int j;
			int k;
			int a = i;	// \tcode{B::i} hides \tcode{A::i}
		}
		using namespace D;
		int k = 89;	// no problem yet
		int l = k;	// ambiguous: \tcode{C::k} or \tcode{D::k}
		int m = i;	// \tcode{B::i} hides \tcode{A::i}
		int n = j;	// \tcode{D::j} hides \tcode{B::j}
	}
}
\end{codeblock}
\exitexampleb

\pnum
If a namespace is extended by an
\grammarterm{extension-namespace-definition} after a
\grammarterm{using-directive} for that namespace is given, the additional
members of the extended namespace and the members of namespaces
nominated by \grammarterm{using-directive}{s} in the
\grammarterm{extension-namespace-definition} can be used after the
\grammarterm{extension-namespace-definition}.

\pnum
If name lookup finds a declaration for a name in two different
namespaces, and the declarations do not declare the same entity and do
not declare functions, the use of the name is ill-formed.
\enternote
in particular, the name of an object, function or enumerator does not
hide the name of a class or enumeration declared in a different
namespace. For example,

\begin{codeblock}
namespace A {
	class X { };
	extern "C"   int g();
	extern "C++" int h();
}
namespace B {
	void X(int);
	extern "C"   int g();
	extern "C++" int h(int);
}
using namespace A;
using namespace B;

void f() {
	X(1);			// error: name \tcode{X} found in two namespaces
	g();			// okay: name \tcode{g} refers to the same entity
	h();			// error: name \tcode{h} found in two namespaces
}
\end{codeblock}
\exitnoteb

\pnum
\indextext{overloading!using directive and}%
During overload resolution, all functions from the transitive search are
considered for argument matching. The set of declarations found by the
transitive search is unordered.
\enternote
in particular, the order in which namespaces were considered and the
relationships among the namespaces implied by the
\grammarterm{using-directive}{s} do not cause preference to be given to any
of the declarations found by the search.
\exitnote
An ambiguity exists if the best match finds two functions with the same
signature, even if one is in a namespace reachable through
\grammarterm{using-directive}{s} in the namespace of the other.\footnote{During
name lookup in a class hierarchy, some ambiguities may be
resolved by considering whether one member hides the other along some
paths~(\ref{class.member.lookup}). There is no such disambiguation when
considering the set of names found as a result of following
\grammarterm{using-directive}{s}.}\\
\enterexample

\begin{codeblock}
namespace D {
	int d1;
	void f(char);
}
using namespace D;

int d1;				// OK: no conflict with \tcode{D::d1}

namespace E {
	int e;
	void f(int);
}

namespace D {			// namespace extension
	int d2;
	using namespace E;
	void f(int);
}

void f()
{
	d1++;			// error: ambiguous \tcode{::d1} or \tcode{D::d1}?
	::d1++;			// OK
	D::d1++;		// OK
	d2++;			// OK: \tcode{D::d2}
	e++;			// OK: \tcode{E::e}
	f(1);			// error: ambiguous: \tcode{D::f(int)} or \tcode{E::f(int)}?
	f('a');			// OK: \tcode{D::f(char)}
}
\end{codeblock}
\exitexampleb%
\indextext{using-directive|)}%
\indextext{namespaces|)}

\rSec1[dcl.asm]{The \tcode{asm} declaration}%
\indextext{declaration!\idxcode{asm}}%
\indextext{assembler}%
\indextext{\idxcode{asm}!implementation-defined}

\pnum
An \tcode{asm} declaration has the form

\begin{bnf}
\nontermdef{asm-definition}\br
    \terminal{asm (} string-literal \terminal{) ;}
\end{bnf}

The meaning of an \tcode{asm} declaration is
\impldef{meaning of \tcode{asm} declaration}.
\enternote
Typically it is used to pass information through the implementation to
an assembler.
\exitnote

\rSec1[dcl.link]{Linkage specifications}%
\indextext{specification!linkage|(}

\pnum
All function types, function names, and variable
names have a \term{language linkage}.
\enternote
Some of the properties associated with an entity with language linkage
are specific to each implementation and are not described here. For
example, a particular language linkage may be associated with a
particular form of representing names of objects and functions with
external linkage, or with a particular calling convention, etc.
\exitnote
The default language linkage of all function types, function names, and
variable names is \Cpp language linkage. Two function types with
different language linkages are distinct types even if they are
otherwise identical.

\pnum
Linkage~(\ref{basic.link}) between \Cpp and  non-\Cpp code fragments can
be achieved using a \grammarterm{linkage-specification}:

\indextext{\idxgram{linkage-specification}}%
\indextext{specification!linkage!\idxcode{extern}}%
%
\begin{bnf}
\nontermdef{linkage-specification}\br
    \terminal{extern} string-literal \terminal{\{} declaration-seq\opt \terminal{\}}\br
    \terminal{extern} string-literal declaration
\end{bnf}

The \grammarterm{string-literal} indicates the required language linkage.
The meaning of the \grammarterm{string-literal} is
\impldef{semantics of linkage specifiers}.
A \grammarterm{linkage-specification} with a string that is unknown to the
implementation is ill-formed. When the \grammarterm{string-literal} in a
\grammarterm{linkage-specification} names a programming language, the
spelling of the programming language's name is implementation-defined.
\enternote
it is recommended that the spelling be
taken from the document defining that language. For example, \tcode{Ada}
(not \tcode{ADA}) and \tcode{Fortran} or \tcode{FORTRAN} (depending on
the vintage). The semantics of a language linkage other than \Cpp or C
are implementation-defined.
\exitnote

\pnum
\indextext{specification!linkage!implementation-defined}%
Every implementation shall provide for linkage to functions written in
the C programming language,
\indextext{C!linkage~to}%
\tcode{"C"}, and linkage to \Cpp functions, \tcode{"C++"}.
\enterexample

\begin{codeblock}
complex sqrt(complex);		// \Cpp linkage by default
extern "C" {
    double sqrt(double);        // C linkage
}
\end{codeblock}
\exitexampleb

\pnum
\indextext{specification!linkage!nesting}%
Linkage specifications nest. When linkage specifications nest, the
innermost one determines the language linkage. A linkage specification
does not establish a scope. A \grammarterm{linkage-specification} shall
occur only in namespace scope~(\ref{basic.scope}). In a
\grammarterm{linkage-specification}, the specified language linkage applies
to the function types of all function declarators, function names, and
variable names introduced by the declaration(s).
\enterexample

\begin{codeblock}
extern "C" void f1(void(*pf)(int));
                                // the name \tcode{f1} and its function type have C language
                                // linkage; \tcode{pf} is a pointer to a C function
extern "C" typedef void FUNC();
FUNC f2;                        // the name \tcode{f2} has \Cpp language linkage and the
                                // function's type has C language linkage
extern "C" FUNC f3;             // the name of function \tcode{f3} and the function's type
                                // have C language linkage
void (*pf2)(FUNC*);             // the name of the variable \tcode{pf2} has \Cpp linkage and
                                // the type of \tcode{pf2} is pointer to \Cpp function that
                                // takes one parameter of type pointer to C function
\end{codeblock}
\exitexampleb
\indextext{class!linkage~specification}%
A C language linkage is ignored for the names of class members and the
member function type of class member functions.
\enterexample

\begin{codeblock}
extern "C" typedef void FUNC_c();
class C {
     void mf1(FUNC_c*);         // the name of the function \tcode{mf1} and the member
                                // function's type have \Cpp language linkage; the
                                // parameter has type pointer to C function
     FUNC_c mf2;                // the name of the function \tcode{mf2} and the member
                                // function's type have \Cpp language linkage
     static FUNC_c* q;          // the name of the data member \tcode{q} has \Cpp language
                                // linkage and the data member's type is pointer to
                                // C function
};

extern "C" {
    class X {
	void mf();              // the name of the function \tcode{mf} and the member
                                // function's type have \Cpp language linkage
	void mf2(void(*)());    // the name of the function \tcode{mf2} has \Cpp language
                                // linkage; the parameter has type pointer to
                                // C function
    };
}
\end{codeblock}
\exitexampleb

\pnum
If two declarations of the same function or object specify different
\grammarterm{linkage-specification}{s} (that is, the
\grammarterm{linkage-specification}{s} of these declarations specify
different \grammarterm{string-literal}{s}), the program is ill-formed if
the declarations appear in the same translation unit, and the one
definition rule~(\ref{basic.def.odr}) applies if the declarations appear
in different translation units.
Except for functions with \Cpp linkage, a function declaration without a
linkage specification shall not precede the first linkage specification
for that function. A function can be declared without a linkage
specification after an explicit linkage specification has been seen; the
linkage explicitly specified in the earlier declaration is not affected
by such a function declaration.

\pnum
\indextext{function!linkage~specification overloaded}%
At most one function with a particular name can have C language linkage.
Two declarations for a function with C language linkage with the same
function name (ignoring the namespace names that qualify it) that appear
in different namespace scopes refer to the same function. Two
declarations for an object with C language linkage with the same name
(ignoring the namespace names that qualify it) that appear in different
namespace scopes refer to the same object.
\enternote
because of the one definition rule~(\ref{basic.def.odr}), only one
definition for a function or object with C linkage may appear in the
program; that is, such a function or object must not be defined in more
than one namespace scope. For example,

\begin{codeblock}
namespace A {
    extern "C" int f();
    extern "C" int g() { return 1; }
    extern "C" int h();
}

namespace B {
    extern "C" int f();			// \tcode{A::f} and \tcode{B::f} refer
					// to the same function
    extern "C" int g() { return 1; }	// ill-formed, the function \tcode{g}
					// with C language linkage
					// has two definitions
}

int A::f() { return 98; }		// definition for the function \tcode{f}
					// with C language linkage
extern "C" int h() { return 97; }
					// definition for the function \tcode{h}
					// with C language linkage
					// \tcode{A::h} and \tcode{::h} refer to the same function
\end{codeblock}
\exitnoteb

\pnum
Except for functions with internal linkage, a function first declared in a
\grammarterm{linkage-specification} behaves as a function with external
linkage.
\enterexample

\begin{codeblock}
extern "C" double f();
static double f();              // error
\end{codeblock}

is ill-formed~(\ref{dcl.stc}).
\exitexample
The form of \grammarterm{linkage-specification} that contains a
brace-enclosed \grammarterm{declaration-seq} does not affect whether the
contained declarations are definitions or not~(\ref{basic.def}); the form
of \grammarterm{linkage-specification} directly containing a single
declaration is treated as an \tcode{extern} specifier~(\ref{dcl.stc}) for
the purpose of determining whether the contained declaration is a
definition.
\enterexample

\begin{codeblock}
extern "C" int i;		// declaration
extern "C" {
	int i;			// definition
}
\end{codeblock}

\exitexampleb
A \grammarterm{linkage-specification} directly containing a single
declaration shall not specify a storage class.
\enterexample

\begin{codeblock}
extern "C" static void f();	// error
\end{codeblock}
\exitexampleb

\pnum
\enternote
because the language linkage is part of a function type, when a pointer to
C function (for example) is dereferenced, the function to which it refers is
considered a C function.
\exitnote

\pnum
\indextext{object!linkage~specification}%
\indextext{linkage!implementation-defined object}%
Linkage from \Cpp to objects defined in other languages and to objects
defined in \Cpp from other languages is implemen\-tation-defined and
language-dependent. Only where the object layout strategies of two
language implementations are similar enough can such linkage be
achieved.%
\indextext{specification!linkage|)}
