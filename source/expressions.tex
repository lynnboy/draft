\rSec0[expr]{Expressions}

%gram: \rSec1[gram.expr]{Expressions}
%gram:

\indextext{\idxcode{operator new}|seealso{\tcode{new}}}%
\indextext{\idxcode{operator delete}|seealso{\tcode{delete}}}%
\indextext{usual arithmetic conversions|see{conversion, usual arithmetic}}%
\indextext{\idxcode{==}|see{equality~operator}}%
\indextext{\idxcode{"!=}|see{inequality~operator}}
\indextext{\idxcode{static_cast}|see{cast, static}}%
\indextext{\idxcode{dynamic_cast}|see{cast, dynamic}}%
\indextext{\idxcode{const_cast}|see{cast, const}}%
\indextext{\idxcode{reinterpret_cast}|see{cast, reinterpret}}

\pnum
\indextext{expression|(}%
\enternote 
Clause~\ref{expr} defines the syntax, order of evaluation, and meaning
of expressions.
An expression is a sequence of operators and operands that specifies a
computation. An expression can result in a value and can cause side
effects.

\pnum
\indextext{operator!overloaded}%
Operators can be overloaded, that is, given meaning when applied to
expressions of class type~(clause \ref{class}) or enumeration
type~(\ref{dcl.enum}). Uses of overloaded operators are transformed into
function calls as described in~\ref{over.oper}. Overloaded operators
obey the rules for syntax specified in clause~\ref{expr}, but the
requirements of operand type, lvalue, and evaluation order are replaced
by the rules for function call. Relations between operators, such as
\tcode{++a} meaning \tcode{a+=1}, are not guaranteed for overloaded
operators~(\ref{over.oper}), and are not guaranteed for operands of type
\tcode{bool}.
\exitnoteb

\pnum
Clause~\ref{expr} defines the effects of operators when applied to types
for which they have not been overloaded. Operator overloading shall not
modify the rules for the \term{built-in operators}, that
is, for operators applied to types for which they are defined by this
Standard. However, these built-in operators participate in overload
resolution, and as part of that process user-defined conversions will be
considered where necessary to convert the operands to types appropriate
for the built-in operator. If a built-in operator is selected, such
conversions will be applied to the operands before the operation is
considered further according to the rules in clause~\ref{expr};
see~\ref{over.match.oper},~\ref{over.built}.

\pnum
Except where noted, the order of evaluation of operands of individual
operators and subexpressions of individual expressions, and the order
in which side effects take place, is unspecified.\footnote{The
precedence of operators is not directly specified, but it can be
derived from the syntax.} Between the previous and next sequence point
a scalar object shall have its stored value modified at most once by
the evaluation of an expression. Furthermore, the prior value shall be
accessed only to determine the value to be stored. The requirements of
this paragraph shall be met for each allowable ordering of the
subexpressions of a full expression; otherwise the behavior is undefined.
\enterexample

\begin{codeblock}
i = v[i++];			// the behavior is unspecified
i = 7, i++, i++;		// \tcode{i} becomes \tcode{9}

i = ++i + 1;			// the behavior is unspecified
i = i + 1;			// the value of \tcode{i} is incremented
\end{codeblock}

\exitexampleb

\pnum
\indextext{exception!arithmetic}%
\indextext{exception!undefined arithmetic}%
\indextext{overflow!undefined}%
\indextext{zero!division by undefined}%
\indextext{zero!remainder undefined}%
If during the evaluation of an expression, the result is not
mathematically defined or not in the range of representable values for
its type, the behavior is undefined, unless such an expression is a
constant expression~(\ref{expr.const}), in which case the program is
ill-formed.
\enternote 
\indextext{overflow}%
most existing implementations of \Cpp ignore integer overflows.
Treatment of division by zero, forming a remainder using a zero divisor,
and all floating point exceptions vary among machines, and is usually
adjustable by a library function.
\exitnote 

\pnum
\indextext{expression!reference}%
If an expression initially has the type ``reference to
\tcode{T}''~(\ref{dcl.ref},~\ref{dcl.init.ref}), the type is adjusted to
``\tcode{T}'' prior to any further analysis, the expression designates the
object or function denoted by the reference, and the expression
is an lvalue.

\pnum
An expression designating an object is called an \defn{object-expression}.

\pnum
Whenever an lvalue expression appears as an operand of an operator that
expects an rvalue for that operand, the
lvalue-to-rvalue~(\ref{conv.lval}), array-to-pointer~(\ref{conv.array}),
or function-to-pointer~(\ref{conv.func}) standard conversions are
applied to convert the expression to an rvalue.
\enternote 
because cv-qualifiers are removed from the type of an expression of
non-class type when the expression is converted to an rvalue, an lvalue
expression of type \tcode{const int} can, for example, be used where
an rvalue expression of type \tcode{int} is required.
\exitnote 

\pnum
\indextext{conversion!usual arithmetic}%
Many binary operators that expect operands of arithmetic or enumeration
type cause conversions and yield result types in a similar way. The
purpose is to yield a common type, which is also the type of the result.
This pattern is called the \term{usual arithmetic conversions},
which are defined as follows:

\begin{itemize}
\item If either operand is of type \tcode{long} \tcode{double}, the
other shall be converted to \tcode{long} \tcode{double}.

\item Otherwise, if either operand is \tcode{double}, the other shall be
converted to \tcode{double}.

\item Otherwise, if either operand is \tcode{float}, the other shall be
converted to \tcode{float}.

\item Otherwise, the integral promotions~(\ref{conv.prom}) shall be
performed on both operands.\footnote{As a consequence, operands of type \tcode{bool},
\tcode{wchar_t}, or an enumerated type are converted to some integral type.}

\item Then, if either operand is \tcode{unsigned} \tcode{long} the
other shall be converted to \tcode{unsigned} \tcode{long}.

\item Otherwise, if one operand is a \tcode{long} \tcode{int} and the
other \tcode{unsigned} \tcode{int}, then if a \tcode{long} \tcode{int}
can represent all the values of an \tcode{unsigned} \tcode{int}, the
\tcode{unsigned} \tcode{int} shall be converted to a \tcode{long}
\tcode{int}; otherwise both operands shall be converted to \tcode{unsigned}
\tcode{long} \tcode{int}.

\item Otherwise, if either operand is \tcode{long}, the other shall be
converted to \tcode{long}.

\item Otherwise, if either operand is \tcode{unsigned}, the other shall
be converted to \tcode{unsigned}.
\end{itemize}

\enternote otherwise, the only remaining case is that both operands are
\tcode{int} \exitnote

\pnum
The values of the floating operands and the results of
floating expressions may be represented in greater precision and range
than that required by the type; the types are not changed thereby.\footnote{The
cast and assignment operators must still perform their specific conversions
as described in~\ref{expr.cast}, \ref{expr.static.cast} and~\ref{expr.ass}.}

\rSec1[expr.prim]{Primary expressions}%
\indextext{expression!primary|(}

\pnum
Primary expressions are literals, names, and names qualified by the
scope resolution operator \tcode{::}.

\begin{bnf}
\nontermdef{primary-expression}\br
    literal\br
    \terminal{this}\br
    \terminal{(} expression \terminal{)}\br
    id-expression
\end{bnf}

\begin{bnf}
\nontermdef{id-expression}\br
    unqualified-id\br
    qualified-id
\end{bnf}

\begin{bnf}
\nontermdef{unqualified-id}\br
    identifier\br
    operator-function-id\br
    conversion-function-id\br
    \terminal{\tilde} class-name\br
    template-id
\end{bnf}

\pnum
A
\indextext{literal}%
\indextext{constant}%
\grammarterm{literal} 
is a primary expression.
Its type depends on its form~(\ref{lex.literal}).
A string literal is an lvalue; all other literals are rvalues.

\pnum
\indextext{\idxcode{this}}%
The keyword \tcode{this} names a pointer to the object for which a nonstatic member
function~(\ref{class.this}) is invoked. The keyword \tcode{this} shall be
used only inside a nonstatic class member function body~(\ref{class.mfct})
or in a constructor \grammarterm{mem-initializer}~(\ref{class.base.init}).
The type of the expression is a pointer to the function's
class~(\ref{class.this}), possibly with cv-qualifiers on the class type.
The expression is an rvalue.

\pnum
The operator \tcode{::} followed by an \grammarterm{identifier}, a
\grammarterm{qualified-id}, or an \grammarterm{operator-function-id}
is a \grammarterm{primary-expression}. Its type is specified by the
declaration of the identifier, \grammarterm{qualified-id}, or
\grammarterm{operator-function-id}. The result is the entity denoted by
the identifier, \grammarterm{qualified-id}, or
\grammarterm{operator-function-id}. The result is an lvalue if the entity
is a function or variable. The identifier, \grammarterm{qualified-id}, or
\grammarterm{operator-function-id} shall have global namespace scope or be
visible in global scope because of a
\grammarterm{using-directive}~(\ref{namespace.udir}).
\enternote the use of \tcode{::} allows a type, an object, a function,
an enumerator, or a namespace declared in the global namespace to be
referred to even if its identifier has been hidden~(\ref{basic.lookup.qual}).
\exitnote

\pnum
\indextext{expression!parenthesized}%
A parenthesized expression is a primary expression whose type and value
are identical to those of the enclosed expression. The presence of
parentheses does not affect whether the expression is an lvalue. The
parenthesized expression can be used in exactly the same contexts as
those where the enclosed expression can be used, and with the same
meaning, except as otherwise indicated.

\pnum
\indextext{name}%
\indextext{id-expression}%
An \grammarterm{id-expression} is a restricted form of a
\grammarterm{primary-expression}.
\enternote 
an \grammarterm{id-expression} can appear after \tcode{.} and \tcode{->}
operators~(\ref{expr.ref}).
\exitnote 

\pnum
\indextext{identifier}%
An \grammarterm{identifier} is an \grammarterm{id-expression} provided it has
been suitably declared (clause~\ref{dcl.dcl}).
\enternote 
for \grammarterm{operator-function-id}{s}, see~\ref{over.oper}; for
\grammarterm{conversion-function-id}{s}, see~\ref{class.conv.fct}; for
\grammarterm{template-id}{s}, see~\ref{temp.names}. A \grammarterm{class-name}
prefixed by \tcode{\tilde} denotes a destructor; see~\ref{class.dtor}.
Within the definition of a nonstatic member function, an
\grammarterm{identifier} that names a nonstatic member is transformed to a
class member access expression~(\ref{class.mfct.nonstatic}).
\exitnote 
The type of the expression is the type of the \grammarterm{identifier}. The
result is the entity denoted by the identifier. The result is an lvalue
if the entity is a function, variable, or data member.

\indextext{operator!scope~resolution}%
\indextext{\idxcode{::}|see{scope~resolution~operator}}%
%
\begin{bnf}
\nontermdef{qualified-id}\br
    \terminal{::}\opt nested-name-specifier \terminal{template}\opt unqualified-id\br
    \terminal{::} identifier\br
    \terminal{::} operator-function-id\br
    \terminal{::} template-id
\end{bnf}

\indextext{operator!scope~resolution}%
\indextext{name~hiding}%
%
\begin{bnf}
\nontermdef{nested-name-specifier}\br
    class-or-namespace-name \terminal{::} nested-name-specifier\opt\br
    class-or-namespace-name \terminal{::} \terminal{template} nested-name-specifier
\end{bnf}

\begin{bnf}
\nontermdef{class-or-namespace-name}\br
    class-name\br
    namespace-name
\end{bnf}

A \grammarterm{nested-name-specifier} that names a class, optionally
followed by the keyword \tcode{template}~(\ref{temp.names}), and then
followed by the name of a member of either that class~(\ref{class.mem})
or one of its base classes (clause~\ref{class.derived}), is a
\indextext{id!qualified}%
\grammarterm{qualified-id};~\ref{class.qual} describes name lookup for
class members that appear in \grammarterm{qualified-ids}. The result is the
member. The type of the result is the type of the member. The result is
an lvalue if the member is a static member function or a data member.
\enternote 
a class member can be referred to using a \grammarterm{qualified-id} at any
point in its potential scope~(\ref{basic.scope.class}).
\exitnote 
Where \grammarterm{class-name} \tcode{::} \grammarterm{class-name} is used,
and the two \grammarterm{class-name}{s} refer to the same class, this
notation names the constructor~(\ref{class.ctor}). Where
\grammarterm{class-name} \tcode{::\tilde} \grammarterm{class-name} is used,
the two \grammarterm{class-name}{s} shall refer to the same class; this
notation names the destructor~(\ref{class.dtor}).
\enternote 
a \grammarterm{typedef-name} that names a class is a
\grammarterm{class-name}~(\ref{dcl.typedef}). Except as the
\grammarterm{identifier} in the declarator for a constructor or destructor
definition outside of a class
\grammarterm{member-specification}~(\ref{class.ctor}, \ref{class.dtor}),
\grammarterm{typedef-name} that names a class may be used in a
\grammarterm{qualified-id} to refer to a constructor or destructor.
\exitnote 

\pnum
A \grammarterm{nested-name-specifier} that names a
namespace~(\ref{basic.namespace}), followed by the name of a member of
that namespace (or the name of a member of a namespace made visible by a
\grammarterm{using-directive}) is a
\indextext{id!qualified}%
\grammarterm{qualified-id};~\ref{namespace.qual} describes name lookup for
namespace members that appear in \grammarterm{qualified-ids}. The result is
the member. The type of the result is the type of the member. The result
is an lvalue if the member is a function or a variable.

\pnum
In a \grammarterm{qualified-id}, if the \grammarterm{id-expression} is a
\grammarterm{conversion-function-id}, its \grammarterm{conversion-type-id}
shall denote the same type in both the context in which the entire
\grammarterm{qualified-id} occurs and in the context of the class denoted
by the \grammarterm{nested-name-specifier}.

\pnum
An \grammarterm{id-expression} that denotes a nonstatic data member or
nonstatic member function of a class can only be used:

\begin{itemize}
\item as part of a class member access~(\ref{expr.ref}) in which the
object-expression refers to the member's class or a class derived from
that class, or

\item to form a pointer to member~(\ref{expr.unary.op}), or

\item in the body of a nonstatic member function of that class or of a
class derived from that class~(\ref{class.mfct.nonstatic}), or

\item in a \grammarterm{mem-initializer} for a constructor for that class
or for a class derived from that class~(\ref{class.base.init}).
\end{itemize}

\pnum
A \grammarterm{template-id} shall be used as an
\grammarterm{unqualified-id} only as specified in~\ref{temp.explicit},
\ref{temp.spec}, and \ref{temp.class.spec}.

\rSec1[expr.post]{Postfix expressions}%
\indextext{expression!postfix|(}

\pnum
Postfix expressions group left-to-right.

\begin{bnf}
\nontermdef{postfix-expression}\br
    primary-expression\br
    postfix-expression \terminal{[} expression \terminal{]}\br
    postfix-expression \terminal{(} expression-list\opt \terminal{)}\br
    simple-type-specifier \terminal{(} expression-list\opt \terminal{)}\br
    \terminal{typename} \terminal{::}\opt nested-name-specifier identifier
	\terminal{(} expression-list\opt \terminal{)}\br
    \terminal{typename} \terminal{::}\opt nested-name-specifier
	\terminal{template}\opt template-id
	\terminal{(} expression-list\opt \terminal{)}\br
    postfix-expression \terminal{. template}\opt id-expression\br
    postfix-expression \terminal{-> template}\opt id-expression\br
    postfix-expression \terminal{.} pseudo-destructor-name\br
    postfix-expression \terminal{->} pseudo-destructor-name\br
    postfix-expression \terminal{++}\br
    postfix-expression \terminal{-{-}}\br
    \terminal{dynamic_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{static_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{reinterpret_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{const_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{typeid (} expression \terminal{)}\br
    \terminal{typeid (} type-id \terminal{)}
\end{bnf}


\begin{bnf}
\nontermdef{expression-list}\br
    assignment-expression\br
    expression-list \terminal{,} assignment-expression
\end{bnf}


\begin{bnf}
\nontermdef{pseudo-destructor-name}\br
    \terminal{::}\opt nested-name-specifier\opt type-name \terminal{::\,\tilde} type-name\br
    \terminal{::}\opt nested-name-specifier \terminal{template} template-id \terminal{::\,\tilde} type-name\br
    \terminal{::}\opt nested-name-specifier\opt \terminal{\tilde} type-name
\end{bnf}

\rSec2[expr.sub]{Subscripting}

\pnum
\indextext{operator!subscripting}%
\indextext{\idxcode{[]}|see{operator, subscripting}}%
A postfix expression followed by an expression in square brackets is a
postfix expression. One of the expressions shall have the type ``pointer
to \tcode{T}'' and the other shall have enumeration or integral type.
The result is an lvalue of type ``\tcode{T}.''
\indextext{type!incomplete}%
The type ``\tcode{T}'' shall be a completely-defined object type.\footnote{This
is true even if the subscript operator is used in the following common idiom:
\tcode{\&x[0]}.}
The expression \tcode{E1[E2]} is identical (by definition) to
\tcode{*((E1)+(E2))}
\enternote 
see~\ref{expr.unary} and~\ref{expr.add} for details of \tcode{*} and
\tcode{+} and~\ref{dcl.array} for details of arrays.
\exitnote 

\rSec2[expr.call]{Function call}

\pnum
\indextext{expression!function~call}%
\indextext{operator!function~call}%
\indextext{\idxcode{()}|see{operator, function~call}}%
There are two kinds of function call: ordinary function call and member
function\footnote{A static member function~(\ref{class.static}) is an ordinary
function.}~(\ref{class.mfct}) call.
A function call is a postfix expression followed by parentheses
containing a possibly empty, comma-separated list of expressions which
constitute the arguments to the function. For an ordinary function call,
the postfix expression shall be either an lvalue that refers to a
function (in which case the function-to-pointer standard
conversion~(\ref{conv.func}) is suppressed on the postfix expression),
or it shall have pointer to function type. Calling a function through an
expression whose function type has a language linkage that is different
from the language linkage of the function type of the called function's
definition is undefined~(\ref{dcl.link}). For a member function call,
the postfix expression shall be an
implicit~(\ref{class.mfct.nonstatic},~\ref{class.static}) or explicit
class member access~(\ref{expr.ref}) whose \grammarterm{id-expression} is a
function member name, or a pointer-to-member
expression~(\ref{expr.mptr.oper}) selecting a function member. The first
expression in the postfix expression is then called the
\defn{object expression}, and the call is as a member of
the object pointed to or referred. In the case of an implicit class
member access, the implied object is the one pointed to by \tcode{this}.
\enternote 
a member function call of the form \tcode{f()} is interpreted as
\tcode{(*this).f()} (see~\ref{class.mfct.nonstatic}).
\exitnote 
If a function or member function name is used, the name can be
overloaded (clause~\ref{over}), in which case the appropriate function
shall be selected according to the rules in~\ref{over.match}. The
function called in a member function call is normally selected according
to the static type of the object expression (clause~\ref{class.derived}),
but if that function is \tcode{virtual} and is not specified using a
\grammarterm{qualified-id} then the function actually called will be the
final overrider~(\ref{class.virtual}) of the selected function in the
dynamic type of the object expression
\enternote 
the dynamic type is the type of the object pointed or referred to by the
current value of the object expression. \ref{class.cdtor}~describes the
behavior of virtual function calls when the object-expression
refers to an object under construction or destruction.
\exitnote 

\pnum
If no declaration of the called function is visible from the scope of
the call the program is ill-formed.

\pnum
The type of the function call expression is the return type of the
statically chosen function (i.e., ignoring the \tcode{virtual} keyword),
even if the type of the function actually called is different.
\indextext{type!incomplete}%
This type shall be a complete object type, a reference type or the type
\tcode{void}.

\pnum
\indextext{function~argument|see{argument}}%
\indextext{function~parameter|see{parameter}}%
\indextext{formal~argument|see{parameter}}%
\indextext{initialization!parameter}%
When a function is called, each parameter~(\ref{dcl.fct}) shall be
initialized~(\ref{dcl.init},~\ref{class.copy},~\ref{class.ctor}) with
its corresponding argument. If the function is a nonstatic member
function, the ``\tcode{this}'' parameter of the function~(\ref{class.this})
shall be initialized with a pointer to the object of the call, converted
as if by an explicit type conversion~(\ref{expr.cast}).
\enternote 
There is no access checking on this conversion; the access
checking is done as part of the (possibly implicit)
class member access operator. See~\ref{class.access.base}.
\exitnote 
When a function is called, the parameters that have object type shall
have completely-defined object type.
\enternote 
this still allows a parameter to be a pointer or reference to an
incomplete class type. However, it prevents a passed-by-value parameter
to have an incomplete class type.
\exitnote 
During the initialization of a parameter, an implementation may avoid
the construction of extra temporaries by combining the conversions on
the associated argument and/or the construction of temporaries with the
initialization of the parameter (see~\ref{class.temporary}). The
lifetime of a parameter ends when the function in which it is defined
returns. The initialization and destruction of each parameter occurs
within the context of the calling function.
\enterexample 
the access of the constructor, conversion functions or destructor is
checked at the point of call in the calling function. If a constructor
or destructor for a function parameter throws an exception, the search
for a handler starts in the scope of the calling function; in
particular, if the function called has a \grammarterm{function-try-block}
(clause~\ref{except}) with a handler that could handle the exception,
this handler is not considered.
\exitexample 
The value of a function call is the value returned by the called
function except in a virtual function call if the return type of the
final overrider is different from the return type of the statically
chosen function, the value returned from the final overrider is
converted to the return type of the statically chosen function.

\pnum
\enternote 
\indextext{type~checking!argument}%
\indextext{function~call}%
\indextext{argument~passing}%
\indextext{value!call~by}%
\indextext{reference!call~by}%
\indextext{argument!reference}%
a function can change the values of its non-const parameters, but these
changes cannot affect the values of the arguments except where a
parameter is of a reference type~(\ref{dcl.ref}); if the reference is to
a const-qualified type, \tcode{const_cast} is required to be used to
cast away the constness in order to modify the argument's value. Where a
parameter is of \tcode{const} reference type a temporary object is
introduced if
needed~(\ref{dcl.type},~\ref{lex.literal},~\ref{lex.string},~\ref{dcl.array},~\ref{class.temporary}).
In addition, it is possible to modify the values of nonconstant objects through
pointer parameters.
\exitnote 

\pnum
\indextext{declaration!ellipsis~in function}%
\indextext{parameter~list!variable}%
A function can be declared to accept fewer arguments (by declaring default
arguments~(\ref{dcl.fct.default})) or more arguments (by using the ellipsis,
\tcode{...}~\ref{dcl.fct}) than the number of
parameters in the function definition~(\ref{dcl.fct.def}).
\enternote 
this implies that, except where the ellipsis (\tcode{...}) is used,
a parameter is available for each argument.
\exitnote 

\pnum
\indextext{ellipsis!conversion~sequence}%
When there is no parameter for a given argument, the argument is passed
in such a way that the receiving function can obtain the value of the
argument by invoking \tcode{va_arg}~(\ref{lib.support.runtime}). The
lvalue-to-rvalue~(\ref{conv.lval}), array-to-pointer~(\ref{conv.array}),
and function-to-pointer~(\ref{conv.func}) standard conversions are
performed on the argument expression. After these conversions, if the
argument does not have arithmetic, enumeration, pointer, pointer to
member, or class type, the program is ill-formed. If the argument has
a non-POD class type (clause~\ref{class}), the behavior is undefined.
If the argument has integral or enumeration type that is subject to the integral
promotions~(\ref{conv.prom}), or a floating point type that is subject to the floating
point promotion~(\ref{conv.fpprom}), the value of the argument is converted to the
promoted type before the call. These promotions are referred to as the \term{default
argument promotions}.

\pnum
\indextext{evaluation!order~of argument}%
\indextext{evaluation!unspecified order~of function~call}%
The order of evaluation of arguments is unspecified. All side effects
of argument expression evaluations take effect before the function is
entered. The order of evaluation of the postfix expression and the
argument expression list is unspecified.

\pnum
\indextext{function~call!recursive}%
Recursive calls are permitted, except to the function named
\tcode{main}~(\ref{basic.start.main}).

\pnum
A function call is an lvalue if and only if the result type is a reference.

\rSec2[expr.type.conv]{Explicit type conversion (functional notation)}

\pnum
\indextext{expression!cast}
\indextext{explicit~type~conversion|see{casting}}%
\indextext{type~conversion,~explicit|see{casting}}%
\indextext{conversion~explicit~type|see{casting}}%
\indextext{casting}%
A \grammarterm{simple-type-specifier}~(\ref{dcl.type}) followed by a
parenthesized \grammarterm{expression-list} constructs a value of the
specified type given the expression list. If the expression list is a
single expression, the type conversion expression is equivalent (in
definedness, and if defined in meaning) to the corresponding cast
expression~(\ref{expr.cast}).
\indextext{type!incomplete}%
If the \grammarterm{simple-type-specifier} specifies a class type, the
class type shall be complete. If the expression list specifies more than
a single value, the type shall be a class with a suitably declared
constructor~(\ref{dcl.init},~\ref{class.ctor}), and the expression
\tcode{T(x1, x2, ...)} is equivalent in effect to the declaration
\tcode{T t(x1, x2, ...);} for some invented temporary variable
\tcode{t}, with the result being the value of \tcode{t} as an rvalue.

\pnum
The expression \tcode{T()}, where \tcode{T} is a
simple-type-specifier~(\ref{dcl.type.simple}) for a non-array complete object
type or the (possibly cv-qualified) \tcode{void} type, creates an rvalue of the
specified type, which is value-initialized~(\ref{dcl.init}; no
initialization is done for the \tcode{void()} case).
\enternote 
if \tcode{T} is a non-class type that is \term{cv-qualified}, the
\grammarterm{cv-qualifier}{s} are ignored when determining the type of the
resulting rvalue~(\ref{basic.lval}).
\exitnote 

\rSec2[expr.pseudo]{Pseudo destructor call}

\pnum
\indextext{expression!pseudo-destructor~call}
\indextext{call!pseudo~destructor}%
\indextext{pseudo-destructor-name}%
The use of a \grammarterm{pseudo-destructor-name} after a dot \tcode{.} or
arrow \tcode{->} operator represents the destructor for the non-class
type named by \grammarterm{type-name}. The result shall only be used as the
operand for the function call operator \tcode{()}, and the result of
such a call has type \tcode{void}. The only effect is the evaluation of
the \grammarterm{postfix-expression} before the dot or arrow.

\pnum
The left-hand side of the dot operator shall be of scalar type. The
left-hand side of the arrow operator shall be of pointer to scalar type.
This scalar type is the object type. The type designated by the
\grammarterm{pseudo-destructor-name} shall be the same as the object type.
Furthermore,
the two \grammarterm{type-name}{s} in a \grammarterm{pseudo-destructor-name} of
the form

\begin{ncbnf}
\terminal{::}\opt nested-name-specifier\opt type-name \terminal{::\,\tilde} type-name
\end{ncbnf}

shall designate the same scalar type. The \cvqual{cv}-unqualified
versions of the object type and of the type designated by the
\grammarterm{pseudo-destructor-name} shall be the same type. 

\rSec2[expr.ref]{Class member access}

\pnum
\indextext{expression!class~member~access}%
\indextext{access control!class member}%
\indextext{syntax!class~member}%
\indextext{semantics!class~member}%
\indextext{operator!class~member~access}%
\indextext{\idxcode{.}|see{operator, class~member~access}}%
\indextext{dot~operator|see{operator, class~member~access}}%
\indextext{operator!class~member~access}%
\indextext{\idxcode{->}|see{operator, class~member~access}}%
\indextext{arrow~operator|see{operator, class~member~access}}%
A postfix expression followed by a dot \tcode{.} or an arrow \tcode{->},
optionally followed by the keyword
\tcode{template}~(\ref{temp.arg.explicit}), and then followed by an
\grammarterm{id-expression}, is a postfix expression. The postfix
expression before the dot or arrow is evaluated;\footnote{This
evaluation happens even if the result is unnecessary to determine
the value of the entire postfix expression, for example if the
\grammarterm{id-expression} denotes a static member.}
the result of that evaluation, together with the
\grammarterm{id-expression}, determines the result of the entire postfix
expression.

\pnum
\indextext{type!incomplete}%
For the first option (dot) the type of the first expression (the
\term{object expression}) shall be ``class object'' (of a complete
type). For the second option (arrow) the type of the first expression
(the \term{pointer expression}) shall be ``pointer to class object''
(of a complete type). In these cases, the
\grammarterm{id-expression} shall name a member of the class or of one of
its base classes.
\enternote 
because the name of a class is inserted in its class scope
(clause~\ref{class}), the name of a class is also considered a nested
member of that class.
\exitnote 
\enternote
\ref{basic.lookup.classref} describes how names are looked up after the
\tcode{.} and \tcode{->} operators.
\exitnote 

\pnum
If \tcode{E1} has the type ``pointer to class \tcode{X},'' then the
expression \tcode{E1->E2} is converted to the equivalent form
\tcode{(*(E1)).E2}; the remainder of~\ref{expr.ref} will address only
the first option (dot)\footnote{Note that if \tcode{E1} has the type
``pointer to class \tcode{X}'', then \tcode{(*(E1))} is an lvalue.}.
Abbreviating \term{object-expression.\brk{}id-expression} as \tcode{E1.E2},
then the type and lvalue properties of this expression are determined
as follows. In the remainder of~\ref{expr.ref}, \cvqual{cq} represents either
\tcode{const} or the absence of \tcode{const}; \cvqual{vq} represents
either \tcode{volatile} or the absence of \tcode{volatile}. \cvqual{cv}
represents an arbitrary set of cv-qualifiers, as defined
in~\ref{basic.type.qualifier}.

\pnum
If \tcode{E2} is declared to have type ``reference to \tcode{T}'', then
\tcode{E1.E2} is an lvalue; the type of \tcode{E1.E2} is \tcode{T}.
Otherwise, one of the following rules applies.

\begin{itemize}
\item If \tcode{E2} is a static data member, and the type of \tcode{E2}
is \tcode{T}, then \tcode{E1.E2} is an lvalue; the expression designates
the named member of the class. The type of \tcode{E1.E2} is \tcode{T}.

\item If \tcode{E2} is a non-static data member, and the type of
\tcode{E1} is ``\cvqual{cq1 vq1} \tcode{X}'', and the type of \tcode{E2}
is ``\cvqual{cq2 vq2} \tcode{T}'', the expression designates the named
member of the object designated by the first expression. If \tcode{E1}
is an lvalue, then \tcode{E1.E2} is an lvalue.
Let the notation \cvqual{vq12} stand for the ``union'' of
\cvqual{vq1} and \cvqual{vq2}; that is, if \cvqual{vq1} or \cvqual{vq2}
is \tcode{volatile}, then \cvqual{vq12} is \tcode{volatile}. Similarly,
let the notation \cvqual{cq12} stand for the ``union'' of \cvqual{cq1}
and \cvqual{cq2}; that is, if \cvqual{cq1} or \cvqual{cq2} is
\tcode{const}, then \cvqual{cq12} is \tcode{const}. If \tcode{E2} is
declared to be a \tcode{mutable} member, then the type of \tcode{E1.E2}
is ``\cvqual{vq12} \tcode{T}''. If \tcode{E2} is not declared to be a
\tcode{mutable} member, then the type of \tcode{E1.E2} is
``\cvqual{cq12} \cvqual{vq12} \tcode{T}''.

\item If \tcode{E2} is a (possibly overloaded) member function, function
overload resolution~(\ref{over.match}) is used to determine whether
\tcode{E1.E2} refers to a static or a non-static member function.

\begin{itemize}
\item If it refers to a static member function and the type of
\tcode{E2} is ``function of (parameter type list) returning \tcode{T}'',
then \tcode{E1.E2} is an lvalue; the expression designates the static
member function. The type of \tcode{E1.E2} is the same type as that of
\tcode{E2}, namely ``function of (parameter type list) returning
\tcode{T}''.

\item Otherwise, if \tcode{E1.E2} refers to a non-static member
function and the type of \tcode{E2} is ``function of (parameter type
list) \cvqual{cv} returning \tcode{T}'', then \tcode{E1.E2} is
\emph{not} an lvalue. The expression designates a
non-static member function. The expression can be used only as the
left-hand operand of a member function call~(\ref{class.mfct}).
\enternote any redundant set of parentheses surrounding the expression
is ignored~(\ref{expr.prim}). \exitnote The type of \tcode{E1.E2} is
``function of (parameter type list) \cvqual{cv} returning \tcode{T}''.
\end{itemize}

\item If \tcode{E2} is a nested type, the expression \tcode{E1.E2} is
ill-formed.

\item If \tcode{E2} is a member enumerator, and the type of \tcode{E2}
is \tcode{T}, the expression \tcode{E1.E2} is not an lvalue. The type of
\tcode{E1.E2} is \tcode{T}.
\end{itemize}

\pnum
\enternote
``class objects'' can be structures~(\ref{class.mem}) and
unions~(\ref{class.union}). Class are discussed in clause~\ref{class}.
\exitnote

\rSec2[expr.post.incr]{Increment and decrement}

\pnum
\indextext{expression!increment}%
\indextext{operator!increment}%
\indextext{\idxcode{++}|see{operator, increment}}%
\indextext{postfix~\tcode{++}}%
The value obtained by applying a postfix \tcode{++} is the value that
the operand had before applying the operator.
\enternote 
the value obtained is a copy of the original value
\exitnote 
The operand shall be a modifiable lvalue. The type of the operand shall
be an arithmetic type or a pointer to a complete object type. After the
result is noted, the value
of the object is modified by adding \tcode{1} to it,
\indextext{increment!\idxcode{bool}}%
\indextext{deprecated~features}%
unless the object is of type \tcode{bool}, in which case it is set to
\tcode{true}.
\enternote 
this use is deprecated, see Annex~\ref{depr}.
\exitnote 
The result is an rvalue. The type of the result is the cv-unqualified
version of the type of the operand. See also~\ref{expr.add}
and~\ref{expr.ass}.

\pnum
\indextext{expression!decrement}%
\indextext{operator!decrement}%
\indextext{\idxcode{\dcr}|see{operator, decrement}}%
\indextext{postfix~\tcode{\dcr}}%
The operand of postfix \tcode{\dcr} is decremented analogously to the
postfix \tcode{++} operator, except that the operand shall not be of
type \tcode{bool}.
\enternote 
For prefix increment and decrement, see~\ref{expr.pre.incr}.
\exitnote 

\rSec2[expr.dynamic.cast]{Dynamic cast}

\pnum
\indextext{expression!dynamic~cast}%
\indextext{cast!dynamic}%
The result of the expression \tcode{dynamic_cast<T>(v)} is the result of
converting the expression \tcode{v} to type \tcode{T}.
\indextext{type!incomplete}%
\tcode{T} shall be a pointer or reference to a complete class type, or
``pointer to \cvqual{cv} \tcode{void}''. Types shall not be defined in
a \tcode{dynamic_cast}. The \tcode{dynamic_cast} operator shall not cast
away constness~(\ref{expr.const.cast}).

\pnum
If \tcode{T} is a pointer type, \tcode{v} shall be an rvalue of a
pointer to complete class type, and the result is an rvalue of type
\tcode{T}. If \tcode{T} is a reference type, \tcode{v} shall be
an lvalue of a complete class type, and the result is an lvalue of the
type referred to by \tcode{T}.

\pnum
If the type of \tcode{v} is the same as the required result type (which,
for convenience, will be called \tcode{R} in this description), or it is
the same as \tcode{R} except that the class object type in \tcode{R} is
more cv-qualified than the class object type in \tcode{v}, the result is
\tcode{v} (converted if necessary).

\pnum
If the value of \tcode{v} is a null pointer value in the pointer case,
the result is the null pointer value of type \tcode{R}.

\pnum
If \tcode{T} is ``pointer to \cvqual{cv1} \tcode{B}'' and \tcode{v} has
type ``pointer to \cvqual{cv2} \tcode{D}'' such that \tcode{B} is a base
class of \tcode{D}, the result is a pointer to the unique \tcode{B}
sub-object of the \tcode{D} object pointed to by \tcode{v}. Similarly, if
\tcode{T} is ``reference to \cvqual{cv1} \tcode{B}'' and \tcode{v} has
type ``\cvqual{cv2} \tcode{D}'' such that \tcode{B} is a base class of
\tcode{D}, the result is an lvalue for the unique\footnote{The most derived object~(\ref{intro.object}) pointed or referred to by
\tcode{v} can contain other \tcode{B} objects as base classes, but these
are ignored.} \tcode{B} sub-object of the \tcode{D} object refered to by
\tcode{v}. In both the pointer and reference cases, \cvqual{cv1} shall be
the same cv-qualification as, or greater cv-qualification than,
\cvqual{cv2}, and \tcode{B} shall be an accessible unambiguous base class
of \tcode{D}.
\enterexample 

\begin{codeblock}
struct B {};
struct D : B {};
void foo(D* dp)
{
    B*  bp = dynamic_cast<B*>(dp);	// equivalent to \tcode{B* bp = dp;}
}
\end{codeblock}
\exitexampleb

\pnum
Otherwise, \tcode{v} shall be a pointer to or an lvalue of a polymorphic
type~(\ref{class.virtual}).

\pnum
If \tcode{T} is ``pointer to \cvqual{cv} \tcode{void},'' then the result
is a pointer to the most derived object pointed to by \tcode{v}.
Otherwise, a run-time check is applied to see if the object pointed or
referred to by \tcode{v} can be converted to the type pointed or
referred to by \tcode{T}.

\pnum
The run-time check logically executes as follows:

\begin{itemize}
\item If, in the most derived object pointed (referred) to by \tcode{v},
\tcode{v} points (refers) to a \tcode{public} base class sub-object of a
\tcode{T} object, and if only one object of type \tcode{T} is derived
from the sub-object pointed (referred) to by \tcode{v}, the result is
a pointer (an lvalue referring) to that \tcode{T} object.

\item Otherwise, if \tcode{v} points (refers) to a \tcode{public} base
class sub-object of the most derived object, and the type of the most
derived object has a base class, of type \tcode{T}, that is unambiguous
and \tcode{public}, the result is a pointer (an lvalue referring) to the
\tcode{T} sub-object of the most derived object.

\item Otherwise, the run-time check \term{fails}.
\end{itemize}

\pnum
The value of a failed cast to pointer type is the null pointer value of
the required result type. A failed cast to reference type throws
\tcode{bad_cast}~(\ref{lib.bad.cast}).

\indextext{\idxcode{bad_cast}}%
\indexlibrary{\idxcode{bad_cast}}%
\enterexample 

\begin{codeblock}
class A { virtual void f(); };
class B { virtual void g(); };
class D : public virtual A, private B {};
void g()
{
    D   d;
    B*  bp = (B*)&d;            // cast needed to break protection
    A*  ap = &d;                // public derivation, no cast needed
    D&  dr = dynamic_cast<D&>(*bp);	// fails
    ap = dynamic_cast<A*>(bp);		// fails
    bp = dynamic_cast<B*>(ap);		// fails
    ap = dynamic_cast<A*>(&d);		// succeeds
    bp = dynamic_cast<B*>(&d);		// fails
}

class E : public D, public B {};
class F : public E, public D {};
void h()
{
    F   f;
    A*  ap  = &f;			// succeeds: finds unique \tcode{A}
    D*  dp  = dynamic_cast<D*>(ap);	// fails: yields \tcode{0}
					// \tcode{f} has two \tcode{D} sub-objects
    E*  ep  = (E*)ap;			// ill-formed:
					// cast from virtual base
    E*  ep1 = dynamic_cast<E*>(ap);	// succeeds
}
\end{codeblock}
\exitexampleb
\enternote
\ref{class.cdtor} describes the behavior of a \tcode{dynamic_cast}
applied to an object under construction or destruction.
\exitnote 

\rSec2[expr.typeid]{Type identification}

\pnum
\indextext{expression!type~identification}%
\indextext{\idxcode{typeid}}%
The result of a \tcode{typeid} expression is an lvalue of static type
\indextext{\idxcode{type_info}}%
\indexlibrary{\idxcode{type_info}}%
\tcode{const} \tcode{std::type_info}~(\ref{lib.type.info}) and dynamic type \tcode{const}
\tcode{std::type_info} or \tcode{const} \term{name} where \term{name} is an
\impldef{derived type for \tcode{typeid}} class derived from
\tcode{std::type_info} which preserves the behavior described
in~\ref{lib.type.info}.\footnote{The recommended name for such a class is
\tcode{extended_type_info}.}
The lifetime of the object referred to by the lvalue extends to the end
of the program. Whether or not the destructor is called for the
\tcode{type_info} object at the end of the program is unspecified.

\pnum
When \tcode{typeid} is applied to an lvalue expression whose type is a
polymorphic class type~(\ref{class.virtual}), the result refers to a
\tcode{type_info} object representing the type of the most derived
object~(\ref{intro.object}) (that is, the dynamic type) to which the
lvalue refers. If the lvalue expression is obtained by applying the
unary \tcode{*} operator to a pointer\footnote{If \tcode{p} is an expression of
pointer type, then \tcode{*p},
\tcode{(*p)}, \tcode{*(p)}, \tcode{((*p))}, \tcode{*((p))}, and so on
all meet this requirement.}
and the pointer is a null pointer value~(\ref{conv.ptr}), the
\tcode{typeid} expression throws the
\indextext{\idxcode{bad_typeid}}%
\indexlibrary{\idxcode{bad_typeid}}%
\tcode{bad_typeid} exception~(\ref{lib.bad.typeid}).

\pnum
When \tcode{typeid} is applied to an expression other than an lvalue of
a polymorphic class type, the result refers to a \tcode{type_info}
object representing the static type of the expression.
Lvalue-to-rvalue~(\ref{conv.lval}), array-to-pointer~(\ref{conv.array}),
and function-to-pointer~(\ref{conv.func}) conversions are not applied to
the expression.
\indextext{type!incomplete}%
If the type of the expression is a class type, the class shall be
completely-defined. The expression is not evaluated.

\pnum
When \tcode{typeid} is applied to a \grammarterm{type-id}, the result
refers to a \tcode{type_info} object representing the type of the
\grammarterm{type-id}. If the type of the \grammarterm{type-id} is a reference
type, the result of the
\tcode{typeid} expression refers to a \tcode{type_info} object
representing the referenced type. If the type of
the \grammarterm{type-id} is a class type or a reference to a class type,
the class shall be completely-defined. Types shall not be defined in the
\grammarterm{type-id}.

\pnum
The top-level cv-qualifiers of the lvalue expression or the
\grammarterm{type-id} that is the operand of \tcode{typeid} are always
ignored.
\enterexample 

\begin{codeblock}
class D { ... }
D d1;
const D d2;

typeid(d1) == typeid(d2);		// yields \tcode{true}
typeid(D)  == typeid(const D);		// yields \tcode{true}
typeid(D)  == typeid(d2);		// yields \tcode{true}
typeid(D)  == typeid(const D&);		// yields \tcode{true}
\end{codeblock}
\exitexampleb

\pnum
If the header \tcode{<typeinfo>}~(\ref{lib.type.info}) is not included prior
to a use of \tcode{typeid}, the program is ill-formed.

\pnum
\enternote
\ref{class.cdtor} describes the behavior of \tcode{typeid} applied to an
object under construction or destruction.
\exitnote 

\rSec2[expr.static.cast]{Static cast}

\pnum
\indextext{expression!static~cast}%
\indextext{cast!static}%
The result of the expression \tcode{static_cast<T>(v)} is the result of
converting the expression \tcode{v} to type \tcode{T}.
\indextext{cast!static!lvalue}%
\indextext{cast!lvalue}%
If \tcode{T} is a reference type, the result is an lvalue; otherwise,
the result is an rvalue. Types shall not be defined in a
\tcode{static_cast}. The \tcode{static_cast} operator shall not cast
away constness~(\ref{expr.const.cast}).

\pnum
An expression \tcode{e} can be explicitly converted to a type \tcode{T}
using a \tcode{static_cast} of the form \tcode{static_cast<T>(e)} if
the declaration ``\tcode{T t(e);}'' is well-formed, for some invented
temporary variable \tcode{t}~(\ref{dcl.init}). The effect of such an
explicit conversion is the same as performing the declaration and
initialization and then using the temporary variable as the result of
the conversion. The result is an lvalue if \tcode{T} is a reference
type~(\ref{dcl.ref}), and an rvalue otherwise. The expression \tcode{e}
is used as an lvalue if and only if the initialization uses it as an
lvalue.

\pnum
Otherwise, the \tcode{static_cast} shall perform one of the conversions
listed below. No other conversion shall be performed explicitly using
a \tcode{static_cast}.

\pnum
Any expression can be explicitly converted to type ``\cv~\tcode{void}.''
The expression value is discarded. \enternote however, if the value is
in a temporary variable~(\ref{class.temporary}), the destructor for that
variable is not executed until the usual time, and the value of the
variable is preserved for the purpose of executing the destructor.
\exitnote The lvalue-to-rvalue~(\ref{conv.lval}),
array-to-pointer~(\ref{conv.array}), and function-to-pointer~(\ref{conv.func})
standard conversions are not applied to the expression.

\pnum
\indextext{cast!static!reference}%
\indextext{cast!reference}%
An lvalue of type ``\cvqual{cv1} \tcode{B}'', where \tcode{B} is a class
type, can be cast to type ``reference to \cvqual{cv2} \tcode{D}'', where
\tcode{D} is a class derived (clause~\ref{class.derived}) from
\tcode{B}, if a valid standard conversion from ``pointer to \tcode{D}''
to ``pointer to \tcode{B}'' exists~(\ref{conv.ptr}), \cvqual{cv2} is the
same cv-qualification as, or greater cv-qualification than,
\cvqual{cv1}, and \tcode{B} is not a virtual base class of \tcode{D}.
The result is an lvalue of type ``\cvqual{cv2} \tcode{D}.'' If the lvalue
of type ``\cvqual{cv1} \tcode{B}'' is actually a sub-object of an object
of type \tcode{D}, the lvalue refers to the enclosing object of type
\tcode{D}. Otherwise, the result of the cast is undefined.
\enterexample 

\begin{codeblock}
struct B {};
struct D : public B {};
D d;
B &br = d;

static_cast<D&>(br);            // produces lvalue to the original \tcode{d} object
\end{codeblock}
\exitexampleb

\pnum
The inverse of any standard conversion sequence (clause~\ref{conv}),
other than lvalue-to-rvalue~(\ref{conv.lval}),
array-to-pointer~(\ref{conv.array}), function-to-pointer~(\ref{conv.func}),
and boolean~(\ref{conv.bool}) conversions, can be performed explicitly
using \tcode{static_cast}. The lvalue-to-rvalue~(\ref{conv.lval}),
array-to-pointer~(\ref{conv.array}), and
function-to-pointer~(\ref{conv.func}) conversions are applied to the
operand. Such a \tcode{static_cast} is subject to the restriction that
the explicit conversion does not cast away
constness~(\ref{expr.const.cast}), and the following additional rules
for specific cases:

\pnum
\indextext{enumeration~type!conversion~to}%
\indextext{enumeration~type!\idxcode{static_cast}!conversion~to}%
A value of integral or enumeration type can be explicitly converted to
an enumeration type. The value is unchanged if the original value is
within the range of the enumeration values~(\ref{dcl.enum}). Otherwise,
the resulting enumeration value is unspecifieda.

\pnum
\indextext{cast!base~class}%
\indextext{cast!derived~class}%
An rvalue of type ``pointer to \cvqual{cv1} \tcode{B}'', where \tcode{B}
is a class type, can be converted to an rvalue of type ``pointer to
\cvqual{cv2} \tcode{D}'', where \tcode{D} is a class derived
(clause~\ref{class.derived}) from \tcode{B}, if a valid standard
conversion from ``pointer to \tcode{D}'' to ``pointer to \tcode{B}''
exists~(\ref{conv.ptr}), \cvqual{cv2} is the same cv-qualification as,
or greater cv-qualification than, \cvqual{cv1}, and \tcode{B} is not
a virtual base class of \tcode{D}. The null pointer
value~(\ref{conv.ptr}) is converted
to the null pointer value of the destination type. If the rvalue of type
``pointer to \cvqual{cv1} \tcode{B}'' points to a \tcode{B} that is
actually a sub-object of an object of type \tcode{D}, the resulting
pointer points to the enclosing object of type \tcode{D}. Otherwise, the
result of the cast is undefined.

\pnum
\indextext{cast!pointer-to-member}%
An rvalue of type ``pointer to member of \tcode{D} of type \cvqual{cv1}
\tcode{T}'' can be converted to an rvalue of type ``pointer to member of
\tcode{B} of type \cvqual{cv2} \tcode{T}'', where \tcode{B} is a base
class (clause~\ref{class.derived}) of \tcode{D}, if a valid standard
conversion from ``pointer to member of \tcode{B} of type \tcode{T}'' to
``pointer to member of \tcode{D} of type \tcode{T}''
exists~(\ref{conv.mem}), and \cvqual{cv2} is the same cv-qualification
as, or greater cv-qualification than, \cvqual{cv1}.\footnote{Function types
(including those used in pointer to member function
types) are never cv-qualified; see~\ref{dcl.fct}.}
The null member pointer value~(\ref{conv.mem}) is converted to the null
member pointer value of the destination type. If class \tcode{B}
contains the original member, or is a base or derived class of the class
containing the original member, the resulting pointer to member points
to the original member. Otherwise, the result of the cast is undefined.
\enternote 
although class \tcode{B} need not contain the original member, the
dynamic type of the object on which the pointer to member is
dereferenced must contain the original member; see~\ref{expr.mptr.oper}.
\exitnote 

\pnum
An rvalue of type ``pointer to \cvqual{cv1} \tcode{void}'' can be
converted to an rvalue of type ``pointer to \cvqual{cv2} \tcode{T},''
where \tcode{T} is an object type and \cvqual{cv2} is the same
cv-qualification as, or greater cv-qualification than, \cvqual{cv1}.
A value of type pointer to object converted to
``pointer to \cvqual{cv} \tcode{void}'' and back to the original pointer
type will have its original value.

\rSec2[expr.reinterpret.cast]{Reinterpret cast}

\pnum
\indextext{expression!reinterpret~cast}%
\indextext{cast!reinterpret}%
The result of the expression \tcode{reinterpret_cast<T>(v)} is the
result of converting the expression \tcode{v} to type \tcode{T}.
\indextext{cast!reinterpret!lvalue}%
\indextext{cast!lvalue}%
If \tcode{T} is a reference type, the result is an lvalue;
otherwise, the result is an rvalue and the
lvalue-to-rvalue~(\ref{conv.lval}), array-to-pointer~(\ref{conv.array}),
and function-to-pointer~(\ref{conv.func}) standard conversions are
performed on the expression \tcode{v}. Types shall not be defined in
a \tcode{reinterpret_cast}. Conversions that can be performed explicitly
using \tcode{reinterpret_cast} are listed below. No other conversion can
be performed explicitly using \tcode{reinterpret_cast}.

\pnum
The \tcode{reinterpret_cast} operator shall not cast away constness.
\enternote see \ref{expr.const.cast} for the definition of ``casting
away constness''. Subject to the restrictions in this section, an
expression may be cast to its own type using a \tcode{reinterpret_cast}
operator. \exitnote

\pnum
The mapping performed by \tcode{reinterpret_cast} is implementation-defined.
\enternote it might, or might not, produce a representation
different from the original value.
\exitnote 

\pnum
\indextext{cast!reinterpret!pointer to integer}%
\indextext{cast!pointer~to integer}%
A pointer can be explicitly converted to any integral type large enough
to hold it.
\indextext{conversion!implementation~defined pointer integer}%
The mapping function is implementa\-tion-defined.
\enternote
It is intended to be unsurprising to those who know the addressing
structure of the underlying machine.
\exitnote

\pnum
\indextext{cast!reinterpret!integer~to pointer}%
\indextext{cast!integer~to pointer}%
A value of inategral type or enumeration type can be explicitly converted
to a pointer.\footnote{Converting an integral constant
expression~(\ref{expr.const}) with value zero always yields a null
pointer~(\ref{conv.ptr}), but converting other expressions that happen to
have value zero need not yield a null pointer.}
A pointer converted to an integer of sufficient size (if
any such exists on the implementation) and back to the same pointer type
will have its original value;
\indextext{conversion!implementation~defined pointer integer}%
mappings between pointers and integers are otherwise
\impldef{conversions between pointers and integers}.

\pnum
\indextext{cast!reinterpret!pointer-to-function}%
\indextext{cast!pointer-to-function}%
\indextext{cast!undefined pointer-to-function}%
A pointer to a function can be explicitly converted to a pointer
to a function of a different type.
\indextext{function~call!undefined}%
The effect of calling a function through a pointer to a function
type~(\ref{dcl.fct}) that is not the same as the type used in the
definition of the function is undefined. Except that converting
an rvalue of type ``pointer to \tcode{T1}'' to the type ``pointer to
\tcode{T2}'' (where \tcode{T1} and \tcode{T2} are function types) and
back to its original type yields the original pointer value, the result
of such a pointer conversion is unspecified.
\enternote 
see also~\ref{conv.ptr} for more details of pointer conversions.
\exitnote 

\pnum
A pointer to an object can be explicitly converted to a pointer to an
object of different type.\footnote{The types may have different
cv-qualifiers, subject to the overall
restriction that a \tcode{reinterpret_cast} cannot cast away constness.}
Except that converting an rvalue of type ``pointer to \tcode{T1}'' to
the type ``pointer to \tcode{T2}'' (where \tcode{T1} and \tcode{T2} are
object types and where the alignment requirements of \tcode{T2} are no
stricter than those of \tcode{T1}) and back to its original type yields
the original pointer value, the result of such pointer conversion is
unspecified.

\pnum
The null pointer value~(\ref{conv.ptr}) is converted to the null pointer value
of the destination type.

\pnum
\indextext{cast!reinterpret!pointer-to-member}%
\indextext{cast!pointer-to-member}%
An rvalue of type ``pointer to member of \tcode{X} of type \tcode{T1}''
can be explicitly converted to an rvalue of type ``pointer to member of
\tcode{Y} of type \tcode{T2}'' if \tcode{T1} and \tcode{T2} are both
function types or both object types.\footnote{\tcode{T1} and \tcode{T2} may have
different cv-qualifiers, subject to
the overall restriction that a \tcode{reinterpret_cast} cannot cast away
constness.} The null member pointer value~(\ref{conv.mem}) is converted to the
null member pointer value of the destination type. The result of this
conversion is unspecified, except in the following cases:

\begin{itemize}
\item converting an rvalue of type ``pointer to member function'' to a
different pointer to member function type and back to its original type
yields the original pointer to member value.

\item converting an rvalue of type ``pointer to data member of \tcode{X}
of type \tcode{T1}'' to the type ``pointer to data member of \tcode{Y}
of type \tcode{T2}'' (where the alignment requirements of \tcode{T2} are
no stricter than those of \tcode{T1}) and back to its original type
yields the original pointer to member value.
\end{itemize}

\pnum
\indextext{cast!reinterpret!reference}%
\indextext{cast!reference}%
An lvalue expression of type \tcode{T1} can be cast to the type
``reference to \tcode{T2}'' if an expression of type ``pointer to
\tcode{T1}'' can be explicitly converted to the type ``pointer to
\tcode{T2}'' using a \tcode{reinterpret_cast}. That is, a reference cast
\tcode{reinterpret_cast<T\&>(x)} has the same effect as the conversion
\tcode{*reinterpret_cast<T*>(\&x)} with the built-in \tcode{\&} and
\tcode{*} operators. The result is an lvalue that refers to the same
object as the source lvalue, but with a different type. No temporary is
created, no copy is made, and constructors~(\ref{class.ctor}) or conversion
functions~(\ref{class.conv}) are not called.\footnote{\indextext{type~pun}This
is sometimes referred to as a \term{type pun}.}

\rSec2[expr.const.cast]{Const cast}

\pnum
\indextext{expression!const~cast}%
\indextext{cast!const}%
The result of the expression \tcode{const_cast<T>(v)} is of type
\tcode{T}. If \tcode{T} is a reference type, the result is an
lvalue; otherwise, the result is an rvalue and, the
lvalue-to-rvalue~(\ref{conv.lval}), array-to-pointer~(\ref{conv.array}),
and function-to-pointer~(\ref{conv.func}) standard conversions are
performed on the expression \tcode{v}. Types shall not be defined in
a \tcode{const_cast}. Conversions that can be performed explicitly using
\tcode{const_cast} are listed below. No other conversion shall be
performed explicitly using \tcode{const_cast}.

\pnum
\enternote 
Subject to the restrictions in this section, an expression may be cast
to its own type using a \tcode{const_cast} operator.
\exitnote 

\pnum
For two pointer types \tcode{T1} and \tcode{T2} where

\begin{indented}
\term{T1} is $\mathit{cv}_{1,0}$ pointer to $\mathit{cv}_{1,1}$ pointer
to $\cdots \mathit{cv}_{1,n-1}$ pointer to $\mathit{cv}_{1,n}$ \term{T}
\end{indented}

and

\begin{indented}
\term{T2} is $\mathit{cv}_{2,0}$ pointer to $\mathit{cv}_{2,1}$ pointer
to $\cdots \mathit{cv}_{2,n-1}$ pointer to $\mathit{cv}_{2,n}$ \term{T}
\end{indented}

where
\tcode{T} is any object type or the \tcode{void} type and where
$\mathit{cv}_{1,k}$ and $\mathit{cv}_{2,k}$ may be different
cv-qualifications, an rvalue of type \tcode{T1} may be explicitly
converted to the type \tcode{T2} using a \tcode{const_cast}. The result
of a pointer \tcode{const_cast} refers to the original object.

\pnum
An lvalue of type \tcode{T1} can be explicitly converted to an lvalue
of type \tcode{T2} using the cast \tcode{const_cast<T2\&>} (where
\tcode{T1} and \tcode{T2} are object types) if a pointer to \tcode{T1} can
be explicitly converted to the type pointer to \tcode{T2} using a
\tcode{const_cast}. The result of a reference \tcode{const_cast} refers
to the original object.

\pnum
For a \tcode{const_cast} involving pointers to data members, multi-level
pointers to data members and multi-level mixed pointers and pointers to
data members~(\ref{conv.qual}), the rules for \tcode{const_cast} are the
same as those used for pointers; the ``member'' aspect of a pointer to
member is ignored when determining where the cv-qualifiers are added or
removed by the \tcode{const_cast}. The result of a pointer to data
member \tcode{const_cast} refers to the same member as the original
(uncast) pointer to data member.

\pnum
A null pointer value~(\ref{conv.ptr}) is converted to the null pointer
value of the destination type. The null member pointer
value~(\ref{conv.mem}) is converted to the null member pointer value of
the destination type.

\pnum
\enternote 
Depending on the type of the object, a write operation through the
pointer, lvalue or pointer to data member resulting from a
\tcode{const_cast} that casts away a const-qualifier\footnote{\tcode{const_cast}
is not limited to conversions that cast away a
const-qualifier.}
may produce undefined behavior~(\ref{dcl.type.cv}).
\exitnote 

\pnum
The following rules define the process known as \term{casting away
constness}. In these rules \tcode{T\term{n}} and \tcode{X\term{n}}
represent types. For two pointer types:

\begin{indented}
\tcode{X1} is \tcode{T1}$\mathit{cv}_{1,1}$ \tcode{*} $\cdots$
$\mathit{cv}_{1,N}$ \tcode{*} where \tcode{T1} is not a pointer type
\end{indented}

\begin{indented}
\tcode{X2} is \tcode{T2}$\mathit{cv}_{2,1}$ \tcode{*} $\cdots$
$\mathit{cv}_{2,M}$ \tcode{*} where \tcode{T2} is not a pointer type
\end{indented}

\begin{indented}
$K$ is $\min (N,M)$
\end{indented}

casting from \tcode{X1} to \tcode{X2} casts away constness if, for a
non-pointer type \tcode{T} there does not exist an implicit conversion
(clause~\ref{conv}) from:

\begin{indented}
\tcode{T}$\mathit{cv}_{1,(N-K+1)}$ \tcode{*} $\mathit{cv}_{1,(N-K+2)}$
\tcode{*} $\cdots$ $\mathit{cv}_{1,N}$ \tcode{*}
\end{indented}

to

\begin{indented}
\tcode{T}$\mathit{cv}_{2,(M-K+1)}$ \tcode{*} $\mathit{cv}_{2,(M-K+2)}$
\tcode{*} $\cdots$ $\mathit{cv}_{2,M}$ \tcode{*}
\end{indented}

\pnum
Casting from an lvalue of type \tcode{T1} to an lvalue of type
\tcode{T2} using a reference cast casts away constness if a cast
from an rvalue of type ``pointer to \tcode{T1}'' to the type ``pointer to
\tcode{T2}'' casts away constness.

\pnum
Casting from an rvalue of type ``pointer to data member of \tcode{X} of
type \tcode{T1}'' to the type ``pointer to data member of \tcode{Y} of
type \tcode{T2}'' casts away constness if a cast from an rvalue of type
``pointer to \tcode{T1}'' to the type ``pointer to \tcode{T2}'' casts
away constness.

\pnum
For multi-level pointer to members and multi-level mixed pointers and
pointer to members~(\ref{conv.qual}), the ``member'' aspect of a pointer
to member level is ignored when determining if a \tcode{const}
cv-qualifier has been cast away.

\pnum
\enternote 
some conversions which involve only changes in cv-qualification cannot
be done using \tcode{const_cast}. For instance, conversions between
pointers to functions are not covered because such conversions lead to
values whose use causes undefined behavior. For the same reasons,
conversions between pointers to member functions, and in particular, the
conversion from a pointer to a const member function to a pointer to a
non-const member function, are not covered.
\exitnote%
\indextext{expression!postfix|)}

\rSec1[expr.unary]{Unary expressions}

\pnum
\indextext{expression!unary|(}%
Expressions with unary operators group right-to-left.

\indextext{expression!unary}%
\indextext{operator!unary}%
\indextext{operator!\idxcode{sizeof}}%
\indextext{operator!cast}%
%
\begin{bnf}
\nontermdef{unary-expression}\br
    postfix-expression\br
    \terminal{++} cast-expression\br
    \terminal{-{-}} cast-expression\br
    unary-operator cast-expression\br
    \terminal{sizeof} unary-expression\br
    \terminal{sizeof (} type-id \terminal{)}\br
    new-expression\br
    delete-expression
\end{bnf}

\indextext{operator!indirection}%
\indextext{\idxcode{*}|see{operator, indirection}}%
\indextext{operator!address-of}%
\indextext{\idxcode{\&}|see{operator, address-of}}%
\indextext{operator!unary~minus}%
\indextext{\idxcode{-}|see{operator, unary~minus}}%
\indextext{operator!unary~plus}%
\indextext{\idxcode{+}|see{operator, unary~plus}}%
\indextext{operator!logical negation}%
\indextext{\idxcode{"!}|see{operator, logical~negation}}%
\indextext{operator!one's~complement}%
\indextext{~@\tcode{\tilde}|see{operator, one's~complement}}%
\indextext{operator!increment}%
\indextext{operator!decrement}%
%
\begin{bnf}
\nontermdef{unary-operator} \textnormal{one of}\br
    \terminal{*  \&  +  -  !  \tilde}
\end{bnf}

\rSec2[expr.unary.op]{Unary operators}

\pnum
\indextext{expression!unary~operator}%
\indextext{operator!unary}%
The unary \tcode{*} operator performs \term{indirection}:
\indextext{dereferencing|seealso{indirection}}%
\indextext{indirection}%
the expression to which it is applied shall be a pointer to an object
type, or a pointer to a function type and the result is an lvalue
referring to the object or function to which the expression points. If
the type of the expression is ``pointer to \tcode{T},'' the type of the
result is ``\tcode{T}.''
\enternote 
\indextext{type!incomplete}%
a pointer to an incomplete type (other than \cvqual{cv} \tcode{void})
can be dereferenced. The lvalue thus obtained can be used in limited
ways (to initialize a reference, for example); this lvalue must not be
converted to an rvalue, see~\ref{conv.lval}.
\exitnote 

\pnum
\indextext{name!address~of cv-qualified}%
\indextext{expression!pointer~to~member constant}%
The result of the unary \tcode{\&} operator is a pointer to its operand.
The operand shall be an lvalue or a \grammarterm{qualified-id}.
In the first case, if the type of the expression is ``\tcode{T},'' the
type of the result is ``pointer to \tcode{T}.'' In particular, the
address of an object of type ``\cv\ \tcode{T}'' is ``pointer
to \cv\ \tcode{T},'' with the same cv-qualifiers. For a
\grammarterm{qualified-id}, if the member is a static member of type
``\tcode{T}'', the type of the result is plain ``pointer to \tcode{T}.''
If the member is a nonstatic member of class \tcode{C} of type \tcode{T},
the type of the result is ``pointer to member of \tcode{class C} of
type \tcode{T}.''
\enterexample 

\begin{codeblock}
struct A { int i; };
struct B : A { };
... &B::i ...			// has type \tcode{int A::*}
\end{codeblock}
\exitexampleb 
\enternote 
a pointer to member formed from a \tcode{mutable} nonstatic data
member~(\ref{dcl.stc}) does not reflect the \tcode{mutable} specifier
associated with the nonstatic data member.
\exitnote 

\pnum
A pointer to member is only formed when an explicit \tcode{\&} is used
and its operand is a \grammarterm{qualified-id} not enclosed in
parentheses.
\enternote 
that is, the expression \tcode{\&(qualified-id)}, where the
\grammarterm{qualified-id} is enclosed in parentheses, does not form an
expression of type ``pointer to member.'' Neither does
\tcode{qualified-id}, because there is no implicit conversion from a
\grammarterm{qualified-id} for a nonstatic member function to the type
``pointer to member function'' as there is from an lvalue of function
type to the type ``pointer to function''~(\ref{conv.func}). Nor is
\tcode{\&unqualified-id} a pointer to member, even within the scope of
the \grammarterm{unqualified-id}'s class.
\exitnote 

\pnum
The address of an object of incomplete type can be taken, but if the
complete type of that object is a class type that declares
\tcode{operator\&()} as a member function, then the behavior is
undefined (and no diagnostic is required). The operand of \tcode{\&}
shall not be a bit-field.

\pnum
\indextext{overloaded~function!address~of}%
The address of an overloaded function (clause~\ref{over}) can be taken
only in a context that uniquely determines which version of the
overloaded function is referred to (see~\ref{over.over}).
\enternote 
since the context might determine whether the operand is a static or
nonstatic member function, the context can also affect whether the
expression has type ``pointer to function'' or ``pointer to member
function.''
\exitnote 

\pnum
\indextext{operator!unary~plus}%
The operand of the unary \tcode{+} operator shall have arithmetic,
enumeration, or pointer type and the result is the value of the
argument. Integral promotion is performed on integral or enumeration
operands. The type of the result is the type of the promoted operand.

\pnum
\indextext{operator!unary~minus}%
The operand of the unary \tcode{-} operator shall have arithmetic or
enumeration type and the result is the negation of its operand. Integral
promotion is performed on integral or enumeration operands. The negative
of an unsigned quantity is computed by subtracting its value from $2^n$,
where $n$ is the number of bits in the promoted operand. The type of the
result is the type of the promoted operand.

\pnum
\indextext{operator!logical negation}%
The operand of the logical negation operator \tcode{!} is implicitly
converted to \tcode{bool} (clause~\ref{conv}); its value is \tcode{true}
if the converted operand is \tcode{false} and \tcode{false} otherwise.
The type of the result is \tcode{bool}.

\pnum
\indextext{operator!one's~complement}%
The operand of \tcode{\~{}} shall have integral or enumeration type; the
result is the one's complement of its operand. Integral promotions are
performed. The type of the result is the type of the promoted operand.
There is an ambiguity in the \grammarterm{unary-expression}
\tcode{\~{}X()}, where \tcode{X} is a \grammarterm{class-name}. The
ambiguity is resolved in favor of treating \tcode{\~{}} as a unary
complement rather than treating \tcode{\~{}X} as referring to a
destructor.

\rSec2[expr.pre.incr]{Increment and decrement}

\pnum
\indextext{expression!increment}%
\indextext{expression!decrement}%
The operand of prefix \tcode{++}
\indextext{operator!increment}%
\indextext{prefix~\tcode{++}}%
is modified by adding \tcode{1},
\indextext{increment!\idxcode{bool}}%
\indextext{prefix~\tcode{\dcr}}%
\indextext{deprecated~features}%
or set to \tcode{true} if it is \tcode{bool} (this use is deprecated).
The operand shall be a modifiable lvalue. The type of the operand shall
be an arithmetic type or a pointer to a completely-defined object type.
The value is the new value of the operand; it is an lvalue.
If \tcode{x} is not of type \tcode{bool}, the expression \tcode{++x} is
equivalent to \tcode{x+=1}.
\indextext{operator!\idxcode{+=}}%
\enternote
see the discussions of addition~(\ref{expr.add}) and assignment
operators~(\ref{expr.ass}) for information on conversions.
\exitnote 

\pnum
The operand of prefix
\indextext{operator!decrement}%
\tcode{\dcr} is modified by subtracting \tcode{1}. The operand shall not
be of type \tcode{bool}. The requirements on the operand of prefix
\tcode{\dcr} and the properties of its result are otherwise the same as
those of prefix \tcode{++}.
\enternote 
For postfix increment and decrement, see~\ref{expr.post.incr}.
\exitnote 

\rSec2[expr.sizeof]{Sizeof}

\pnum
\indextext{expression!\idxcode{sizeof}}%
\indextext{operator!\idxcode{sizeof}}%
\indextext{byte}%
The \tcode{sizeof} operator yields the number of bytes in the object
representation of its operand. The operand is either an expression,
which is not evaluated, or a parenthesized \grammarterm{type-id}.
\indextext{type!incomplete}%
The \tcode{sizeof} operator shall not be applied to an expression that
has function or incomplete type, or to an enumeration type before all
its enumerators have been declared, or to the parenthesized name of such
types, or to an lvalue that designates a bit-field.
\tcode{sizeof(char)}, \tcode{sizeof(signed char)} and
\tcode{sizeof(unsigned char)} are \tcode{1}; the result of
\tcode{sizeof} applied to any other fundamental
type~(\ref{basic.fundamental}) is \impldef{sizeof applied@\tcode{sizeof} applied to
fundamental types
other than \tcode{char}, \tcode{signed char}, and \tcode{unsigned char}}.
\enternote 
in particular, \tcode{sizeof(bool)} and \tcode{sizeof(wchar_t)} are
implementation-defined.\footnote{\tcode{sizeof(bool)} is not required to be \tcode{1}.}
\exitnote 
\enternote 
See~\ref{intro.memory} for the definition of \term{byte}
and~\ref{basic.types} for the definition of \term{object representation}.
\exitnote 

\pnum
\indextext{reference!\idxcode{sizeof}}%
When applied to a reference or a reference type, the result is the size
of the referenced type.
\indextext{class~object!\idxcode{sizeof}}%
When applied to a class, the result is the number of bytes in an object
of that class including any padding required for placing objects of that
type in an array. The size of a most derived class shall be greater than
zero~(\ref{intro.object}). The result of applying \tcode{sizeof} to a
base class subobject is the size of the base class type.\footnote{The actual
size of a base class subobject may be less than the result of
applying \tcode{sizeof} to the subobject, due to virtual base classes
and less strict padding requirements on base class subobjects.}
\indextext{array!\idxcode{sizeof}}%
When applied to an array, the result is the total number of bytes in the
array. This implies that the size of an array of \term{n} elements is
\term{n} times the size of an element.

\pnum
The \tcode{sizeof} operator can be applied to a pointer to a function,
but shall not be applied directly to a function.

\pnum
The lvalue-to-rvalue~(\ref{conv.lval}),
array-to-pointer~(\ref{conv.array}), and
function-to-pointer~(\ref{conv.func}) standard conversions are not
applied to the operand of \tcode{sizeof}.

\pnum
Types shall not be defined in a \tcode{sizeof} expression.

\pnum
The result is a constant of type \tcode{size_t}.
\enternote 
\indextext{\idxcode{size_t}}%
\indexlibrary{\idxcode{size_t}}%
\tcode{size_t} is defined in the standard header
\indextext{\idxhdr{cstddef}}%
\tcode{<cstddef>}~(\ref{lib.support.types}).
\exitnote 

\rSec2[expr.new]{New}

\pnum
\indextext{expression!\idxcode{new}}%
\indextext{free~store|seealso{\tcode{new},~\tcode{delete}}}%
\indextext{memory~management|seealso{\tcode{new},~\tcode{delete}}}%
\indextext{storage~management|see{\tcode{new},~\tcode{delete}}}%
\indextext{\idxcode{new}}%
The \grammarterm{new-expression} attempts to create an object of the
\grammarterm{type-id}~(\ref{dcl.name}) or \grammarterm{new-type-id} to which
it is applied. The type of that object is the \term{allocated type}.
\indextext{type!incomplete}%
This type shall be a complete object type, but not an abstract class
type or array
thereof~(\ref{intro.object},~\ref{basic.types},~\ref{class.abstract}).
\enternote 
because references are not objects, references cannot be created by
\grammarterm{new-expression}{s}.
\exitnote 
\enternote 
the \grammarterm{type-id} may be a cv-qualified type, in which case the
object created by the \grammarterm{new-expression} has a cv-qualified type.
\exitnote 

\begin{bnf}
\nontermdef{new-expression}\br
    \terminal{::}\opt \terminal{new} new-placement\opt new-type-id new-initializer\opt \br
    \terminal{::}\opt \terminal{new} new-placement\opt \terminal{(} type-id \terminal{)} new-initializer\opt
\end{bnf}

\indextext{\idxcode{new}!storage allocation}%
%
\begin{bnf}
\nontermdef{new-placement}\br
    \terminal{(} expression-list \terminal{)}
\end{bnf}

\begin{bnf}
\nontermdef{new-type-id}\br
    type-specifier-seq new-declarator\opt
\end{bnf}

\begin{bnf}
\nontermdef{new-declarator}\br
    ptr-operator new-declarator\opt \br
    direct-new-declarator
\end{bnf}

\begin{bnf}
\nontermdef{direct-new-declarator}\br
    \terminal{[} expression \terminal{]}\br
    direct-new-declarator \terminal{[} constant-expression \terminal{]}
\end{bnf}

\begin{bnf}
\nontermdef{new-initializer}\br
    \terminal{(} expression-list\opt \terminal{)}
\end{bnf}

\indextext{storage~duration!dynamic}%
Entities created by a \grammarterm{new-expression} have dynamic storage
duration~(\ref{basic.stc.dynamic}).
\enternote 
\indextext{\idxcode{new}!scoping~and}%
the lifetime of such an entity is not necessarily restricted to the
scope in which it is created.
\exitnote 
If the entity is a non-array object, the \grammarterm{new-expression}
returns a pointer to the object created. If it is an array, the
\grammarterm{new-expression} returns a pointer to the initial element of
the array.

\pnum
The \grammarterm{new-type-id} in a \grammarterm{new-expression} is the longest
possible sequence of \grammarterm{new-declarator}{s}.
\enternote 
this prevents ambiguities between the declarator operators \tcode{\&},
\tcode{*}, \tcode{[]}, and their expression counterparts.
\exitnote 
\enterexample 

\begin{codeblock}
new int * i;                    // syntax error: parsed as \tcode{(new int*) i}
				//	not as \tcode{(new int)*i}
\end{codeblock}
The \tcode{*} is the pointer declarator and not the multiplication
operator.
\exitexample 

\pnum
\enternote 
\indextext{ambiguity!parentheses~and}%
parentheses in a \grammarterm{new-type-id} of a \grammarterm{new-expression}
can have surprising effects.
\enterexample 

\begin{codeblock}
new int(*[10])();               // error
\end{codeblock}

is ill-formed because the binding is

\begin{codeblock}
(new int) (*[10])();            // error
\end{codeblock}

Instead, the explicitly parenthesized version of the \tcode{new}
operator can be used to create objects of compound
types~(\ref{basic.compound}):

\begin{codeblock}
new (int (*[10])());
\end{codeblock}

allocates an array of \tcode{10} pointers to functions (taking no
argument and returning \tcode{int}).
\exitexample 
\exitnote 

\pnum
The \grammarterm{type-specifier-seq} shall not contain class declarations,
or enumeration declarations.

\pnum
\indextext{array!\idxcode{new}}%
When the allocated object is an array (that is, the
\grammarterm{direct-new-declarator} syntax is used or the
\grammarterm{new-type-id} or \grammarterm{type-id} denotes an array type), the
\grammarterm{new-expression} yields a pointer to the initial element (if
any) of the array.
\enternote 
both \tcode{new int} and \tcode{new int[10]} have type \tcode{int*} and
the type of \tcode{new int[i][10]} is \tcode{int (*)[10]}.
\exitnote 

\pnum
Every \grammarterm{constant-expression} in a
\grammarterm{direct-new-declarator} shall be an integral constant
expression~(\ref{expr.const}) and evaluate to a strictly positive value.
\indextext{\idxcode{new}}%
The \grammarterm{expression} in a \grammarterm{direct-new-declarator} shall
have integral or enumeration type~(\ref{basic.fundamental}) with a
non-negative value.
\enterexample
if \tcode{n} is a variable of type \tcode{int}, then
\tcode{new float[n][5]} is well-formed (because \tcode{n} is the
\grammarterm{expression} of a \grammarterm{direct-new-declarator}), but
\tcode{new float[5][n]} is ill-formed (because \tcode{n} is not a
\grammarterm{constant-expression}). If \tcode{n} is negative, the effect
of \tcode{new float[n][5]} is undefined.
\exitexample 

\pnum
\indextext{function!allocation}%
When the value of the \grammarterm{expression} in a \grammarterm{direct-new-declarator}
is zero, the allocation function is called to allocate an array with no elements.

\pnum
A \grammarterm{new-expression} obtains storage for the object by calling an
\term{allocation function}~(\ref{basic.stc.dynamic.allocation}). If
the \grammarterm{new-expression} terminates by throwing an exception, it
may release storage by calling a deallocation
function~(\ref{basic.stc.dynamic.deallocation}). If the allocated type
is a non-array type, the allocation function's name is
\indextext{\idxcode{operator new}}%
\indextext{\idxcode{operator delete}}%
\tcode{operator new} and the deallocation function's name is
\tcode{operator delete}. If the allocated type is an array type, the
allocation function's name is
\indextext{\idxcode{operator new}}%
\indextext{\idxcode{operator delete}}%
\tcode{operator new[]}
and the deallocation function's name is
\tcode{operator delete[]}.
\enternote 
an implementation shall provide default definitions for the global
allocation
functions~(\ref{basic.stc.dynamic},~\ref{lib.new.delete.single},~\ref{lib.new.delete.array}).
A \Cpp program can provide alternative definitions of
these functions~(\ref{lib.replacement.functions}) and/or class-specific
versions~(\ref{class.free}).
\exitnote 

\pnum
\indextext{operator!scope~resolution}%
If the \grammarterm{new-expression} begins with a unary \tcode{::}
operator, the allocation function's name is looked up in the global
scope. Otherwise, if the allocated type is a class type \tcode{T} or
array thereof, the allocation function's name is looked up in the scope
of \tcode{T}. If this lookup fails to find the name, or if the allocated
type is not a class type, the allocation function's name is looked up in
the global scope.

\pnum
A \grammarterm{new-expression} passes the amount of space requested to the
allocation function as the first argument of type
\tcode{std\colcol{}size_t}. That argument shall be no less than the size
of the object being created; it may be greater than the size of the
object being created only if the object is an array. For arrays of
\tcode{char} and \tcode{unsigned char}, the difference between the
result of the \grammarterm{new-expression} and the address returned by the
allocation function shall be an integral multiple of the
most stringent alignment requirement~(\ref{basic.types}) of any object
type whose size is no greater than the size of the array being created.
\enternote 
\indextext{allocation!alignment~storage}%
Because allocation functions are assumed to return pointers to storage
that is appropriately aligned for objects of any type, this constraint
on array allocation overhead permits the common idiom of allocating
character arrays into which objects of other types will later be placed.
\exitnote 

\pnum
\indextext{placement~syntax!\idxcode{new}}%
The \grammarterm{new-placement} syntax is used to supply additional
arguments to an allocation function. If used, overload resolution is
performed on a function call created by assembling an argument list
consisting of the amount of space requested (the first argument) and the
expressions in the \grammarterm{new-placement} part of the
\grammarterm{new-expression} (the second and succeeding arguments). The
first of these arguments has type \tcode{size_t} and the remaining
arguments have the corresponding types of the expressions in the
\grammarterm{new-placement}.

\pnum
\enterexample 

\begin{itemize}
\item \tcode{new T} results in a call of \tcode{operator
new(sizeof(T))},

\item \tcode{new(2,f) T} results in a call of \tcode{operator
new(sizeof(T),2,f)},

\item \tcode{new T[5]} results in a call of \tcode{operator
new[](sizeof(T)*5+x)}, and

\item \tcode{new(2,f) T[5]} results in a call of \tcode{operator
new[](sizeof(T)*5+y,2,f)}.
\end{itemize}

Here, \tcode{x} and \tcode{y} are non-negative unspecified values
representing array allocation overhead; the result of the
\grammarterm{new-expression} will be offset by this amount from the value
returned by \tcode{operator new[]}. This overhead may be applied in all
array \grammarterm{new-expression}{s}, including those referencing the
library function \tcode{operator new[](std::size_t, void*)} and other
placement allocation functions. The amount of overhead may vary from one
invocation of \tcode{new} to another.
\exitexample 

\pnum
\enternote 
unless an allocation function is declared with an empty
\grammarterm{exception-specification}~(\ref{except.spec}), \tcode{throw()},
it indicates failure to allocate storage by throwing a
\indextext{\idxcode{bad_alloc}}%
\indexlibrary{\idxcode{bad_alloc}}%
\term{bad_alloc} exception (clause~\ref{except},~\ref{lib.bad.alloc});
it returns a non-null pointer otherwise. If the allocation function is
declared with an empty \grammarterm{exception-specification},
\tcode{throw()}, it returns null to indicate failure to allocate storage
and a non-null pointer otherwise.
\exitnote 
If the allocation function returns null, initialization shall not be
done, the deallocation function shall not be called, and the value of
the \grammarterm{new-expression} shall be null.

\pnum
\enternote 
when the allocation function returns a value other than null, it must be
a pointer to a block of storage in which space for the object has been
reserved. The block of storage is assumed to be appropriately aligned
and of the requested size. The address of the created object will not
necessarily be the same as that of the block if the object is an array.
\exitnote 

\pnum
\indextext{\idxcode{new}!array~of class~objects~and}%
\indextext{\idxcode{new}!initialization~and}%
\indextext{\idxcode{new}!constructor~and}%
\indextext{\idxcode{new}!default~constructor~and}%
\indextext{constructor, default|see{default~constructor}}%
\indextext{trivial~type}%
\indextext{trivial~class~type}%
A \grammarterm{new-expression} that creates an object of type \tcode{T}
initializes that object as follows:

\begin{itemize}
\item If the \grammarterm{new-initializer} is omitted:

\begin{itemize}
\item If \tcode{T} is a (possibly cv-qualified) non-POD class type (or
array thereof), the object is
default-initialized~(\ref{dcl.init}). If \tcode{T} is a const-qualified
type, the underlying class type shall have a user-declared default
constructor.
\item Otherwise, the object created has indeterminate value. If \tcode{T}
is a const-qualified type, or a (possibly cv-qualified) POD class type
(or array thereof) containing (directly or indirectly) a member of
const-qualified type, the program is ill-formed;
\end{itemize}

\item If the \grammarterm{new-initializer} is of the form \tcode{()}, the
item is value-initialized~(\ref{dcl.init});

\item If the \grammarterm{new-initializer} is of the form
(\grammarterm{expression-list}) and \tcode{T} is a class type, the
appropriate constructor is called, using \grammarterm{expression-list} as
the arguments~(\ref{dcl.init});

\item If the \grammarterm{new-initializer} is of the form
(\grammarterm{expression-list}) and \tcode{T} is an arithmetic, enumeration,
pointer, or pointer-to-member type and \grammarterm{expression-list}
comprises exactly one expression, then the object is initialized to the
(possibly converted) value of the expression~(\ref{dcl.init});

\item Otherwise, the \grammarterm{new-initializer} is ill-formed.
\end{itemize}

\pnum
If the \grammarterm{new-expression} creates an object or an array of
objects of class type, access and ambiguity control are done for the
allocation function, the deallocation function~(\ref{class.free}), and
the constructor~(\ref{class.ctor}). If the new expression creates an
array of objects of class type, access and ambiguity control are done
for the destructor~(\ref{class.dtor}).

\pnum
\indextext{\idxcode{new}!exception~and}%
If any part of the object initialization described above\footnote{This may
include evaluating a \grammarterm{new-initializer} and/or calling
a constructor.}
terminates by throwing an exception and a suitable deallocation function
can be found, the deallocation function is called to free the memory in
which the object was being constructed, after which the exception
continues to propagate in the context of the \grammarterm{new-expression}.
If no unambiguous matching deallocation function can be found,
propagating the exception does not cause the object's memory to be
freed.
\enternote 
This is appropriate when the called allocation function does not
allocate memory; otherwise, it is likely to result in a memory leak.
\exitnote 

\pnum
If the \grammarterm{new-expression} begins with a unary \tcode{::}
operator, the deallocation function's name is looked up in the global
scope. Otherwise, if the allocated type is a class type \tcode{T} or an
array thereof, the deallocation function's name is looked up in the
scope of \tcode{T}. If this lookup fails to find the name, or if the
allocated type is not a class type or array thereof, the deallocation
function's name is looked up in the global scope.

\pnum
A declaration of a placement deallocation function matches the
declaration of a placement allocation function if it has the same number
of parameters and, after parameter transformations~(\ref{dcl.fct}), all
parameter types except the first are identical. Any non-placement
deallocation function matches a non-placement allocation function. If
the lookup finds a single matching deallocation function, that function
will be called; otherwise, no deallocation function will be called.

\pnum
If a \grammarterm{new-expression} calls a deallocation function, it passes
the value returned from the allocation function call as the first
argument of type \tcode{void*}. If a placement deallocation function is
called, it is passed the same additional arguments as were passed to the
placement allocation function, that is, the same arguments as those
specified with the \grammarterm{new-placement} syntax. If the
implementation is allowed to make a copy of any argument as part of the
call to the allocation function, it is allowed to make a copy (of the
same original value) as part of the call to the deallocation function or
to reuse the copy made as part of the call to the allocation function.
If the copy is elided in one place, it need not be elided in the other.

\pnum
Whether the allocation function is called before evaluating the
constructor arguments or after evaluating the constructor arguments but
before entering the constructor is unspecified. It is also unspecified
whether the arguments to a constructor are evaluated if the allocation
function returns the null pointer or exits using an exception.

\rSec2[expr.delete]{Delete}

\pnum
\indextext{expression!\idxcode{delete}}%
\indextext{\idxcode{delete}}%
The \grammarterm{delete-expression} operator destroys a most derived
object~(\ref{intro.object}) or array created by a
\grammarterm{new-expression}.

\begin{bnf}
\nontermdef{delete-expression}\br
    \terminal{::}\opt \terminal{delete} cast-expression\br
    \terminal{::}\opt \terminal{delete [ ]} cast-expression
\end{bnf}

The first alternative is for non-array objects, and the second is for arrays.
The operand shall have a pointer type, or a class type having a single
conversion function~(\ref{class.conv.fct}) to a pointer
type. The result has type \tcode{void}.

\pnum
\indextext{\idxcode{delete}!object}%
If the operand has a class type, the operand is converted to a pointer
type by calling the above-mentioned conversion function, and the
converted operand is used in place of the original operand for the
remainder of this section. In either alternative, if the value of the
operand of \tcode{delete} is the null pointer the operation has no effect.
\indextext{object!delete}%
In the first alternative
(\term{delete object}), the value of the operand of \tcode{delete} shall
be a pointer to a non-array object or a pointer to a
sub-object~(\ref{intro.object}) representing a base class of such an
object (clause~\ref{class.derived}). If not, the behavior is undefined.
\indextext{array!\idxcode{delete}}%
\indextext{\idxcode{delete}!array}%
In the second alternative (\term{delete array}), the value of the
operand of \tcode{delete} shall be the pointer value which resulted from
a previous array \grammarterm{new-expression}.\footnote{For non-zero-length
arrays, this is the same as a pointer to the first
element of the array created by that \grammarterm{new-expression}.
Zero-length arrays do not have a first element.}
If not, the behavior is undefined.
\enternote 
this means that the syntax of the \grammarterm{delete-expression} must
match the type of the object allocated by \tcode{new}, not the syntax of the
\grammarterm{new-expression}.
\exitnote 
\enternote 
a pointer to a \tcode{const} type can be the operand of a
\grammarterm{delete-expression}; it is not necessary to cast away the
constness~(\ref{expr.const.cast}) of the pointer expression before it is
used as the operand of the \grammarterm{delete-expression}.
\exitnote 

\pnum
\indextext{\idxcode{delete}!undefined}%
In the first alternative (\term{delete object}), if the static type of
the operand is different from its dynamic type, the static type shall be
a base class of the operand's dynamic type and the static type shall
have a virtual destructor or the behavior is undefined. In the second
alternative (\term{delete array}) if the dynamic type of the object to
be deleted differs from its static type, the behavior is undefined.%
\footnote{This implies that an object cannot be deleted using a pointer
of type \tcode{void*} because there are no objects of type \tcode{void}.}

\pnum
The \grammarterm{cast-expression} in a \grammarterm{delete-expression}
shall be evaluated exactly once. If the \grammarterm{delete-expression}
calls the implementation deallocation
function~(\ref{basic.stc.dynamic.deallocation}), and if the operand of
the delete expression is not the null pointer constant, the deallocation
function will deallocate the storage referenced by the pointer thus
rendering the pointer invalid.
\enternote
the value of a pointer that refers to deallocated storage is indeterminate.
\exitnote

\pnum
\indextext{type!incomplete}%
If the object being deleted has incomplete class type at the point of
deletion and the complete class has a non-trivial destructor or a
deallocation function, the behavior is undefined.

\pnum
\indextext{\idxcode{delete}!destructor~and}%
The \grammarterm{delete-expression} will invoke the
destructor (if any) for the object or the elements of the array being
deleted. In the case of an array, the elements will be destroyed in
order of decreasing address (that is, in reverse order of the completion
of their constructor; see~\ref{class.base.init}).

\pnum
The \grammarterm{delete-expression} will call a
\indextext{function!deallocation}%
\indextext{deallocation|see{\tcode{delete}}}%
\indextext{\idxcode{delete}}%
\term{deallocation function}~(\ref{basic.stc.dynamic.deallocation}).

\pnum
\enternote 
An implementation provides default definitions of the global
deallocation functions \tcode{operator delete()} for
non-arrays~(\ref{lib.new.delete.single}) and
\indextext{operator~|see{\tcode{delete}}}%
\indextext{\idxcode{operator delete}}%
\tcode{operator delete[]()} for arrays~(\ref{lib.new.delete.array}). A \Cpp
program can provide alternative definitions of these
functions~(\ref{lib.replacement.functions}), and/or class-specific
versions~(\ref{class.free}).
\exitnote 
When the keyword \tcode{delete} in a \grammarterm{delete-expression} is
preceded by the unary \tcode{::} operator, the global deallocation
function is used to deallocate the storage.

\pnum
Access and ambiguity control are done for both the deallocation function
and the destructor~(\ref{class.dtor},~\ref{class.free}).

\rSec1[expr.cast]{Explicit type conversion (cast notation)}%
\indextext{expression!cast|(}

\pnum
The result of the expression \tcode{(T)} \grammarterm{cast-expression} is
of type \tcode{T}. The result is an lvalue if \tcode{T} is a reference
type, otherwise the result is an rvalue.
\enternote 
if \tcode{T} is a non-class type that is \grammarterm{cv-qualified}, the
\grammarterm{cv-qualifiers} are ignored when determining the type of the
resulting rvalue; see~\ref{basic.lval}.
\exitnote 

\pnum
An explicit type conversion can be expressed using functional
notation~(\ref{expr.type.conv}), a type conversion operator
(\tcode{dynamic_cast}, \tcode{static_cast}, \tcode{reinterpret_cast},
\tcode{const_cast}), or the \term{cast} notation.

\begin{bnf}
\nontermdef{cast-expression}\br
    unary-expression\br
    \terminal{(} type-id \terminal{)} cast-expression
\end{bnf}

\pnum
Types shall not be defined in casts.

\pnum
Any type conversion not mentioned below and not explicitly defined by
the user~(\ref{class.conv}) is ill-formed.

\pnum
The conversions performed by

\begin{itemize}
\indextext{cast!const}%
\indextext{cast!static}%
\indextext{cast!reinterpret}%
\item a \tcode{const_cast}~(\ref{expr.const.cast}),
\item a \tcode{static_cast}~(\ref{expr.static.cast}),
\item a \tcode{static_cast} followed by a \tcode{const_cast},
\item a \tcode{reinterpret_cast}~(\ref{expr.reinterpret.cast}), or
\item a \tcode{reinterpret_cast} followed by a \tcode{const_cast},
\end{itemize}

can be performed using the cast notation of explicit type conversion.
The same semantic restrictions and behaviors apply. If a conversion
can be interpreted in more than one of the ways listed above, the
interpretation that appears first in the list is used, even if a cast
resulting from that interpretation is ill-formed. If a conversion can be
interpreted in more than one way as a \tcode{static_cast} followed by a
\tcode{const_cast}, the conversion is ill-formed.
\enterexample

\begin{codeblock}
struct A {};
struct I1 : A {};
struct I2 : A {};
struct D : I1, I2 {};
A *foo( D *p ) {
	return (A*)( p );	// ill-formed \tcode{static_cast} interpretation
}
\end{codeblock}

\exitexampleb

\pnum
\indextext{class!cast~to incomplete}%
The operand of a cast using the cast notation can be an rvalue of type
``pointer to incomplete class type''. The destination type of a cast
using the cast notation can be ``pointer to incomplete class type''. In
such cases, even if there is a inheritance relationship between the
source and destination classes, whether the \tcode{static_cast} or
\tcode{reinterpret_cast} interpretation is used is unspecified.

\pnum
In addition to those conversions, the following \tcode{static_cast} and
\tcode{reinterpret_cast} operations (optionally followed by a
\tcode{const_cast} operation) may be performed using the cast notation
of explicit type conversion, even if the base class type is not accessible:

\begin{itemize}
\item a pointer to an object of derived class type or an lvalue of
derived class type may be explicitly converted to a pointer or
reference to an unambiguous base class type, respectively;

\item a pointer to member of derived class type may be explicitly
converted to a pointer to member of an unambiguous non-virtual base
class type;

\item a pointer to an object of non-virtual base class type, an lvalue
of non-virtual base class type, or a pointer to member of non-virtual
base class type may be explicitly converted to a pointer, a reference,
or a pointer to member of a derived class type, respectively.
\end{itemize}
\indextext{expression!cast|)}

\rSec1[expr.mptr.oper]{Pointer-to-member operators}

\pnum
\indextext{expression!pointer-to-member}%
\indextext{pointer~to~member}%
\indextext{operator!pointer~to~member}%
\indextext{\idxcode{.*}|see{pointer~to~member~operator}}%
\indextext{operator!pointer~to~member}%
\indextext{\idxcode{->*}|see{pointer~to~member~operator}}%
The pointer-to-member operators \tcode{->*} and \tcode{.*} group
left-to-right.

\begin{bnf}
\nontermdef{pm-expression}\br
    cast-expression\br
    pm-expression \terminal{.*} cast-expression\br
    pm-expression \terminal{->*} cast-expression
\end{bnf}

\pnum
The binary operator \tcode{.*} binds its second operand, which shall be
of type ``pointer to member of \tcode{T}'' (where \tcode{T} is a
completely-defined class type) to its first operand, which shall be of
class \tcode{T} or of a class of which \tcode{T} is an unambiguous and
accessible base class. The result is an object or a function of the type
specified by the second operand.

\pnum
The binary operator \tcode{->*} binds its second operand, which shall be
of type ``pointer to member of \tcode{T}'' (where \tcode{T} is a
completely-defined class type) to its first operand, which shall be of
type ``pointer to \tcode{T}'' or ``pointer to a class of which \tcode{T}
is an unambiguous and accessible base class.'' The result is an object
or a function of the type specified by the second operand.

\pnum
If the dynamic type of the object does not contain the member to which
the pointer refers, the behavior is undefined.

\pnum
The restrictions on \cvqual{cv-}qualification, and the manner in which
the \cvqual{cv-}qualifiers of the operands are combined to produce the
\cvqual{cv-}qualifiers of the result, are the same as the rules for
\tcode{E1.E2} given in~\ref{expr.ref}.
\enternote 
it is not possible to use a pointer to member that refers to a
\tcode{mutable} member to modify a \tcode{const} class object. For
example,

\begin{codeblock}
struct S {
	mutable int i;
};
const S cs;
int S::* pm = &S::i;            // \tcode{pm} refers to \tcode{mutable} member \tcode{S::i}
cs.*pm = 88;                    // ill-formed: \tcode{cs} is a \tcode{const} object
\end{codeblock}
\exitnote 

\pnum
\indextext{function!pointer~to~member}%
If the result of \tcode{.*} or \tcode{->*} is a function, then that
result can be used only as the operand for the function call operator
\tcode{()}.
\enterexample 

\begin{codeblock}
(ptr_to_obj->*ptr_to_mfct)(10);
\end{codeblock}

calls the member function denoted by \tcode{ptr_to_mfct} for the object
pointed to by \tcode{ptr_to_obj}.
\exitexample 
The result of a \tcode{.*} expression is an lvalue only if its first
operand is an lvalue and its second operand is a pointer to data member.
The result of a \tcode{->*} expression is an lvalue only if its second
operand is a pointer to data member. If the second operand is the null
pointer to member value~(\ref{conv.mem}), the behavior is undefined.

\rSec1[expr.mul]{Multiplicative operators}%
\indextext{expression!multiplicative~operators}%
\indextext{operator!multiplicative}

\pnum
The multiplicative operators \tcode{*}, \tcode{/}, and \tcode{\%} group
left-to-right.

\indextext{operator!multiplication}%
\indextext{\idxcode{*}|see{multiplication~operator}}%
\indextext{operator!division}%
\indextext{\idxcode{/}|see{division~operator}}%
\indextext{operator!remainder}%
\indextext{\idxcode{\%}|see{remainder~operator}}%
\indextext{remainder~operator|see{remainder~operator}}%
%
\begin{bnf}
\nontermdef{multiplicative-expression}\br
    pm-expression\br
    multiplicative-expression \terminal{*} pm-expression\br
    multiplicative-expression \terminal{/} pm-expression\br
    multiplicative-expression \terminal{\%} pm-expression
\end{bnf}

\pnum
The operands of \tcode{*} and \tcode{/} shall have arithmetic or
enumeration type; the operands of \tcode{\%} shall have integral or
enumeration type. The usual arithmetic conversions are performed on the
operands and determine the type of the result.

\pnum
The binary \tcode{*} operator indicates multiplication.

\pnum
The binary \tcode{/} operator yields the quotient, and the binary
\tcode{\%} operator yields the remainder from the division of the first
expression by the second.
\indextext{zero!undefined division~by}%
If the second operand of \tcode{/} or \tcode{\%} is zero the behavior is
undefined; otherwise \tcode{(a/b)*b + a\%b} is equal to \tcode{a}.
If both operands are nonnegative then the remainder is nonnegative; if
not, the sign of the remainder is
\impldef{Sign of modulo remainder}\footnote{According to work underway
toward the revision of ISO C, the preferred algorithm for integer
division follows the rules defined in the ISO Fortran standard,
ISO/IEC 1539:1991, in which the quotient is always rounded toward zero.}.

\rSec1[expr.add]{Additive operators}%
\indextext{expression!additive~operators}%
\indextext{operator!additive}

\pnum
The additive operators \tcode{+} and \tcode{-} group left-to-right. The
usual arithmetic conversions are performed for operands of arithmetic or
enumeration type.

\indextext{addition~operator}%
\indextext{\idxcode{+}|see{addition~operator}}%
\indextext{subtraction~operator}%
\indextext{\idxcode{-}|see{subtraction~operator}}%
%
\begin{bnf}
\nontermdef{additive-expression}\br
    multiplicative-expression\br
    additive-expression \terminal{+} multiplicative-expression\br
    additive-expression \terminal{-} multiplicative-expression
\end{bnf}

\indextext{incomplete}%
For addition, either both operands shall have arithmetic or enumeration
type, or one operand shall be a pointer to a completely defined object
type and the other shall have integral or enumeration type.

\pnum
For subtraction, one of the following shall hold:

\begin{itemize}
\item both operands have arithmetic or enumeration type; or

\indextext{arithmetic!pointer}%
\item both operands are pointers to cv-qualified or cv-unqualified
versions of the same completely defined object type; or

\item the left operand is a pointer to a completely defined object type
and the right operand has integral or enumeration type.
\end{itemize}

\pnum
The result of the binary \tcode{+} operator is the sum of the operands.
The result of the binary \tcode{-} operator is the difference resulting
from the subtraction of the second operand from the first.

\pnum
\indextext{arithmetic!pointer}%
For the purposes of these operators, a pointer to a nonarray object
behaves the same as a pointer to the first element of an array of length
one with the type of the object as its element type.

\pnum
When an expression that has integral type is added to or subtracted from
a pointer, the result has the type of the pointer operand. If the
pointer operand points to an element of an array object, and the array
is large enough, the result points to an element offset from the
original element such that the difference of the subscripts of the
resulting and original array elements equals the integral expression. In
other words, if the expression \tcode{P} points to the $i$-th element of
an array object, the expressions \tcode{(P)+N} (equivalently,
\tcode{N+(P)}) and \tcode{(P)-N} (where \tcode{N} has the value $n$)
point to, respectively, the $i+n$-th and $i-n$-th elements of the array
object, provided they exist. Moreover, if the expression \tcode{P}
points to the last element of an array object, the expression
\tcode{(P)+1} points one past the last element of the array object, and
if the expression \tcode{Q} points one past the last element of an array
object, the expression \tcode{(Q)-1} points to the last element of the
array object. If both the pointer operand and the result point to
elements of the same array object, or one past the last element of the
array object, the evaluation shall not produce an overflow; otherwise,
the behavior is undefined.

\pnum
\indextext{\idxcode{ptrdiff_t}!implementation~defined type~of}%
\indextext{subtraction!implementation~defined pointer}%
\indextext{\idxcode{ptrdiff_t}}%
\indextext{\idxhdr{cstddef}}%
\indextext{comparison!undefined pointer}%
When two pointers to elements of the same array object are subtracted,
the result is the difference of the subscripts of the two array
elements. The type of the result is an \impldef{type of \tcode{ptrdiff_t}} signed
integral type; this type shall be the same type that is defined as
\tcode{ptrdiff_t} in the \tcode{<cstddef>}
header~(\ref{lib.support.types}). As with any other arithmetic overflow, if
the result does not fit in the space provided, the behavior is
undefined. In other words, if the expressions \tcode{P} and \tcode{Q}
point to, respectively, the $i$-th and $j$-th elements of an array
object, the expression \tcode{(P)-(Q)} has the value $i-j$ provided the
value fits in an object of type \tcode{ptrdiff_t}. Moreover, if the
expression \tcode{P} points either to an element of an array object or
one past the last element of an array object, and the expression
\tcode{Q} points to the last element of the same array object, the
expression \tcode{((Q)+1)-(P)} has the same value as \tcode{((Q)-(P))+1}
and as \tcode{-((P)-((Q)+1))}, and has the value zero if the expression
\tcode{P} points one past the last element of the array object, even
though the expression \tcode{(Q)+1} does not point to an element of the
array object. Unless both pointers point to elements of the same array
object, or one past the last element of the array object, the behavior
is undefined.\footnote{Another way to approach pointer arithmetic is first to convert the
pointer(s) to character pointer(s): In this scheme the integral value of
the expression added to or subtracted from the converted pointer is
first multiplied by the size of the object originally pointed to, and
the resulting pointer is converted back to the original type. For
pointer subtraction, the result of the difference between the character
pointers is similarly divided by the size of the object originally
pointed to.

When viewed in this way, an implementation need only provide one extra
byte (which might overlap another object in the program) just after the
end of the object in order to satisfy the ``one past the last element''
requirements.}

\pnum
If the value 0 is added to or subtracted from a pointer value, the
result compares equal to the original pointer value. If two pointers
point to the same object or both point one past the end of the same
array or both are null, and the two pointers are subtracted, the result
compares equal to the value 0 converted to the type
\tcode{ptrdiff_t}.

\rSec1[expr.shift]{Shift operators}

\pnum
\indextext{expression!left-shift-operator}%
\indextext{expression!right-shift-operator}%
\indextext{shift~operator|see{left~shift~operator,~right~shift~operator}}%
\indextext{operator~right~shift|see{right~shift~operator}}%
\indextext{operator~left~shift|see{left~shift~operator}}%
The shift operators \tcode{\shl} and \tcode{\shr} group left-to-right.

\indextext{left~shift~operator}%
\indextext{\idxcode{\shl}|see{left~shift~operator}}%
\indextext{right~shift~operator}%
\indextext{\idxcode{\shr}|see{right~shift~operator}}%
%
\begin{bnf}
\nontermdef{shift-expression}\br
    additive-expression\br
    shift-expression \terminal{\shl} additive-expression\br
    shift-expression \terminal{\shr} additive-expression
\end{bnf}

The operands shall be of integral or enumeration type and integral
promotions are performed. The type of the result is that of the promoted
left operand.
\indextext{left~shift!undefined}%
The behavior is undefined if the right operand is negative, or greater
than or equal to the length in bits of the promoted left operand.

\pnum
The value of \tcode{E1 \shl\ E2} is \tcode{E1} (interpreted as a bit
patterm) left-shifted \tcode{E2} bit positions; vacated bits are
zero-filled. If \tcode{E1} has an unsigned type, the value of the result
is \tcode{E1} multiplied by the quantity 2 raised to the power \tcode{E2},
reduced modulo \tcode{ULONG_MAX+1} if \tcode{E1} has type unsigned long,
\tcode{UINT_MAX+1} otherwise.
\enternote the constants \tcode{ULONG_MAX} and \tcode{UINT_MAX} are defined
in the header \tcode{<climits>}). \exitnote

\pnum
The value of \tcode{E1 \shr\ E2} is \tcode{E1} right-shifted \tcode{E2}
bit positions. If \tcode{E1} has an unsigned type or if \tcode{E1} has a
signed type and a nonnegative value, the value of the result is the
integral part of the quotient of \tcode{E1} divided by the quantity 2
raised to the power \tcode{E2}. If \tcode{E1}
\indextext{right~shift!implementation~defined}%
has a signed type and a negative value, the resulting value is
\impldef{result of right shift of negative value}.

\rSec1[expr.rel]{Relational operators}%
\indextext{expression!relational operators}%
\indextext{operator!relational}

\pnum
The relational operators group left-to-right.
\enterexample 
\tcode{a<b<c} means \tcode{(a<b)<c} and \emph{not}
\tcode{(a<b)\&\&(b<c)}.
\exitexample 

\indextext{operator!less~than}%
\indextext{\idxcode{<}|see{less~than~operator}}%
\indextext{operator!greater~than}%
\indextext{\idxcode{>}|see{greater~than~operator}}%
\indextext{operator!less~than~or~equal~to}%
\indextext{\idxcode{<=}|see{less~than~or~equal~to~operator}}%
\indextext{operator!greater~than~or~equal~to}%
\indextext{\idxcode{>=}|see{greater~than~or~equal~operator}}%
%
\begin{bnf}
\nontermdef{relational-expression}\br
    shift-expression\br
    relational-expression \terminal{<} shift-expression\br
    relational-expression \terminal{>} shift-expression\br
    relational-expression \terminal{<=} shift-expression\br
    relational-expression \terminal{>=} shift-expression
\end{bnf}

The operands shall have arithmetic, enumeration or pointer type. The
operators \tcode{<} (less than), \tcode{>} (greater than), \tcode{<=}
(less than or equal to), and \tcode{>=} (greater than or equal to) all
yield \tcode{false} or \tcode{true}. The type of the result is
\tcode{bool}.

\pnum
The usual arithmetic conversions are performed on operands of arithmetic
or enumeration type. Pointer conversions~(\ref{conv.ptr}) and
qualification conversions~(\ref{conv.qual}) are performed on pointer
operands (or on a pointer operand and a null pointer constant) to bring
them to their \term{composite pointer type}. If one operand is a
null pointer constant, the composite pointer type is the type of the
other operand. Otherwise, if one of the operands has type ``pointer to
\cvqual{cv1} \tcode{void}'', then the other has type ``pointer to
\cvqual{cv2} \term{T}'' and the composite pointer type is ``pointer to
\cvqual{cv12} \tcode{void}'', where \cvqual{cv12} is the union of
\cvqual{cv1} and \cvqual{cv2}. Otherwise, the composite pointer type is
a pointer type similar~(\ref{conv.qual}) to the type of one of the
operands, with a cv-qualification signature~(\ref{conv.qual}) that is
the union of the cv-qualification signatures of the operand types.
\enternote 
\indextext{comparison!void* pointer@\tcode{void*} pointer}%
this implies
that any pointer can be compared to a null pointer constant and that any
object pointer can be compared to a pointer to (possibly cv-qualified)
\tcode{void}.
\exitnote 
\enterexample 

\begin{codeblock}
void *p;
const int *q;
int **pi;
const int *const *pci;
void ct()
{
    p <= q;			// Both converted to \tcode{const void *} before comparison
    pi <= pci;			// Both converted to \tcode{const int *const *} before comparison
}
\end{codeblock}
\exitexampleb
\indextext{comparison!pointer}%
\indextext{comparison!pointer~to function}%
Pointers to objects or functions of the same type (after pointer
conversions) can be compared, with a result defined as follows:

\begin{itemize}
\item If two pointers \tcode{p} and \tcode{q} of the same type point to
the same object or function, or both point one past the end of the same
array, or are both null, then \tcode{p<=q} and \tcode{p>=q} both yield
\tcode{true} and \tcode{p<q} and \tcode{p>q} both yield \tcode{false}.

\item If two pointers \tcode{p} and \tcode{q} of the same type point to
different objects that are not members of the same object or elements of
the same array or to different functions, or if only one of them is
null, the results of \tcode{p<q}, \tcode{p>q}, \tcode{p<=q}, and
\tcode{p>=q} are unspecified.

\item If two pointers point to nonstatic data members of the same
object, or to subobjects or array elements of such members, recursively,
the pointer to the later declared member compares greater provided the
two members are not separated by an \grammarterm{access-specifier}
label~(\ref{class.access.spec}) and provided their class is not a union.

\indextext{comparison!undefined pointer}%
\item If two pointers point to nonstatic data members of the same
object separated by an \grammarterm{access-specifier}
label~(\ref{class.access.spec}) the result is unspecified.

\item If two pointers point to data members of the same union object,
they compare equal (after conversion to \tcode{void*}, if necessary). If
two pointers point to elements of the same array or one beyond the end
of the array, the pointer to the object with the higher subscript
compares higher.

\indextext{comparison!unspecified pointer}%
\indextext{comparison!pointer}%
\item Other pointer comparisons are unspecified.
\end{itemize}


\rSec1[expr.eq]{Equality operators}%
\indextext{expression!equality~operators}%
\indextext{operator!equality}%
\indextext{operator!inequality}

\begin{bnf}
\nontermdef{equality-expression}\br
    relational-expression\br
    equality-expression \terminal{==} relational-expression\br
    equality-expression \terminal{!=} relational-expression
\end{bnf}

\pnum
The \tcode{==} (equal to) and the \tcode{!=} (not equal to) operators
have the same semantic restrictions, conversions, and result type as the
relational operators except for their lower precedence and truth-value
result.
\enternote 
\tcode{a<b == c<d} is \tcode{true} whenever \tcode{a<b} and \tcode{c<d}
have the same truth-value.
\exitnote 
\indextext{comparison!pointer}%
\indextext{comparison!pointer~to function}%
Pointers to objects or functions of the same type (after pointer
conversions) can be compared for equality. Two pointers of the same type
compare equal if and only if they are both null, both point to the same
\indextext{address}%
function, or both represent the same address~(\ref{basic.compound}).

\pnum
In addition, pointers to members can be compared, or a pointer to member
and a null pointer constant. Pointer to member
conversions~(\ref{conv.mem}) and qualification
conversions~(\ref{conv.qual}) are performed to bring them to a common
type. If one operand is a null pointer constant, the common type is the
type of the other operand. Otherwise, the common type is a pointer to
member type similar~(\ref{conv.qual}) to the type of one of the
operands, with a cv-qualification signature~(\ref{conv.qual}) that is
the union of the cv-qualification signatures of the operand types.
\enternote 
this implies that any pointer to member can be compared to a null
pointer constant.
\exitnote 
If both operands are null, they compare equal. Otherwise if only one is
null, they compare unequal. Otherwise if either is a pointer to a
virtual member function, the result is unspecified. Otherwise they
compare equal if and only if they would refer to the same member of the
same most derived object~(\ref{intro.object}) or the same subobject if
they were dereferenced with a hypothetical object of the associated
class type.
\enterexample 

\begin{codeblock}
struct B {
	int f();
};
struct L : B { };
struct R : B { };
struct D : L, R { };

int (B::*pb)() = &B::f;
int (L::*pl)() = pb;
int (R::*pr)() = pb;
int (D::*pdl)() = pl;
int (D::*pdr)() = pr;
bool x = (pdl == pdr);          // \tcode{false}
\end{codeblock}
\exitexampleb

\rSec1[expr.bit.and]{Bitwise \logop{AND} operator}%
\indextext{expression!bitwise~AND}%
\indextext{operator!bitwise}%
\indextext{operator!bitwise AND}%
\indextext{\idxcode{\&}|see{bitwise~AND~operator}}%

\begin{bnf}
\nontermdef{and-expression}\br
    equality-expression\br
    and-expression \terminal{\&} equality-expression
\end{bnf}

\pnum
The usual arithmetic conversions are performed; the result is the
bitwise \logop{AND} function of the operands. The operator
applies only to integral or enumeration operands.

\rSec1[expr.xor]{Bitwise exclusive \logop{OR} operator}%
\indextext{expression!bitwise~exclusive~OR}%
\indextext{operator!bitwise~exclusive OR}%
\indextext{\idxcode{\exor}|see{bitwise~exclusive~OR~operator}}

\begin{bnf}
\nontermdef{exclusive-or-expression}\br
    and-expression\br
    exclusive-or-expression \terminal{\^{}} and-expression
\end{bnf}

\pnum
The usual arithmetic conversions are performed; the result is the
bitwise exclusive \logop{OR} function of the operands. The
operator applies only to integral or enumeration operands.

\rSec1[expr.or]{Bitwise inclusive \logop{OR} operator}%
\indextext{expression!bitwise~inclusive~OR}%
\indextext{operator!bitwise~inclusive OR}%
\indextext{\idxcode{"|}|see{bitwise~inclusive~OR~operator}}

\begin{bnf}
\nontermdef{inclusive-or-expression}\br
    exclusive-or-expression\br
    inclusive-or-expression \terminal{|} exclusive-or-expression
\end{bnf}

\pnum
The usual arithmetic conversions are performed; the result is the
bitwise inclusive \logop{OR} function of its operands. The
operator applies only to integral or enumeration operands.

\rSec1[expr.log.and]{Logical \logop{AND} operator}%
\indextext{expression!logical~AND}%
\indextext{operator!logical AND}%
\indextext{\idxcode{\&\&}|see{logical~AND~operator}}%

\begin{bnf}
\nontermdef{logical-and-expression}\br
    inclusive-or-expression\br
    logical-and-expression \terminal{\&\&} inclusive-or-expression
\end{bnf}

\pnum
The \tcode{\&\&} operator groups left-to-right. The operands are both
contextually converted to type \tcode{bool} (clause~\ref{conv}). The
result is \tcode{true} if both operands are \tcode{true} and
\tcode{false} otherwise. Unlike \tcode{\&}, \tcode{\&\&} guarantees
left-to-right evaluation: the second operand is not evaluated if the
first operand is \tcode{false}.

\pnum
The result is a \tcode{bool}.
\indextext{operator!side~effects~and logical AND}%
\indextext{side effects}%
All side effects of the first expression except for destruction of
temporaries~(\ref{class.temporary}) happen before the second expression
is evaluated.

\rSec1[expr.log.or]{Logical \logop{OR} operator}%
\indextext{expression!logical~OR}%
\indextext{operator!logical OR}%
\indextext{\idxcode{"|"|}|see{logical~OR~operator}}%

\begin{bnf}
\nontermdef{logical-or-expression}\br
    logical-and-expression\br
    logical-or-expression \terminal{||} logical-and-expression
\end{bnf}

\pnum
The \tcode{||} operator groups left-to-right. The operands are both
implicitly converted to \tcode{bool} (clause~\ref{conv}). It returns
\tcode{true} if either of its operands is \tcode{true}, and
\tcode{false} otherwise. Unlike \tcode{|}, \tcode{||} guarantees
left-to-right evaluation; moreover, the second operand is not evaluated
if the first operand evaluates to \tcode{true}.

\pnum
The result is a \tcode{bool}.
\indextext{operator!side~effects~and logical OR}%
\indextext{side effects}%
All side effects of the first expression except for destruction of
temporaries~(\ref{class.temporary}) happen before the second expression
is evaluated.

\rSec1[expr.cond]{Conditional operator}%
\indextext{expression!conditional~operator}%
\indextext{operator!conditional~expression}%
\indextext{\idxcode{?:}|see{conditional~expression~operator}}%

\begin{bnf}
\nontermdef{conditional-expression}\br
    logical-or-expression\br
    logical-or-expression \terminal{?} expression \terminal{:} assignment-expression
\end{bnf}

\pnum
Conditional expressions group right-to-left. The first expression is
implicitly converted to \tcode{bool} (clause~\ref{conv}). It is
evaluated and if it is \tcode{true}, the result of the conditional
expression is the value of the second expression, otherwise that of the
third expression.
\indextext{operator!side~effects~and conditional}%
\indextext{side effects}%
All side effects of the first expression except for destruction of
temporaries~(\ref{class.temporary}) happen before the second or third
expression is evaluated. Only one of the second and third expressions
is evaluated.

\pnum
If either the second or the third operand has type (possibly cv-qualified)
\tcode{void}, then the lvalue-to-rvalue~(\ref{conv.lval}),
array-to-pointer~(\ref{conv.array}), and
function-to-pointer~(\ref{conv.func}) standard conversions are performed
on the second and third operands, and one of the following shall hold:

\begin{itemize}
\indextext{conditional-expression!throw-expression~in}%
\item The second or the third operand (but not both) is a
\grammarterm{throw-expression}~(\ref{except.throw}); the result is of the
type of the other and is an rvalue.

\item Both the second and the third operands have type \tcode{void}; the
result is of type \tcode{void} and is an rvalue. \enternote this
includes the case where both operands are \grammarterm{throw-expression}{s}.
\exitnote
\end{itemize}

\pnum
Otherwise, if the second and third operand have different types, and
either has (possibly cv-qualified) class type, an attempt is made to
convert each of those operands to the type of the other. The process for
determining whether an operand expression \tcode{E1} of type \tcode{T1}
can be converted to match an operand expression \tcode{E2} of type
\tcode{T2} is defined as follows:

\begin{itemize}
\item If \tcode{E2} is an lvalue: \tcode{E1} can be converted to match
\tcode{E2} if \tcode{E1} can be implicitly converted (clause~\ref{conv})
to the type ``reference to \tcode{T2}'', subject to the
constraint that in the conversion the reference must bind
directly~(\ref{dcl.init.ref}) to \tcode{E1}.

\item If \tcode{E2} is an rvalue, or if the conversion above cannot be
done:

\begin{itemize}
\item if \tcode{E1} and \tcode{E2} have class type, and the underlying
class types are the same or one is a base class of the other: \tcode{E1}
can be converted to match \tcode{E2} if the class of \tcode{T2} is the
same type as, or a base class of, the class of \tcode{T1}, and the
cv-qualification of \tcode{T2} is the same cv-qualification as, or a
greater cv-qualification than, the cv-qualification of \tcode{T1}. If
the conversion is applied, \tcode{E1} is changed to an rvalue of type
\tcode{T2} that still refers to the original source class object (or the
appropriate subobject thereof).
\enternote that is, no copy is made. \exitnote

\item Otherwise (i.e., if \tcode{E1} or \tcode{E2} has a nonclass type,
or if they both have class types but the underlying classes are not
either the same or one a base class of the other): \tcode{E1} can be
converted to match \tcode{E2} if \tcode{E1} can be implicitly converted
to the type that expression \tcode{E2} would have if \tcode{E2} were
converted to an rvalue (or the type it has, if \tcode{E2} is an rvalue).
\end{itemize}

Using this process, it is determined whether the second operand can be
converted to match the third operand, and whether the third operand can
be converted to match the second operand. If both can be converted, or
one can be converted but the conversion is ambiguous, the program is
ill-formed. If neither can be converted, the operands are left unchanged
and further checking is performed as described below. If exactly one
conversion is possible, that conversion is applied to the chosen operand
and the converted operand is used in place of the original operand for
the remainder of this section.
\end{itemize}

\pnum
If the second and third operands are lvalues and have the same type, the
result is of that type and is an lvalue.

\pnum
Otherwise, the result is an rvalue. If the second and third operands do
not have the same type, and either has (possibly cv-qualified) class
type, overload resolution is used to determine the conversions (if any)
to be applied to the operands~(\ref{over.match.oper},~\ref{over.built}).
If the overload resolution fails, the program is ill-formed. Otherwise,
the conversions thus determined are applied, and the converted operands
are used in place of the original operands for the remainder of this
section.

\pnum
Lvalue-to-rvalue~(\ref{conv.lval}), array-to-pointer~(\ref{conv.array}),
and function-to-pointer~(\ref{conv.func}) standard conversions are
performed on the second and third operands. After those conversions, one
of the following shall hold:

\begin{itemize}
\item The second and third operands have the same type; the result is of
that type.

\item The second and third operands have arithmetic or enumeration type;
the usual arithmetic conversions are performed to bring them to a common
type, and the result is of that type.

\item The second and third operands have pointer type, or one has
pointer type and the other is a null pointer constant; pointer
conversions~(\ref{conv.ptr}) and qualification
conversions~(\ref{conv.qual}) are performed to bring them to their
composite pointer type~(\ref{expr.rel}). The result is of the composite
pointer type.

\item The second and third operands have pointer to member type, or one
has pointer to member type and the other is a null pointer constant;
pointer to member conversions~(\ref{conv.mem}) and qualification
conversions~(\ref{conv.qual}) are performed to bring them to a common
type, whose cv-qualification shall match the cv-qualification of either
the second or the third operand. The result is of the common type.
\end{itemize}

\rSec1[expr.ass]{Assignment operators}%
\indextext{expression!assignment and compound assignment}

\pnum
\indextext{operator!assignment}%
\indextext{\idxcode{=}|see{assignment~operator}}%
\indextext{operator!\idxcode{+=}}%
\indextext{operator!\idxcode{-=}}%
\indextext{operator!\idxcode{*=}}%
\indextext{operator!\idxcode{/=}}%
\indextext{operator!\idxcode{\%=}}%
\indextext{operator!\idxcode{\shr=}}%
\indextext{operator!\idxcode{\shl=}}%
\indextext{operator!\idxcode{\&=}}%
\indextext{operator!\idxcode{\^{}=}}%
\indextext{operator!\idxcode{"|=}}%
There are several assignment operators, all of which group right-to-left.
\indextext{assignment!and lvalue}%
All require a modifiable lvalue as their left operand, and the type
of an assignment expression is that of its left operand. The result
of the assignment operation is the value stored in the left operand
after the assignment has taken place; the result is an lvalue.

\begin{bnf}
\nontermdef{assignment-expression}\br
    conditional-expression\br
    logical-or-expression assignment-operator assignment-expression\br
    throw-expression
\end{bnf}

\begin{bnf}
\nontermdef{assignment-operator} \textnormal{one of}\br
    \terminal{=  *=  /=  \%=   +=  -=  \shr=  \shl=  \&=  \^{}=  |=}
\end{bnf}

\pnum
In simple assignment (\tcode{=}), the value of the expression replaces
that of the object referred to by the left operand.

\pnum
\indextext{assignment!conversion~by}%
If the left operand is not of class type, the expression is implicitly
converted (clause~\ref{conv}) to the cv-unqualified type of the left
operand.

\pnum
\indextext{class~object!assignment~to}%
\indextext{type!incomplete}%
If the left operand is of class type, the class shall be complete.
Assignment to objects of a class is defined by the copy assignment
operator~(\ref{class.copy},~\ref{over.ass}).

\pnum
\enternote 
For class objects, assignment is not in general the same as
initialization~(\ref{dcl.init},~\ref{class.ctor},~\ref{class.init},~\ref{class.copy}).
\exitnote 

\pnum
\indextext{reference!assignment~to}%
When the left operand of an assignment operator denotes a reference to
\tcode{T}, the operation assigns to the object of type \tcode{T} denoted
by the reference.

\pnum
The behavior of an expression of the form \tcode{E1} \term{op}{}\tcode{=}
\tcode{E2} is equivalent to \tcode{E1 = E1} \term{op} \tcode{E2} except
that \tcode{E1} is evaluated only once. In \tcode{+=} and \tcode{-=},
\tcode{E1} shall either have arithmetic type or be a pointer to a
possibly cv-qualified completely defined object type. In all other
cases, \tcode{E1} shall have arithmetic type.

\pnum
If the value being stored in an object is accessed from another object that
overlaps in any way the storage of the first object, then the overlap shall be
exact and the two objects shall have the same type, otherwise the behavior is
undefined.

\rSec1[expr.comma]{Comma operator}%
\indextext{expression!comma}%
\indextext{operator!comma}%
\indextext{\idxcode{,}|see{comma~operator}}%
\indextext{sequencing~operator|see{comma~operator}}%

\pnum
The comma operator groups left-to-right.

\begin{bnf}
\nontermdef{expression}\br
    assignment-expression\br
    expression \terminal{,} assignment-expression
\end{bnf}

A pair of expressions separated by a comma is evaluated left-to-right
and the value of the left expression is discarded. The
lvalue-to-rvalue~(\ref{conv.lval}), array-to-pointer~(\ref{conv.array}),
and function-to-pointer~(\ref{conv.func}) standard conversions are not
applied to the left expression.
\indextext{operator!side~effects~and comma}%
All side effects~(\ref{intro.execution})
of the left expression, except for the destruction of
temporaries~(\ref{class.temporary}), are performed before the evaluation of
the right expression. The type and value of the
result are the type and value of the right operand; the result is
an lvalue if its right operand is.

\pnum
In contexts where comma is given a special meaning, \enterexample in
lists of arguments to functions~(\ref{expr.call}) and lists of
initializers~(\ref{dcl.init}) \exitexample the comma operator as
described in clause~\ref{expr} can appear only in parentheses.
\enterexample 

\begin{codeblock}
f(a, (t=3, t+2), c);
\end{codeblock}

has three arguments, the second of which has the value
\tcode{5}.
\exitexample 

\rSec1[expr.const]{Constant expressions}%
\indextext{expression!constant}

\pnum
In several places, \Cpp require expressions that evaluate to an integral
or enumeration constant: as array bounds~(\ref{dcl.array}, \ref{expr.new}),
as \tcode{case} expressions~(\ref{stmt.switch}), as bit-field
lengths~(\ref{class.bit}), as enumerator initializers~(\ref{dcl.enum}),
as static member initializers~(\ref{class.static.data}), and as integral
or enumeration non-type template arguments~(\ref{temp.arg}).

\begin{bnf}
\nontermdef{constant-expression}\br
    conditional-expression
\end{bnf}

An \term{integral constant-expression} can involve only
literals~(\ref{lex.literal}), enumerators, \tcode{const} variables or static
data members of integral or enumeration types initialized with constant
expressions~(\ref{dcl.init}), non-type template parameters of integral or
enumeration types, and \tcode{sizeof} expressions. Floating
literals~(\ref{lex.fcon}) can appear only if they are cast to integral or
enumeration types. Only type conversions to integral or enumeration
types can be used. In particular, except in \tcode{sizeof} expressions,
functions, class objects, pointers, or references shall not be used, and
assignment, increment, decrement, function-call, or comma operators shall
not be used.

\pnum
Other expressions are considered \grammarterm{constant-expression}{s} only
for the purpose of non-local static object
initialization~(\ref{basic.start.init}). Such constant expressions shall
evaluate to one of the following:

\begin{itemize}
\item a null pointer value~(\ref{conv.ptr}),
\item a null member pointer value~(\ref{conv.mem}),
\item an arithmetic constant expression,
\item an address constant expression,
\item a reference constant expression,
\item an address constant expression for a complete object type, plus or
minus an integral constant expression, or
\item a pointer to member constant expression.
\end{itemize}

\pnum
An \term{arithmetic constant expression} shall satisfy the requirements
for an integral constant expression, except that

\begin{itemize}
\item floating literals need not be cast to integral or enumeration type, and
\item conversions to floating point types are permitted.
\end{itemize}

\pnum
An \term{address constant expression} is a pointer to an lvalue designating
an object of static storage duration, a string literal~(\ref{lex.string}),
or a function. The pointer shall be created explicitly, using the unary
\tcode{\&} operator, or implicitly using a non-type template parameter of
pointer type, or using an expression of array~(\ref{conv.array}) or
function~(\ref{conv.func}) type. The subscripting operator \tcode{[]} and
the class member access \tcode{.} and \tcode{->} operators, the \tcode{\&}
and \tcode{*} unary operators, and pointer casts (except
\tcode{dynamic_cast}{s},~\ref{expr.dynamic.cast}) can be used in the
creation of an address constant expression, but the value of an object
shall not be accessed by the use of these operators. If the subscripting
operator is used, one of its operands shall be an integral constant
expression. An expression that designates the address of a subobject of
a non-POD class object (clause~\ref{class}) is not an address constant
expression~(\ref{class.cdtor}). Function calls shall not be used in an
address constant expression, even if the function is \tcode{inline} and
has a reference return type.

\pnum
A \term{reference constant expression} is an lvalue designating an object
of static storage duration, a non-type template parameter of reference
type, or a function. The subscripting operator \tcode{[]}, the class
member access \tcode{.} and \tcode{->} operators, the \tcode{\&} and
\tcode{*} unary operators, and reference casts (except those invoking
user-defined conversion functions~(\ref{class.conv.fct}) and except
\tcode{dynamic_cast}{s}~(\ref{expr.dynamic.cast})) can be used in the
creation of a reference constant expression, but the value of an object
shall not be accessed by the use of these operators. If the subscripting
operator is used, one of its operands shall be an integral constant
expression. An lvalue expression that designates a member or base class of
a non-POD class object (clause~\ref{class}) is not a reference constant
expression~(\ref{class.cdtor}). Function calls shall not be used in a
reference constant expression, even if the function is \tcode{inline} and
has a reference return type.

\pnum
A \term{pointer to member constant expression} shall be created using the
unary \tcode{\&} operator applied to a \grammarterm{qualified-id}
operand~(\ref{expr.unary.op}), optionally preceded by a pointer to member
cast~(\ref{expr.static.cast}).%
\indextext{expression|)}
