\rSec0[lex]{Lexical conventions}

%gram: \rSec1[gram.lex]{Lexical conventions}
%gram:

\indextext{lexical conventions|see{conventions, lexical}}
\indextext{translation!separate|see{compilation, separate}}
\indextext{separate translation|see{compilation, separate}}
\indextext{separate compilation|see{compilation, separate}}
\indextext{phases of translation|see{translation, phases}}
\indextext{source file character|see{character, source file}}
\indextext{alternative token|see{token, alternative}}
\indextext{digraph|see{token, alternative}}
\indextext{integer literal|see{literal, integer}}
\indextext{character literal|see{literal, character}}
\indextext{floating literal|see{literal, floating}}
\indextext{floating-point literal|see{literal, floating}}
\indextext{string literal|see{literal, string}}
\indextext{boolean literal|see{literal, boolean}}
\indextext{file, source|see{source file}}

\pnum
\indextext{conventions!lexical|(}%
\indextext{compilation!separate|(}%
The text of the program is kept in units called
\indextext{source file}\term{source files} in this International
Standard. A source file together with all the headers~(\ref{lib.headers})
and source files included~(\ref{cpp.include}) via the preprocessing
directive \tcode{\#include}, less any source lines skipped by any of the
conditional inclusion~(\ref{cpp.cond}) preprocessing directives, is
called a \defn{translation unit}.
\enternote a \Cpp program need not all be translated at the same time.
\exitnote

\pnum
\enternote previously translated translation units and instantiation
units can be preserved individually or in libraries. The separate
translation units of a program communicate~(\ref{basic.link}) by (for
example) calls to functions whose identifiers have external linkage,
manipulation of objects whose identifiers have external linkage, or
manipulation of data files. Translation units can be separately
translated and then later linked to produce an executable
program~(\ref{basic.link}). \exitnote%
\indextext{compilation!separate|)}

\rSec1[lex.phases]{Phases of translation}%

\pnum
\indextext{translation!phases|(}
The precedence among the syntax rules of translation is specified by the
following phases.\footnote{Implementations must behave as if these separate phases
occur, although in practice different phases might be folded together.}

\begin{enumerate}
\indextext{source file}%
\indextext{character!source file}%
\indextext{character set!basic source}%
\item Physical source file characters are mapped, in an
\impldef{mapping physical source file characters to basic source character set} manner,
to the basic source character set (introducing new-line characters for end-of-line
indicators) if necessary.
\indextext{trigraph sequence}Trigraph sequences~(\ref{lex.trigraph}) are
replaced by corresponding single-character internal representations. Any
source file character not in the basic source character
set~(\ref{lex.charset}) is replaced by the
\indextext{universal character name}universal-character-name that
designates that character. (An implementation may use any internal
encoding, so long as an actual extended character encountered in the
source file, and the same extended character expressed in the source
file as a universal-character-name (i.e., using the \tcode{\textbackslash
uXXXX} notation), are handled equivalently.)

\indextext{line splicing}%
\item Each instance of a new-line character and an immediately preceding
backslash character is deleted, splicing
physical source lines to form logical source lines.
If, as a result, a character sequence that matches the
syntax of a universal-character-name is produced, the behavior is undefined.
If a source file that is not empty does not end in a new-line
character, or ends in a new-line character immediately preceded by a
backslash character, the behavior is undefined.

\item The source file is decomposed into preprocessing
tokens~(\ref{lex.pptoken}) and sequences of white-space characters
(including comments). A source file shall not end in a partial
preprocessing token or partial comment.\footnote{A partial preprocessing
token would arise from a source file
ending in the first portion of a multi-character token that requires a
terminating sequence of characters, such as a \grammarterm{header-name}
that is missing the closing \tcode{"}
or \tcode{>}. A partial comment
would arise from a source file ending with an unclosed \tcode{/*}
comment.}
Each comment is replaced by one space character. New-line characters are
retained. Whether each nonempty sequence of white-space characters other
than new-line is retained or replaced by one space character is
\impldef{retain or replace white-space characters other than new-line}.
The process of dividing a source file's
characters into preprocessing tokens is context-dependent.
\enterexample
see the handling of \tcode{<} within a \tcode{\#include} preprocessing
directive.
\exitexample

\item Preprocessing directives are executed, macro invocations are expanded.
If a character sequence that matches the syntax of a
universal-character-name is produced by token
concatenation~(\ref{cpp.concat}), the behavior is undefined. A
\tcode{\#include} preprocessing directive causes the named header or
source file to be processed from phase 1 through phase 4, recursively.

\item Each source character set member, escape sequence, or
universal-character-name in
character literals and string literals is converted to a
member of the execution character set~(\ref{lex.ccon}, \ref{lex.string}).

\item Adjacent ordinary string literal tokens are concatenated.
Adjacent wide string literal tokens are concatenated.

\item White-space characters separating tokens are no longer
significant. Each preprocessing token is converted into a
token.~(\ref{lex.token}). The resulting tokens are syntactically and
semantically analyzed and translated. \enternote Source files, translation
units and translated translation units need not necessarily be stored as
files, nor need there be any one-to-one correspondence between these
entities and any external representation. The description is conceptual
only, and does not specify any particular implementation. \exitnote

\item Translated translation units and instantiation units are combined
as follows: \enternote some or all of these may be supplied from a
library. \exitnote Each translated translation unit is examined to
produce a list of required instantiations. \enternote this may include
instantiations which have been explicitly
requested~(\ref{temp.explicit}). \exitnote The definitions of the
required templates are located. It is \impldef{whether source of translation units must
be available to locate template definitions} whether the
source of the translation units containing these definitions is required
to be available. \enternote an implementation could encode sufficient
information into the translated translation unit so as to ensure the
source is not required here. \exitnote All the required instantiations
are performed to produce
\defn{instantiation units}. \enternote these are similar
to translated translation units, but contain no references to
uninstantiated templates and no template definitions. \exitnote The
program is ill-formed if any instantiation fails.

\item All external object and function references are resolved. Library
components are linked to satisfy external references to functions and
objects not defined in the current translation. All such translator
output is collected into a program image which contains information
needed for execution in its execution environment.%
\indextext{translation!phases|)}
\end{enumerate}

\rSec1[lex.charset]{Character sets}

\pnum
\indextext{character set|(}%
\indextext{character set!basic source}%
The \term{basic source character set} consists of 96 characters: the space character,
the control characters representing horizontal tab, vertical tab, form feed, and
new-line, plus the following 91 graphical characters:\footnote{The glyphs for
the members of the basic source character set are intended to
identify characters from the subset of ISO/IEC 10646 which corresponds to the ASCII
character set. However, because the mapping from source file characters to the source
character set (described in translation phase 1) is specified as implementation-defined,
an implementation is required to document how the basic source characters are
represented in source files.}

\begin{codeblock}
a b c d e f g h i j k l m n o p q r s t u v w x y z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
0 1 2 3 4 5 6 7 8 9
_ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ~ ! = , @\textbackslash@ " '
\end{codeblock}

\pnum
The \grammarterm{universal-character-name} construct provides a way to name
other characters.

\begin{bnf}
\nontermdef{hex-quad}\br
    hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
\end{bnf}

\begin{bnf}
\nontermdef{universal-character-name}\br
    \terminal{\textbackslash u} hex-quad\br
    \terminal{\textbackslash U} hex-quad hex-quad
\end{bnf}

The character designated by the universal-character-name \tcode{\textbackslash
UNNNNNNNN} is that character whose character short name in ISO/IEC 10646 is
\tcode{NNNNNNNN}; the character designated by the universal-character-name
\tcode{\textbackslash uNNNN} is that character whose character short name in
ISO/IEC 10646 is \tcode{0000NNNN}. If the hexadecimal value for a
universal character name is less than 0x20 or in the range 0x7F-0x9F
(inclusive), or if the universal character name designates a character in the
basic source character set, then the program is ill-formed.

\pnum
The \term{basic execution character set} and the \term{basic
execution wide-character set} shall each contain all the members of the
basic source character set, plus control characters representing alert,
backspace, and carriage return, plus a \term{null character}
(respectively, \term{null wide character}), whose representation has
all zero bits. For each basic execution character set, the values of the
members shall be non-negative and distinct from one another. In both the
source and execution basic character sets, the value of each character
after \tcode{0} in the above list of decimal digits shall be one greater
than the value of the previous. The \term{execution character set}
and the \term{execution wide-character set} are supersets of the
basic execution character set and the basic execution wide-character
set, respectively. The values of the members of the execution character sets
are \impldef{execution character-set and execution wide-character set},
and any additional members are locale-specific.%
\indextext{character set|)}

\rSec1[lex.trigraph]{Trigraph sequences}

\pnum
\indextext{trigraph sequence|(}%
Before any other processing takes place, each occurrence of one of the
following sequences of three characters (``\term{trigraph
sequences}'') is replaced by the single character indicated in
Table~\ref{tab:trigraph.sequences}.

\begin{tokentable}{trigraph sequences}{tab:trigraph.sequences}{trigraph}{replacement}
\tcode{??=}        &   \tcode{\#}             &
\tcode{??(}        &   \tcode{[}              &
\tcode{??<}        &   \tcode{\{}             \\ \rowsep
\tcode{??/}        &   \tcode{\textbackslash} &
\tcode{??)}        &   \tcode{]}              &
\tcode{??>}        &   \tcode{\}}             \\ \rowsep
\tcode{??'}        &   \tcode{\^{}}           &
\tcode{??!}        &   \tcode{|}              &
\tcode{??-}        &   \tcode{$\sim$}         \\
\end{tokentable}

\pnum
\enterexample
\begin{codeblock}
??=define arraycheck(a,b) a??(b??) ??!??! b??(a??)
\end{codeblock}

becomes

\begin{codeblock}
#define arraycheck(a,b) a[b] || b[a]
\end{codeblock}
\exitexampleb

\pnum
No other trigraph sequence exists. Each \tcode{?} that does not begin
one of the trigraphs listed above is not changed.%
\indextext{trigraph sequence|)}

\rSec1[lex.pptoken]{Preprocessing tokens}

\begin{bnf}
\indextext{token!preprocessing|(}%
\nontermdef{preprocessing-token}\br
    header-name\br
    identifier\br
    pp-number\br
    character-literal\br
    string-literal\br
    preprocessing-op-or-punc\br
    \textnormal{each non-white-space character that cannot be one of the above}
\end{bnf}

\pnum
Each preprocessing token that is converted to a token~(\ref{lex.token})
shall have the lexical form of a keyword, an identifier, a literal, an
operator, or a punctuator.

\pnum
A preprocessing token is the minimal lexical element of the language in translation
phases 3 through 6. The categories of preprocessing token are: \term{header names},
\term{identifiers}, \term{preprocessing numbers}, \term{character literals},
\term{string literals}, \grammarterm{preprocessing-op-or-punc},
and single non-white-space characters that do not lexically
match the other preprocessing token categories. If a \tcode{'} or a \tcode{"} character
matches the last category, the behavior is undefined. Preprocessing tokens can be
separated by
\indextext{space!white}%
\term{white space};
\indextext{comment}%
this consists of comments~(\ref{lex.comment}), or \defn{white-space
characters} (space, horizontal tab, new-line, vertical tab, and
form-feed), or both. As described in clause~\ref{cpp}, in certain
circumstances during translation phase 4, white space (or the absence
thereof) serves as more than preprocessing token separation. White space
can appear within a preprocessing token only as part of a header name or
between the quotation characters in a character literal or string
literal.

\pnum
If the input stream has been parsed into preprocessing tokens up to a
given character, the next preprocessing token is the longest sequence of
characters that could constitute a preprocessing token, even if that
would cause further lexical analysis to fail.

\pnum
\enterexample The program fragment \tcode{1Ex} is parsed as a
preprocessing number token (one that is not a valid floating or integer
literal token), even though a parse as the pair of preprocessing tokens
\tcode{1} and \tcode{Ex} might produce a valid expression (for example,
if \tcode{Ex} were a macro defined as \tcode{+1}). Similarly, the
program fragment \tcode{1E1} is parsed as a preprocessing number (one
that is a valid floating literal token), whether or not \tcode{E} is a
macro name. \exitexample

\pnum
\enterexample The program fragment \tcode{x+++++y} is parsed as \tcode{x
++ ++ + y}, which, if \tcode{x} and \tcode{y} are of built-in types,
violates a constraint on increment operators, even though the parse
\tcode{x ++ + ++ y} might yield a correct expression. \exitexample%
\indextext{token!preprocessing|)}

\rSec1[lex.digraph]{Alternative tokens}

\pnum
\indextext{token!alternative|(}%
Alternative token representations are provided for some operators and
punctuators\footnote{\indextext{digraph}%
These include ``digraphs'' and additional reserved words. The term
``digraph'' (token consisting of two characters) is not perfectly
descriptive, since one of the alternative preprocessing-tokens is
\tcode{\%:\%:} and of course several primary tokens contain two
characters. Nonetheless, those alternative tokens that aren't lexical
keywords are colloquially known as ``digraphs''. }.

\pnum
In all respects of the language, each alternative token behaves the
same, respectively, as its primary token, except for its spelling\footnote{Thus the ``stringized'' values~(\ref{cpp.stringize}) of
\tcode{[} and \tcode{<:} will be different, maintaining the source
spelling, but the tokens can otherwise be freely interchanged. }.
The set of alternative tokens is defined in
Table~\ref{tab:alternative.tokens}.

\begin{tokentable}{alternative tokens}{tab:alternative.tokens}{alternative}{primary}
\tcode{<\%}             &   \tcode{\{}         &
\tcode{and}             &   \tcode{\&\&}       &
\tcode{and_eq}          &   \tcode{\&=}        \\ \rowsep
\tcode{\%>}             &   \tcode{\}}         &
\tcode{bitor}           &   \tcode{|}          &
\tcode{or_eq}           &   \tcode{|=}         \\ \rowsep
\tcode{<:}              &   \tcode{[}          &
\tcode{or}              &   \tcode{||}         &
\tcode{xor_eq}          &   \tcode{\^{}=}      \\ \rowsep
\tcode{:>}              &   \tcode{]}          &
\tcode{xor}             &   \tcode{\^{}}       &
\tcode{not}             &   \tcode{!}          \\ \rowsep
\tcode{\%:}             &   \tcode{\#}         &
\tcode{compl}           &   \tcode{$\sim$}     &
\tcode{not_eq}          &   \tcode{!=}         \\ \rowsep
\tcode{\%:\%:}          &   \tcode{\#\#}       &
\tcode{bitand}          &   \tcode{\&}         &
                        &                      \\
\end{tokentable}%
\indextext{token!alternative|)}

\rSec1[lex.token]{Tokens}

\indextext{token|(}%
\begin{bnf}
\nontermdef{token}\br
    identifier\br
    keyword\br
    literal\br
    operator\br
    punctuator
\end{bnf}

\pnum
\indextext{\idxgram{token}}%
There are five kinds of tokens: identifiers, keywords, literals,\footnote{Literals include strings and character and numeric literals.
}
operators, and other separators.
\indextext{white~space}%
Blanks, horizontal and vertical tabs, newlines, formfeeds, and comments
(collectively, ``white space''), as described below, are ignored except
as they serve to separate tokens. \enternote Some white space is
required to separate otherwise adjacent identifiers, keywords, numeric
literals, and alternative tokens containing alphabetic characters.
\exitnote%
\indextext{token|)}

\rSec1[lex.comment]{Comments}

\pnum
\indextext{comment|(}%
\indextext{comment!\tcode{/*}~\tcode{*/}}%
\indextext{comment!\tcode{//}}%
The characters \tcode{/*} start a comment, which terminates with the
characters \tcode{*/}. These comments do not nest.
\indextext{comment!\tcode{//}}%
The characters \tcode{//} start a comment, which terminates with the
next new-line character. If there is a form-feed or a vertical-tab
character in such a comment, only white-space characters shall appear
between it and the new-line that terminates the comment; no diagnostic
is required. \enternote The comment characters \tcode{//}, \tcode{/*},
and \tcode{*/} have no special meaning within a \tcode{//} comment and
are treated just like other characters. Similarly, the comment
characters \tcode{//} and \tcode{/*} have no special meaning within a
\tcode{/*} comment. \exitnote%
\indextext{comment|)}

\rSec1[lex.header]{Header names}

\indextext{header!name|(}%
\begin{bnf}
\nontermdef{header-name}\br
    \terminal{<} h-char-sequence \terminal{>}\br
    \terminal{"} q-char-sequence \terminal{"}
\end{bnf}

\begin{bnf}
\nontermdef{h-char-sequence}\br
    h-char\br
    h-char-sequence h-char
\end{bnf}

\begin{bnftab}
\nontermdef{h-char}\br
\>\textnormal{any member of the source character set except}\br
\>\>\textnormal{new-line and \terminal{>}}
\end{bnftab}

\begin{bnf}
\nontermdef{q-char-sequence}\br
    q-char\br
    q-char-sequence q-char
\end{bnf}

\begin{bnftab}
\nontermdef{q-char}\br
\>\textnormal{any member of the source character set except}\br
\>\>\textnormal{new-line and \terminal{"}}
\end{bnftab}

\pnum
Header name preprocessing tokens shall only appear within a
\tcode{\#include} preprocessing directive~(\ref{cpp.include}). The
sequences in both forms of \grammarterm{header-name}{s} are mapped in an
\impldef{mapping header name to header or external source file} manner to headers or to
external source file names as specified in~\ref{cpp.include}.

\pnum
If either of the characters \tcode{'} or \tcode{\textbackslash}, or
either of the character sequences \tcode{/*} or \tcode{//} appears in a
\grammarterm{q-char-sequence} or a \grammarterm{h-char-sequence}, or the
character \tcode{"} appears in a \grammarterm{h-char-sequence},
the behavior is undefined.\footnote{Thus, sequences of characters that
resemble escape sequences cause undefined behavior.}%
\indextext{header!name|)}

\rSec1[lex.ppnumber]{Preprocessing numbers}

\index{number!preprocessing|(}%
\begin{bnf}
\nontermdef{pp-number}\br
    digit\br
    \terminal{.} digit\br
    pp-number digit\br
    pp-number nondigit\br
    pp-number \terminal{e} sign\br
    pp-number \terminal{E} sign\br
    pp-number \terminal{.}
\end{bnf}

\pnum
Preprocessing number tokens lexically include all integral literal
tokens~(\ref{lex.icon}) and all floating literal
tokens~(\ref{lex.fcon}).

\pnum
A preprocessing number does not have a type or a value; it acquires both
after a successful conversion (as part of translation phase 7,~\ref{lex.phases})
to an integral literal token or a floating literal
token.%
\index{number!preprocessing|)}

\rSec1[lex.name]{Identifiers}

\indextext{identifier|(}%
\begin{bnf}
\nontermdef{identifier}\br
    nondigit\br
    identifier nondigit\br
    identifier digit
\end{bnf}

\begin{bnf}
\nontermdef{nondigit} \textnormal{one of}\br
    universal-character-name\br
    \terminal{_ a b c d e f g h i j k l m}\br
    \terminal{n o p q r s t u v w x y z}\br
    \terminal{A B C D E F G H I J K L M}\br
    \terminal{N O P Q R S T U V W X Y Z}
\end{bnf}

\begin{bnf}
\nontermdef{digit} \textnormal{one of}\br
    \terminal{0 1 2 3 4 5 6 7 8 9}
\end{bnf}

\pnum
\indextext{name!length~of}%
\indextext{name}%
An identifier is an arbitrarily long sequence of letters and digits.
Each universal-character-name in an identifier shall designate a
character whose encoding in ISO 10646 falls into one of the ranges
specified in Annex~\ref{extendid}. Upper- and lower-case letters are
different. All characters are
significant.\footnote{On systems in which linkers cannot accept extended
characters, an encoding of the universal-character-name may be used in
forming valid external identifiers. For example, some otherwise unused
character or sequence of characters may be used to encode the
\tcode{\textbackslash u} in a universal-character-name. Extended
characters may produce a long external identifier, but \Cpp does not
place a translation limit on significant characters for external
identifiers. In \Cpp, upper- and lower-case letters are considered
different for all identifiers, including external identifiers. }

\pnum
\indextext{\idxcode{_}|see{character, underscore}}%
\indextext{character!underscore!in identifier}%
\indextext{reserved~identifier}%
In addition, some identifiers are reserved for use by \Cpp
implementations and standard libraries~(\ref{lib.global.names}) and shall
not be used otherwise; no diagnostic is required.%
\indextext{identifier|)}

\rSec1[lex.key]{Keywords}

\enlargethispage{\baselineskip}%
\pnum
\indextext{keyword|(}%
The identifiers shown in Table~\ref{tab:keywords} are reserved for use
as keywords (that is, they are unconditionally treated as keywords in
phase 7):

\begin{floattable}{keywords}{tab:keywords}
{lllll}
\topline

\tcode{asm}               &
\tcode{do}                &
\tcode{if}                &
\tcode{return}            &
\tcode{typedef}           \\

\tcode{auto}              &
\tcode{double}            &
\tcode{inline}            &
\tcode{short}             &
\tcode{typeid}            \\

\tcode{bool}              &
\tcode{dynamic_cast}      &
\tcode{int}               &
\tcode{signed}            &
\tcode{typename}          \\

\tcode{break}             &
\tcode{else}              &
\tcode{long}              &
\tcode{sizeof}            &
\tcode{union}             \\

\tcode{case}              &
\tcode{enum}              &
\tcode{mutable}           &
\tcode{static}            &
\tcode{unsigned}          \\

\tcode{catch}             &
\tcode{explicit}          &
\tcode{namespace}         &
\tcode{static_cast}       &
\tcode{using}             \\

\tcode{char}              &
\tcode{export}            &
\tcode{new}               &
\tcode{struct}            &
\tcode{virtual}           \\

\tcode{class}             &
\tcode{extern}            &
\tcode{operator}          &
\tcode{switch}            &
\tcode{void}              \\

\tcode{const}             &
\tcode{false}             &
\tcode{private}           &
\tcode{template}          &
\tcode{volatile}          \\

\tcode{const_cast}        &
\tcode{float}             &
\tcode{protected}         &
\tcode{this}              &
\tcode{wchar_t}           \\

\tcode{continue}          &
\tcode{for}               &
\tcode{public}            &
\tcode{throw}             &
\tcode{while}             \\

\tcode{default}           &
\tcode{friend}            &
\tcode{register}          &
\tcode{true}              & \\

\tcode{delete}            &
\tcode{goto}              &
\tcode{reinterpret_cast}  &
\tcode{try}               & \\

\end{floattable}

\pnum
Furthermore, the alternative representations shown in
Table~\ref{tab:alternative.representations} for certain operators and
punctuators~(\ref{lex.digraph}) are reserved and shall not be used
otherwise:


\begin{floattable}{alternative representations}{tab:alternative.representations}
{llllll}
\topline
\tcode{and}     &   \tcode{and_eq}  &   \tcode{bitand}  &   \tcode{bitor}   &   \tcode{compl}   &   \tcode{not} \\
\tcode{not_eq}  &   \tcode{or}      &   \tcode{or_eq}   &   \tcode{xor}     &   \tcode{xor_eq}  &       \\
\end{floattable}%
\indextext{keyword|)}%


\rSec1[lex.operators]{Operators and punctuators}

\pnum
\indextext{operator|(}%
\indextext{punctuator|(}%
The lexical representation of \Cpp programs includes a number of
preprocessing tokens which are used in the syntax of the preprocessor or
are converted into tokens for operators and punctuators:

\begin{bnfkeywordtab}
\nontermdef{preprocessing-op-or-punc} \textnormal{one of}\br
\>\{ \>\} \>[ \>] \>\# \>\#\# \>( \>)\br
\><: \>:> \><\% \>\%> \>\%: \>\%:\%: \>; \>: \>.{..}\br
\>new \>delete \>? \>:: \>. \>.*\br
\>+ \>- \>* \>/ \>\% \>\^{} \>\& \>| \>\tilde\br
\>! \>= \>< \>> \>+= \>-= \>*= \>/= \>\%=\br
\>\^{}= \>\&= \>|= \>\shl \>\shr \>\shr= \>\shl= \>== \>!=\br
\><= \>>= \>\&\& \>|| \>++ \>-{-} \>, \>->* \>->\br
\>and \>and_eq \>bitand \>bitor \>compl \>not \>not_eq\br
\>or \>or_eq \>xor \>xor_eq
\end{bnfkeywordtab}

Each \grammarterm{preprocessing-op-or-punc} is converted to a single token
in translation phase 7~(\ref{lex.phases}).%
\indextext{punctuator|)}%
\indextext{operator|)}

\rSec1[lex.literal]{Literals}%
\indextext{literal|(}

\pnum
\indextext{constant}%
\indextext{literal!constant}%
There are several kinds of literals.\footnote{The term ``literal'' generally designates, in this
International Standard, those tokens that are called ``constants'' in
ISO C. }

\begin{bnf}
\nontermdef{literal}\br
    integer-literal\br
    character-literal\br
    floating-literal\br
    string-literal\br
    boolean-literal\br
\end{bnf}

\rSec2[lex.icon]{Integer literals}

\indextext{literal!integer}%
\begin{bnf}
\nontermdef{integer-literal}\br
    decimal-literal integer-suffix\opt\br
    octal-literal integer-suffix\opt\br
    hexadecimal-literal integer-suffix\opt
\end{bnf}

\begin{bnf}
\nontermdef{decimal-literal}\br
    nonzero-digit\br
    decimal-literal digit
\end{bnf}

\begin{bnf}
\nontermdef{octal-literal}\br
    \terminal{0}\br
    octal-literal octal-digit
\end{bnf}

\begin{bnf}
\nontermdef{hexadecimal-literal}\br
    \terminal{0x} hexadecimal-digit\br
    \terminal{0X} hexadecimal-digit\br
    hexadecimal-literal hexadecimal-digit
\end{bnf}

\begin{bnf}
\nontermdef{nonzero-digit} \textnormal{one of}\br
    \terminal{1  2  3  4  5  6  7  8  9}
\end{bnf}

\begin{bnf}
\nontermdef{octal-digit} \textnormal{one of}\br
    \terminal{0  1  2  3  4  5  6  7}
\end{bnf}

\begin{bnf}
\nontermdef{hexadecimal-digit} \textnormal{one of}\br
    \terminal{0  1  2  3  4  5  6  7  8  9}\br
    \terminal{a  b  c  d  e  f}\br
    \terminal{A  B  C  D  E  F}
\end{bnf}

\begin{bnf}
\nontermdef{integer-suffix}\br
    unsigned-suffix long-suffix\opt \br
    long-suffix unsigned-suffix\opt \br
\end{bnf}

\begin{bnf}
\nontermdef{unsigned-suffix} \textnormal{one of}\br
    \terminal{u  U}
\end{bnf}

\begin{bnf}
\nontermdef{long-suffix} \textnormal{one of}\br
    \terminal{l  L}
\end{bnf}

\pnum
\indextext{literal!\idxcode{unsigned}}%
\indextext{literal!\idxcode{long}}%
\indextext{literal!integer}%
\indextext{literal!hexadecimal}%
\indextext{literal!octal}%
\indextext{literal!decimal}%
\indextext{literal!base~of integer}%
An integer literal is a sequence of digits that has no period
or exponent part. An integer literal may have a prefix that specifies
its base and a suffix that specifies its type. The lexically first digit
of the sequence of digits is the most significant. A \term{decimal}
integer literal (base ten) begins with a digit other than \tcode{0} and
consists of a sequence of decimal digits. An \term{octal} integer
literal (base eight) begins with the digit \tcode{0} and consists of a
sequence of octal digits.\footnote{The digits \tcode{8} and \tcode{9} are not octal digits. }
A \term{hexadecimal} integer literal (base sixteen) begins with
\tcode{0x} or \tcode{0X} and consists of a sequence of hexadecimal
digits, which include the decimal digits and the letters \tcode{a}
through \tcode{f} and \tcode{A} through \tcode{F} with decimal values
ten through fifteen. \enterexample the number twelve can be written
\tcode{12}, \tcode{014}, or \tcode{0XC}. \exitexample

\pnum
\indextext{literal!\idxcode{long}}%
\indextext{literal!\idxcode{unsigned}}%
\indextext{suffix!\idxcode{L}}%
\indextext{suffix!\idxcode{U}}%
\indextext{suffix!\idxcode{l}}%
\indextext{suffix!\idxcode{u}}%
\indextext{literal!type~of integer}%
The type of an integer literal depends on its form, value, and suffix.
If it is decimal and has no suffix, it has the first of these types in which
its value can be represented: \tcode{int}, \tcode{long int}; if the value
cannot be represented as a \tcode{long int}, the behavior is undefined.
If it is octal or hexadecimal and has no suffix, it has the first of these
types in which its value can be represented: \tcode{int}, \tcode{unsigned int},
\tcode{long int}, \tcode{unsigned long int}. If it is suffixed by \tcode{u}
or \tcode{U}, its type is the first of these types in which its value can be
represented: \tcode{unsigned int}, \tcode{unsigned long int}. If it is suffixed
by \tcode{l} or \tcode{L}, its type is the first of these types in which its
value can be represented: \tcode{long int}, \tcode{unsigned long int}.
If it is suffixed by \tcode{ul}, \tcode{lu}, \tcode{uL}, \tcode{Lu}, \tcode{Ul},
\tcode{lU}, \tcode{UL}, or \tcode{LU}, its type is \tcode{unsigned long int}.

\pnum
A program is ill-formed if one of its translation units contains an
integer literal that cannot be represented by any of the allowed types.

\rSec2[lex.ccon]{Character literals}

\indextext{literal!character}%
\begin{bnf}
\nontermdef{character-literal}\br
    \terminal{'} c-char-sequence \terminal{'}\br
    L\terminal{'} c-char-sequence \terminal{'}
\end{bnf}

\begin{bnf}
\nontermdef{c-char-sequence}\br
    c-char\br
    c-char-sequence c-char
\end{bnf}

\begin{bnftab}
\nontermdef{c-char}\br
\>\textnormal{any member of the source character set except}\br
\>\>\textnormal{the single-quote \terminal{'}, backslash \terminal{\textbackslash}, or new-line character}\br
\>escape-sequence\br
\>universal-character-name
\end{bnftab}

\begin{bnf}
\nontermdef{escape-sequence}\br
    simple-escape-sequence\br
    octal-escape-sequence\br
    hexadecimal-escape-sequence
\end{bnf}

\begin{bnf}
\nontermdef{simple-escape-sequence} \textnormal{one of}\br
    \terminal{\textbackslash'}\quad\terminal{\textbackslash"}\quad\terminal{\textbackslash ?}\quad\terminal{\textbackslash\textbackslash}\br
    \terminal{\textbackslash a}\quad\terminal{\textbackslash b}\quad\terminal{\textbackslash f}\quad\terminal{\textbackslash n}\quad\terminal{\textbackslash r}\quad\terminal{\textbackslash t}\quad\terminal{\textbackslash v}
\end{bnf}

\begin{bnf}
\nontermdef{octal-escape-sequence}\br
    \terminal{\textbackslash} octal-digit\br
    \terminal{\textbackslash} octal-digit octal-digit\br
    \terminal{\textbackslash} octal-digit octal-digit octal-digit
\end{bnf}

\begin{bnf}
\nontermdef{hexadecimal-escape-sequence}\br
    \terminal{\textbackslash x} hexadecimal-digit\br
    hexadecimal-escape-sequence hexadecimal-digit
\end{bnf}

\pnum
\indextext{literal!character}%
\indextext{literal!narrow-character}%
A character literal is one or more characters enclosed in single quotes,
as in \tcode{'x'}, optionally preceded by the letter \tcode{L},
as in \tcode{L'x'}.
\indextext{literal!type~of character}%
A character literal that does not begin with
\tcode{L} is an ordinary character literal, also referred to as a
narrow-character literal. An ordinary character literal that contains a
single \grammarterm{c-char} has type \tcode{char}, with value equal to the
numerical value of the encoding of the \grammarterm{c-char} in the
execution character set. An ordinary character literal that contains
more than one \grammarterm{c-char} is a
\indextext{multicharacter literal|see{literal, multicharacter}}%
\defnx{multicharacter literal}{literal!multicharacter}.
A multicharacter literal has type \tcode{int}
\indextext{literal!multicharacter!implementation-defined value of}%
and \impldef{value of multicharacter literal} value.

\pnum
\indextext{wide-character}%
\indextext{\idxhdr{stddef.h}}%
\indextext{\idxcode{wchar_t}}%
A character literal that begins with the letter \tcode{L}, such as \tcode{L'x'},
\indextext{prefix!\idxcode{L}}%
is a wide-character literal. A wide-character literal has type
\tcode{wchar_t}.\footnote{They are intended for character sets where a character does
not fit into a single byte. }
The value of a wide-character literal containing a single
\grammarterm{c-char} has value equal to the numerical value of the encoding
of the \grammarterm{c-char} in the execution wide-character set. The value
of a wide-character literal containing multiple \grammarterm{c-char}{s} is
\impldef{value of wide-character literal containing multiple characters}.

\pnum
Certain nongraphic characters, the single quote \tcode{'}, the double quote \tcode{"},
the question mark \tcode{?}, and the backslash
\indextext{backslash~character}%
\indextext{\idxcode{\textbackslash}|see{backslash}}%
\indextext{escape~character|see{backslash}}%
\tcode{\textbackslash}, can be represented according to
Table~\ref{tab:escape.sequences}.
\indextext{escape~sequence!undefined}%
The double quote \tcode{"}  and the question mark \tcode{?}, can be
represented as themselves or by the escape sequences
\tcode{\textbackslash "} and \tcode{\textbackslash ?} respectively, but
the single quote \tcode{'} and the backslash \tcode{\textbackslash}
shall be represented by the escape sequences \tcode{\textbackslash'} and
\tcode{\textbackslash\textbackslash} respectively. If the character
following a backslash is not one of those specified, the behavior is undefined.
An escape sequence specifies a single character.

\begin{floattable}{escape sequences}{tab:escape.sequences}
{llm}
\topline
new-line        &   NL(LF)          &   \textbackslash n                \\
horizontal tab  &   HT              &   \textbackslash t                \\
vertical tab    &   VT              &   \textbackslash v                \\
backspace       &   BS              &   \textbackslash b                \\
carriage return &   CR              &   \textbackslash r                \\
form feed       &   FF              &   \textbackslash f                \\
alert           &   BEL             &   \textbackslash a                \\
backslash       &   \textbackslash  &   \textbackslash\textbackslash    \\
question mark   &   ?               &   \textbackslash ?                \\
single quote    &   \tcode{'}       &   \textbackslash\tcode{'}         \\
double quote    &   \tcode{"}       &   \textbackslash\tcode{"}         \\
octal number    &   \numconst{ooo}  &   \textbackslash\numconst{ooo}    \\
hex number      &   \numconst{hhh}  &   \textbackslash x\numconst{hhh}  \\
\end{floattable}

\pnum
The escape
\indextext{number!octal}%
\tcode{\textbackslash\numconst{ooo}} consists of the backslash followed by one,
two, or three octal digits that are taken to specify the value of the
desired character. The escape
\indextext{number!hex}%
\tcode{\textbackslash x\numconst{hhh}}
consists of the backslash followed by \tcode{x} followed by one or more
hexadecimal digits that are taken to specify the value of the desired
character. There is no limit to the number of digits in a hexadecimal
sequence. A sequence of octal or hexadecimal digits is terminated by the
first character that is not an octal digit or a hexadecimal digit,
respectively.
\indextext{literal!implementation-defined value~of \idxcode{char}}%
The value of a character literal is \impldef{value of character literal outside range of
corresponding type} if it falls outside of the implementation-defined range defined for
\tcode{char}
(for ordinary literals) or \tcode{wchar_t} (for wide literals).

\pnum
A universal-character-name is translated to the encoding, in the
execution character set, of the character named. If there is no such
encoding, the universal-character-name is translated to an
\impldef{encoding of universal character name not in execution character set} encoding.
\enternote in translation phase 1, a universal-character-name is introduced whenever an
actual extended
character is encountered in the source text. Therefore, all extended
characters are described in terms of universal-character-names. However,
the actual compiler implementation may use its own native character set,
so long as the same results are obtained. \exitnote

\rSec2[lex.fcon]{Floating literals}

\indextext{literal!floating}%
\begin{bnf}
\nontermdef{floating-literal}\br
    fractional-constant exponent-part\opt floating-suffix\opt\br
    digit-sequence exponent-part floating-suffix\opt
\end{bnf}

\begin{bnf}
\nontermdef{fractional-constant}\br
    digit-sequence\opt \terminal{.} digit-sequence\br
    digit-sequence \terminal{.}
\end{bnf}

\begin{bnf}
\nontermdef{exponent-part}\br
    \terminal{e} sign\opt digit-sequence\br
    \terminal{E} sign\opt digit-sequence
\end{bnf}

\begin{bnf}
\nontermdef{sign} \textnormal{one of}\br
    \terminal{+  -}
\end{bnf}

\begin{bnf}
\nontermdef{digit-sequence}\br
    digit\br
    digit-sequence digit
\end{bnf}

\begin{bnf}
\nontermdef{floating-suffix} \textnormal{one of}\br
    \terminal{f  l  F  L}
\end{bnf}

\pnum
\indextext{literal!floating}%
A floating literal consists of an integer part, a decimal point, a
fraction part, an
\indextext{suffix!\idxcode{e}}%
\indextext{suffix!\idxcode{E}}%
\tcode{e} or \tcode{E}, an optionally signed integer exponent, and an
optional type suffix. The integer and fraction parts both consist of a
sequence of decimal (base ten) digits. Either the integer part or the
fraction part (not both) can be omitted; either the decimal point or the
letter \tcode{e} (or \tcode{E} ) and the exponent (not both) can be
omitted. The integer part, the optional decimal point and the optional
fraction part form the \term{significant part} of the
floating literal. The exponent, if present, indicates the power of 10 by
which the significant part is to be scaled. If the scaled value is in
the range of representable values for its type, the result is the scaled
value if representable, else the larger or smaller representable value
nearest the scaled value, chosen in an \impldef{choice of larger or smaller value of
floating literal} manner.
\indextext{literal!\idxcode{double}}%
The type of a floating literal is \tcode{double}
\indextext{literal!type~of floating~point}%
unless explicitly specified by a suffix.
\indextext{literal!\idxcode{float}}%
\indextext{suffix!\idxcode{F}}%
\indextext{suffix!\idxcode{f}}%
The suffixes \tcode{f} and \tcode{F} specify \tcode{float},
\indextext{suffix!\idxcode{L}}%
\indextext{suffix!\idxcode{l}}%
\indextext{literal!\idxcode{long double}}%
the suffixes \tcode{l} and \tcode{L} specify \tcode{long}
\tcode{double}. If the scaled value is not in the range of representable
values for its type, the program is ill-formed.

\rSec2[lex.string]{String literals}

\indextext{literal!string}%
\begin{bnf}
\nontermdef{string-literal}\br
    \terminal{"} s-char-sequence\opt \terminal{"}\br
    \terminal{L"} s-char-sequence\opt \terminal{"}\br
\end{bnf}

\begin{bnf}
\nontermdef{s-char-sequence}\br
    s-char\br
    s-char-sequence s-char
\end{bnf}

\begin{bnftab}
\nontermdef{s-char}\br
\>\textnormal{any member of the source character set except}\br
\>\>\textnormal{the double-quote \terminal{"}, backslash \terminal{\textbackslash}, or new-line character}\br
\>escape-sequence\br
\>universal-character-name
\end{bnftab}

\pnum
\indextext{literal!string}%
\indextext{literal!string!narrow}%
\indextext{literal!string!wide}%
\indextext{character~string}%
A string literal is a sequence of characters (as defined
in~\ref{lex.ccon}) surrounded by double quotes, optionally beginning with
the letter \tcode{L}, as in \tcode{"..."} or \tcode{L"..."}.
\indextext{string!type~of}%
\indextext{literal!string!narrow}%
A string literal that does not begin with \tcode{L} is an ordinary
string literal, also referred to as a narrow
string literal. An ordinary string literal has type
\indextext{literal!string!type~of}%
``array of \term{n} \tcode{const char}'' and \term{static} storage
duration~(\ref{basic.stc}), where \term{n} is the size of
the string as defined below, and is initialized with the given characters.
\indextext{literal!string!wide}%
A string literal that begins with
\tcode{L},
such as \tcode{L"asdf"},
is a wide string literal.
\indextext{\idxhdr{stddef.h}}%
\indextext{\idxcode{wchar_t}}%
\indextext{literal!string!wide}%
\indextext{prefix!\idxcode{L}}%
A wide string literal has type ``array of \term{n} \tcode{const
wchar_t}'' and has static storage duration,
where \term{n} is the size of the string as defined below,
and is initialized with the given characters.

\pnum
\indextext{literal!string!implementation-defined}%
\indextext{string!distinct}%
Whether all string literals are distinct (that is, are stored in
nonoverlapping objects) is \impldef{distinctness of string literals}.
\indextext{literal!string!undefined change~to}%
The effect of attempting to modify a string literal is undefined.

\pnum
\indextext{concatenation!string}%
In translation phase 6~(\ref{lex.phases}), adjacent narrow string literals are
concatenated and adjacent wide string literals are concatenated. If a narrow
string literal token is adjacent to a wide string literal token, the behavior
is undefined.
Characters in concatenated strings are kept distinct.
\enterexample
\begin{codeblock}
"\xA" "B"
\end{codeblock}

contains the two characters \tcode{'\textbackslash xA'} and \tcode{'B'}
after concatenation (and not the single hexadecimal character
\tcode{'\textbackslash xAB'}).
\exitexample

\pnum
\indextext{\idxcode{0}|seealso{zero,~null}}%
\indextext{\idxcode{0}!string terminator}%
\indextext{\idxcode{0}!null~character}%
After any necessary concatenation, in translation phase
7~(\ref{lex.phases}), \tcode{'\textbackslash 0'} is appended to every
string literal so that programs that scan a string can find its end.

\pnum
\indextext{encoding!multibyte}%
Escape sequences and universal-character-names in string literals
have the same meaning as in character literals~(\ref{lex.ccon}), except that
the single quote \tcode{'} is representable either by itself or by the escape sequence
\tcode{\textbackslash'}, and the double quote \tcode{"} shall be preceded by a
\tcode{\textbackslash}.
\indextext{string!\idxcode{sizeof}}%
In a narrow string literal, a universal-character-name may map to more
than one \tcode{char} element due to \term{multibyte encoding}. The
size of a wide string literal is the total number of
escape sequences, universal-character-names, and other characters, plus
one for the terminating \tcode{L'\textbackslash 0'}.
The size of a narrow string literal is
the total number of escape sequences and other characters, plus at least
one for the multibyte encoding of each universal-character-name, plus
one for the terminating \tcode{'\textbackslash 0'}.

\rSec2[lex.bool]{Boolean literals}

\indextext{literal!boolean}%
\begin{bnf}
\nontermdef{boolean-literal}\br
    \terminal{false}\br
    \terminal{true}
\end{bnf}

\pnum
\indextext{Boolean literal}%
The Boolean literals are the keywords \tcode{false} and \tcode{true}.
Such literals have type \tcode{bool}. They are not lvalues.
\indextext{literal|)}%
\indextext{conventions!lexical|)}
