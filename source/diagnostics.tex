\rSec0[lib.diagnostics]{Diagnostics library}

\pnum
This clause describes components that \Cpp programs may use to detect and
report error conditions.

\pnum
The following subclauses describe components for
reporting several kinds of exceptional conditions,
documenting program assertions, and
a global variable for error number codes,
as summarized in Table~\ref{tab:diagnostics.lib.summary}.

\begin{libsumtab}{Diagnostics library summary}{tab:diagnostics.lib.summary}
\ref{lib.std.exceptions}  & Exception classes     &   \tcode{<stdexcept>}     \\ \rowsep
\ref{lib.assertions}      & Assertions            &   \tcode{<cassert>}       \\ \rowsep
\ref{lib.errno}           & Error numbers         &   \tcode{<cerrno>}        \\ \rowsep
\end{libsumtab}

\rSec1[lib.std.exceptions]{Exception classes}

\pnum
The Standard \Cpp library provides classes to be used to report certain errors~(\ref{lib.res.on.exception.handling}) in
\Cpp programs.
In the error model reflected in these classes, errors are divided into two
broad categories:
\term{logic}
errors and
\term{runtime}
errors.

\pnum
The distinguishing characteristic of logic errors is that they are due to errors
in the internal logic of the program.
In theory, they are preventable.

\pnum
By contrast, runtime errors are due to events beyond the scope of the program.
They cannot be easily predicted in advance.
The header
\tcode{<stdexcept>}
\indextext{\idxhdr{stdexcept}}%
\indexlibrary{\idxhdr{stdexcept}}%
defines several types of predefined exceptions for reporting errors in a \Cpp program.
These exceptions are related by inheritance.

\synopsis{Header \tcode{<stdexcept>} synopsis}

\indexlibrary{\idxhdr{stdexcept}}%
\indexlibrary{\idxcode{logic_error}}%
\indexlibrary{\idxcode{domain_error}}%
\indexlibrary{\idxcode{invalid_argument}}%
\indexlibrary{\idxcode{length_error}}%
\indexlibrary{\idxcode{out_of_range}}%
\indexlibrary{\idxcode{runtime_error}}%
\indexlibrary{\idxcode{range_error}}%
\indexlibrary{\idxcode{overflow_error}}%
\indexlibrary{\idxcode{underflow_error}}%
\begin{codeblock}
namespace std {
  class logic_error;
    class domain_error;
    class invalid_argument;
    class length_error;
    class out_of_range;
  class runtime_error;
    class range_error;
    class overflow_error;
    class underflow_error;
}
\end{codeblock}

\rSec2[lib.logic.error]{Class \tcode{logic_error}}

\indexlibrary{\idxcode{logic_error}}%
\begin{codeblock}
namespace std {
  class logic_error : public exception {
  public:
    explicit logic_error(const string& what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{logic_error}
defines the type of objects thrown as
exceptions to report errors presumably detectable before
the program executes, such as violations of logical preconditions or class
invariants.

\indexlibrary{\idxcode{logic_error}!\tcode{logic_error}}%
\begin{itemdecl}
logic_error(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{logic_error}.

\pnum
\postcondition
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\rSec2[lib.domain.error]{Class \tcode{domain_error}}

\indexlibrary{\idxcode{domain_error}}%
\begin{codeblock}
namespace std {
  class domain_error : public logic_error {
  public:
    explicit domain_error(const string& what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{domain_error}
defines the type of objects thrown as
exceptions by the implementation to report domain errors.

\indexlibrary{\idxcode{domain_error}!\tcode{domain_error}}%
\begin{itemdecl}
domain_error(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{domain_error}.

\pnum
\postcondition
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\rSec2[lib.invalid.argument]{Class \tcode{invalid_argument}}

\indexlibrary{\idxcode{invalid_argument}}%
\begin{codeblock}
namespace std {
  class invalid_argument : public logic_error {
  public:
    explicit invalid_argument(const string& what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{invalid_argument}
defines the type of objects thrown as exceptions to report an invalid argument.

\indexlibrary{\idxcode{invalid_argument}!\tcode{invalid_argument}}%
\begin{itemdecl}
invalid_argument(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{invalid_argument}.

\pnum
\postcondition
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\rSec2[lib.length.error]{Class \tcode{length_error}}

\indexlibrary{\idxcode{length_error}}%
\begin{codeblock}
namespace std {
  class length_error : public logic_error {
  public:
    explicit length_error(const string& what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{length_error}
defines the type of objects thrown as exceptions
to report an attempt to produce
an object whose length exceeds its maximum allowable size.

\indexlibrary{\idxcode{length_error}!\tcode{length_error}}%
\begin{itemdecl}
length_error(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{length_error}.

\pnum
\postcondition
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\rSec2[lib.out.of.range]{Class \tcode{out_of_range}}

\indexlibrary{\idxcode{out_of_range}}%
\begin{codeblock}
namespace std {
  class out_of_range : public logic_error {
  public:
    explicit out_of_range(const string& what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{out_of_range}
defines the type of objects thrown as exceptions to report an
argument value not in its expected range.
\indextext{argument}

\indexlibrary{\idxcode{out_of_range}!\tcode{out_of_range}}%
\begin{itemdecl}
out_of_range(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{out_of_range}.

\pnum
\postcondition
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\rSec2[lib.runtime.error]{Class \tcode{runtime_error}}

\indexlibrary{\idxcode{runtime_error}}%
\begin{codeblock}
namespace std {
  class runtime_error : public exception {
  public:
    explicit runtime_error(const string& what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{runtime_error}
defines the type of objects thrown as exceptions to report errors presumably detectable only
when the program executes.

\indexlibrary{\idxcode{runtime_error}!\tcode{runtime_error}}%
\begin{itemdecl}
runtime_error(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{runtime_error}.

\pnum
\postcondition
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\rSec2[lib.range.error]{Class \tcode{range_error}}

\indexlibrary{\idxcode{range_error}}%
\begin{codeblock}
namespace std {
  class range_error : public runtime_error {
  public:
    explicit range_error(const string& what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{range_error}
defines the type of objects thrown as exceptions to report range errors
in internal computations.

\indexlibrary{\idxcode{range_error}!\tcode{range_error}}%
\begin{itemdecl}
range_error(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{range_error}.

\pnum
\postcondition
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\rSec2[lib.overflow.error]{Class \tcode{overflow_error}}

\indexlibrary{\idxcode{overflow_error}}%
\begin{codeblock}
namespace std {
  class overflow_error : public runtime_error {
  public:
    explicit overflow_error(const string& what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{overflow_error}
defines the type of objects thrown as exceptions to report an arithmetic overflow error.

\indexlibrary{\idxcode{overflow_error}!\tcode{overflow_error}}%
\begin{itemdecl}
overflow_error(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{overflow_error}.

\pnum
\postcondition
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\rSec2[lib.underflow.error]{Class \tcode{underflow_error}}

\indexlibrary{\idxcode{overflow_error}}%
\begin{codeblock}
namespace std {
  class underflow_error : public runtime_error {
  public:
    explicit underflow_error(const string& what_arg);
  };
}
\end{codeblock}

\pnum
The class
\tcode{underflow_error}
defines the type of objects thrown as exceptions to report an arithmetic underflow error.

\indexlibrary{\idxcode{underflow_error}!\tcode{underflow_error}}%
\begin{itemdecl}
underflow_error(const string& what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{underflow_error}.

\pnum
\postcondition
\tcode{strcmp(what(), what_arg.c_str()) == 0}.
\end{itemdescr}

\rSec1[lib.assertions]{Assertions}

\pnum
Provides macros for documenting \Cpp program assertions, and
for disabling the assertion checks.

\pnum
Header
\tcode{<cassert>} (Table~\ref{tab:diagnostics.hdr.cassert}):

\begin{libsyntab2}{cassert}{tab:diagnostics.hdr.cassert}
\macro  &   \tcode{assert}  \\
\end{libsyntab2}

\pnum
The contents are the same as the Standard C library header
\tcode{<assert.h>}.

\xref
ISO C subclause~7.2.

\rSec1[lib.errno]{Error numbers}

\pnum
Header \tcode{<cerrno>} (Table~\ref{tab:diagnostics.hdr.cerrno}):

\begin{libsyntab4}{cerrno}{tab:diagnostics.hdr.cerrno}

\macros &
\tcode{EDOM} &
\tcode{ERANGE} &
\tcode{errno} \\

\end{libsyntab4}

\pnum
The contents are the same as the Standard C library header \tcode{<errno.h>}.

\xref ISO C subclause 7.1.4, 7.2, Amendment 1 subclause 4.3.
