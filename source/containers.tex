\rSec0[lib.containers]{Containers library}

\pnum
This clause describes components that \Cpp programs may use to
organize collections of information.

\pnum
The following subclauses describe container requirements, and components for
sequences and associative containers, as summarized in
Table~\ref{tab:containers.lib.summary}.

\begin{libsumtab}{Containers library summary}{tab:containers.lib.summary}
\ref{lib.container.requirements} & Requirements                 &                           \\ \rowsep
\ref{lib.sequences}          & Sequences                        & \tcode{<deque>}         \\
                             &                                  & \tcode{<list>}          \\
                             &                                  & \tcode{<queue>}          \\
                             &                                  & \tcode{<stack>}          \\
                             &                                  & \tcode{<vector>}        \\ \rowsep
\ref{lib.associative}        & Associative containers           & \tcode{<map>}           \\
                             &                                  & \tcode{<set>}           \\
\ref{lib.template.bitset}    & \tcode{bitset}                   & \tcode{<bitset>}         \\ \rowsep
\end{libsumtab}

\rSec1[lib.container.requirements]{Container requirements}%
\indextext{requirements!container}

\pnum
Containers are objects that store other objects.
They control allocation and deallocation of these objects
through constructors, destructors, insert and erase operations.

\pnum
All of the complexity requirements in this clause are stated solely
in terms of the number of operations on the contained objects.
\enterexample
the copy constructor of type
\tcode{vector <vector<int> >}
has linear complexity,
even though the complexity of copying each contained
\tcode{vector<int>}
is itself linear.
\exitexample

\pnum
The type of objects stored in these components must meet the requirements
of \tcode{CopyConstructible} types (\ref{lib.copyconstructible}), and the
additional requirements of \tcode{Assignable} types.

\pnum
In Table~\ref{assignable}, \tcode{T} is the type used to instantiate the
container, \tcode{t} is a value of \tcode{T}, and \tcode{u} is a value of
(possibly \tcode{const}) \tcode{T}.

\indextext{requirements!\idxcode{Assignable}}%
\begin{concepttable}{\tcode{Assignable} requirements}{assignable}
{x{1in}x{1in}p{3in}}
\topline
expression          &   return type     & post-condition  \\ \capsep
\tcode{t = u}       &  \tcode{T\&}      & \tcode{t} is equivalent to \tcode{u} \\
\end{concepttable}

\pnum
In Tables~\ref{tab:containers.container.requirements} and
\ref{tab:containers.reversible.requirements}, \tcode{X}
denotes a container class containing objects of type
\tcode{T}, \tcode{a} and \tcode{b}
denote values of type \tcode{X}, \tcode{u}
denotes an identifier and \tcode{r} denotes
a value of \tcode{X\&}.

\begin{libreqtab5}
{Container requirements}
{tab:containers.container.requirements}
\\ \topline
\lhdr{expression}       &   \chdr{return type}  & \chdr{operational semantics} &
\chdr{assertion/note}   &   \rhdr{complexity}   \\
    &   &   &   \chdr{pre/post-condition}   &      \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{expression}       &   \chdr{return type}  & \chdr{operational semantics} &
\chdr{assertion/note}   &   \rhdr{complexity}   \\
    &   &   &   \chdr{pre/post-condition}   &      \\ \capsep
\endhead

\tcode{X::value_type}       &
 \tcode{T}                  & &
 \tcode{T} is \tcode{Assignable} &
 compile time               \\ \rowsep

\tcode{X::reference}        &
 lvalue of \tcode{T}        & &
                            &
 compile time               \\ \rowsep

\tcode{X::const_reference} &
 const lvalue of \tcode{T}  & &
                            &
 compile time               \\ \rowsep

\tcode{X::iterator}         &
 iterator type pointing to \tcode{T} & &
 any iterator category except output iterator.\br
 convertible to \tcode{X::const_iterator}. &
 compile time               \\ \rowsep

\tcode{X::const_iterator}  &
 iterator type pointing to \tcode{const T} & &
 any iterator category except output iterator. &
 compile time               \\ \rowsep

\tcode{X::dif\-ference_type}    &
 signed integer type           & &
 is identical to the difference type of \tcode{X::iterator} and \tcode{X::const_iterator} &
 compile time               \\ \rowsep

\tcode{X::size_type}        &
 unsigned integer type     & &
 \tcode{size_type} can represent any non-negative value of \tcode{difference_type} &
 compile time                \\ \rowsep

\tcode{X u;}                &
                            & &
 post: \tcode{u.size() == 0}.    &
 constant                   \\ \rowsep

\tcode{X();}                &
                            & &
 \tcode{X().size() == 0}.   &
 constant                   \\ \rowsep

\tcode{X(a)}                &
                            & &
 \tcode{a == X(a)}.         &
 linear                     \\ \rowsep

\tcode{X u(a);}\br
\tcode{X u = a;}            &
                            & &
 post: \tcode{u == a}.\br
 Equivalent to: \tcode{X u; u = a;} &
 linear                     \\ \rowsep

\tcode{(\&a)->$\sim$X();}   &
 \tcode{void}               & &
 note: the destructor is applied to every element of \tcode{a}; all the memory is deallocated. &
 linear                     \\ \rowsep

\tcode{a.begin()}           &
 \tcode{iterator}; \tcode{const_iterator} for constant \tcode{a} & &
                            &
 constant                   \\ \rowsep

\tcode{a.end()}             &
 \tcode{iterator}; \tcode{const_iterator} for constant \tcode{a} & &
                            &
 constant                   \\ \rowsep

\tcode{a == b}                  &
 convertible to \tcode{bool}    & &
 \tcode{==} is an equivalence relation.

 \tcode{a.size()==b.size()}
 \tcode{\&\& equal(a.begin(),}
 \tcode{a.end(), b.begin())}    &
 linear                         \\ \rowsep

\tcode{a != b}                      &
 convertible to \tcode{bool}        & &
 Equivalent to: \tcode{!(a == b)}   &
 linear                             \\ \rowsep

\tcode{a.swap(b)}           &
 \tcode{void}               & &
 \tcode{swap(a,b)}          &
 (Note A)                   \\ \rowsep

\tcode{r = a}               &
 \tcode{X\&}                &
                            &
 post: \tcode{r == a}.      &
 linear                     \\ \rowsep

\tcode{a.size()}                &
 \tcode{size_type}              &
 \tcode{a.end()-a.begin()}      &
                                &
 (Note A)                       \\ \rowsep

\tcode{a.max_size()}        &
 \tcode{size_type}         &
 \tcode{size()}
 of the largest possible container. &
                            &
 (Note A)                   \\ \rowsep

\tcode{a.empty()}               &
 convertible to \tcode{bool}    &
 \tcode{a.size() == 0}          &
                                &
 constant                       \\ \rowsep

\tcode{a < b}                   &
 convertible to \tcode{bool}    &
 \tcode{lexicographical_compare}
 \tcode{(a.begin(),}
 \tcode{a.end(),}
 \tcode{b.begin(),}
 \tcode{b.end())}               &
 pre: \tcode{<} is defined for values of \tcode{T}.
      \tcode{<} is a total ordering relation. &
 linear                         \\ \rowsep

\tcode{a > b}                   &
 convertible to \tcode{bool}    &
 \tcode{b < a}                  &
                                &
 linear                         \\ \rowsep

\tcode{a <= b}                  &
 convertible to \tcode{bool}    &
 \tcode{!(a > b)}               &
                                &
 linear                         \\ \rowsep

\tcode{a >= b}                  &
 convertible to \tcode{bool}    &
 \tcode{!(a < b)}               &
                                &
 linear                         \\

\end{libreqtab5}

Notes: the algorithms
\tcode{swap()},
\tcode{equal()}
and
\tcode{lexicographical_compare()}
are defined in clause~\ref{lib.algorithms}.
Those entries marked ``(Note A)'' should have constant complexity.

\pnum
The member function \tcode{size()} returns the number of elements in the container.
This semantics is defined by the rules of
constructors, inserts, and erases.

\pnum
\tcode{begin()}
returns an iterator referring to the first element in the container.
\tcode{end()}
returns an iterator which is the past-the-end value for the container.
If the container is empty, then
\tcode{begin() == end()};

\pnum
Copy constructors for all container types defined in this clause copy an
allocator argument from their respective first parameters.
All other constructors for these container types take an \tcode{Allocator\&}
argument~(\ref{lib.allocator.requirements}), an allocator whose value type is the
same as the container's value type.
A copy of this argument is used for any memory allocation performed, by these
constructors and by all member functions, during the lifetime of each container object.
In all container types defined in this clause, the member \tcode{get_allocator()}
returns a copy of the Allocator object used to construct the container.

\pnum
If the iterator type of a container belongs to the bidirectional or
random access iterator categories~(\ref{lib.iterator.requirements}),
the container is called
\term{reversible}
and satisfies the additional requirements
in Table~\ref{tab:containers.reversible.requirements}.

\begin{libreqtab4a}
{Reversible container requirements}
{tab:containers.reversible.requirements}
\\ \topline
\lhdr{expression}       &   \chdr{return type}  &
\chdr{assertion/note}   &   \rhdr{complexity}   \\
    &   &   \chdr{pre/post-condition}   &      \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{expression}       &   \chdr{return type}  &
\chdr{assertion/note}   &   \rhdr{complexity}   \\
    &   &   \chdr{pre/post-condition}   &      \\ \capsep
\endhead
\tcode{X::reverse_iterator}            &
iterator type pointing to \tcode{T}    &
 \tcode{reverse_iterator <iterator>}   &
 compile time                           \\ \rowsep
\tcode{X::const_reverse_iterator}         &
 iterator type pointing to \tcode{const T}  &
 \tcode{reverse_iterator <const_iterator>}    &
 compile time                               \\ \rowsep
\tcode{a.rbegin()}                  &
 \tcode{reverse_iterator};
 \tcode{const_reverse_iterator} for constant \tcode{a} &
 \tcode{reverse_iterator(end())}   &
 constant                           \\ \rowsep
\tcode{a.rend()}                     &
 \tcode{reverse_iterator};
 \tcode{const_reverse_iterator} for constant \tcode{a} &
 \tcode{reverse_iterator(begin())}    &
 constant                           \\
\end{libreqtab4a}

\pnum
Unless otherwise specified (see~\ref{lib.deque.modifiers}, and
\ref{lib.vector.modifiers})
all container types defined in this clause meet
the following additional requirements:

\begin{itemize}
\item
if an exception is thrown by an
\tcode{insert()}
function while inserting a single element, that
function has no effects.
\item
if an exception is thrown by a
\tcode{push_back()}
or
\tcode{push_front()}
function, that function has no effects.
\item
no
\tcode{erase()},
\tcode{pop_back()}
or
\tcode{pop_front()}
function throws an exception.
\item
no copy constructor or assignment operator of a returned iterator
throws an exception.
\item
no
\tcode{swap()}
function throws an exception unless that exception is thrown by the copy
constructor or assignment operator of the container's Compare object
(if any; see~\ref{lib.associative.reqmts}).
\item
no
\tcode{swap()}
function invalidates any references,
pointers, or iterators referring to the elements
of the containers being swapped.
\end{itemize}

\pnum
Unless otherwise specified (either explicitly or by defining a
function in terms of other functions), invoking a container member
function or passing a container as an argument to a library function
shall not invalidate iterators to, or change the values of, objects
within that container.

\rSec2[lib.sequence.reqmts]{Sequences}

\pnum
A sequence is a kind of container that organizes a finite set of objects, all of the same type, into a strictly
linear arrangement. The library provides three basic kinds of sequence containers:
\tcode{vector}, \tcode{list}, and \tcode{deque}. It also provides container adaptors that
make it easy to construct abstract data types, such as \tcode{stack}s or \tcode{queue}s, out of
the basic sequence kinds (or out of other kinds of sequences that the user
might define).

\pnum
\tcode{vector}, \tcode{list}, and \tcode{deque}
offer the programmer different complexity trade-offs and should be used
accordingly.
\tcode{vector}
is the type of sequence that should be used by default.
\tcode{list}
should be used when there are frequent insertions and deletions from the
middle of the sequence.
\tcode{deque}
is the data structure of choice
when most insertions and deletions take place at the beginning or at the
end of the sequence.

\pnum
In Tables~\ref{tab:containers.sequence.requirements}
and \ref{tab:containers.sequence.optional}, \tcode{X}
denotes a sequence class,
\tcode{a} denotes a value of \tcode{X},
\tcode{i} and \tcode{j}
denote iterators satisfying input iterator requirements,
\tcode{[i, j)}
denotes a valid range,
\tcode{n}
denotes a value of \tcode{X::size_type},
\tcode{p} denotes a valid iterator to
\tcode{a}, \tcode{q}
denotes a valid dereferenceable iterator to
\tcode{a}, \tcode{[q1, q2)}
denotes a valid range in
\tcode{a}, and \tcode{t}
denotes a value of
\tcode{X::value_type}.

\pnum
The complexities of the expressions are sequence dependent.

\begin{libreqtab3}
{Sequence requirements (in addition to container)}
{tab:containers.sequence.requirements}
\\ \topline
\lhdr{expression}       &   \chdr{return type}  &   \rhdr{assertion/note}       \\
                        &                       &   \rhdr{pre/post-condition}   \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{expression}       &   \chdr{return type}  &   \rhdr{assertion/note}       \\
                        &                       &   \rhdr{pre/post-condition}   \\ \capsep
\endhead
\tcode{X(n, t)}\br
\tcode{X a(n, t);}   &
                &
 post: \tcode{size() == n}.\br
 constructs a sequence with \tcode{n} copies of \tcode{t}.  \\ \rowsep

\tcode{X(i, j)}\br
\tcode{X a(i, j);}   &
                    &
 post: \tcode{size() ==}
 \tcode{distance} between \tcode{i} and \tcode{j}.\br
 constructs a sequence equal to the range \tcode{[i,j)}.    \\ \rowsep

\tcode{a.insert(p,t)}   &
 \tcode{iterator}       &
 inserts a copy of \tcode{t} before \tcode{p}. \\ \rowsep

\tcode{a.insert(p,n,t)}     &
 \tcode{void}               &
 inserts \tcode{n} copies of \tcode{t} before \tcode{p}. \\ \rowsep

\tcode{a.insert(p,i,j)}     &
 \tcode{void}               &
 pre: \tcode{i},\tcode{j} are not iterators into \tcode{a}.\br
 inserts copies of elements in \tcode{[i,j)} before \tcode{p}.  \\ \rowsep

\tcode{a.erase(q)}  &
 \tcode{iterator}   &
 erases the element pointed to by \tcode{q}. \\ \rowsep

\tcode{a.erase(q1,q2)}  &
 \tcode{iterator}   &
 erases the elements in the range \tcode{[q1,q2)}.  \\ \rowsep

\tcode{a.clear()}   &
 \tcode{void}       &
 \tcode{eraise(begin(), end())}\br
 post: \tcode{a.size() == 0}.      \\

\end{libreqtab3}

\pnum
\tcode{iterator}
and
\tcode{const_iterator}
types for sequences must be at least of the forward iterator category.

\pnum
The iterator returned from
\tcode{a.insert(p,t)}
points to the copy of
\tcode{t}
inserted into
\tcode{a}.

\pnum
The iterator returned from
\tcode{a.erase(q)}
points to the element immediately following
\tcode{q}
prior to the element being erased.
If no such element exists,
\tcode{a.end()}
is returned.

\pnum
The iterator returned by
\tcode{a.erase(q1,q2)}
points to the element pointed to by
\tcode{q2}
prior to any elements being erased.
If no such element exists,
\tcode{a.end()}
is returned.

\pnum
For every sequence defined in this clause and in clause~\ref{lib.strings}:

\begin{itemize}
\item the constructor

\begin{codeblock}
template <class InputIterator>
X(InputIterator f, InputIterator l, const Allocator& a = Allocator())
\end{codeblock}

shall have the same effect as:

\begin{codeblock}
X(static_cast<typename X::size_type>(f),
  static_cast<typename X::value_type>(l),
  a)
\end{codeblock}

if \tcode{InputIterator} is an integral type.

\item the member functions in the forms:

\begin{codeblock}
template <class InputIterator>          // such as \tcode{insert()}
rt fx1(iterator p, InputIterator f, InputIterator l);

template <class InputIterator>          // such as \tcode{append()}, \tcode{assign()}
rt fx2(InputIterator f, InputIterator l);

template <class InputIterator>          // such as \tcode{replace()}
rt fx3(iterator i1, iterator i2, InputIterator f, InputIterator l);
\end{codeblock}

shall have the same effect, respectively, as:

\begin{codeblock}
fx1(p,
    static_cast<typename X::size_type>(f),
    static_cast<typename X::value_type>(l));

fx2(static_cast<typename X::size_type>(f),
    static_cast<typename X::value_type>(l));

fx3(i1, i2,
    static_cast<typename X::size_type>(f),
    static_cast<typename X::value_type>(l));
\end{codeblock}

if \tcode{InputIterator} is an integral type.
\end{itemize}

\pnum
\enternote
This follows directly from the requirements in the Iterator Requirements Table.
Integral types cannot be iterators, so, if \tcode{n1} and \tcode{n2} are values
of an integral type \tcode{N}, the expression \tcode{X(n1, n2)} cannot possibly
be interpreted as construction from a range of iterators. It must be taken to
mean the first constructor in the Iterator Requirements Table, not the second
one. If there is no conversion from \tcode{N} to \tcode{X::value_type}, then
this is not a valid expression at all.

\pnum
One way that sequence implementators can satisfy this requirement is to
specialize the member template for every integral type. Less cumbersome
implementation techniques also exist.
\exitnoteb
\enterexample

\begin{codeblock}
list<int> x;
...
vector<int> y(x.begin(), x.end());      // Construct a vector
                                        // from a range of iterators.
vector<int> z(100, 1);                  // Construct a vector of 100
                                        // elements, all initialized
                                        // to 1. The arguments are
                                        // not interpreted as iterators.
z.insert(z.begin(), x.begin(), x.end());// Insert a range of
                                        // iterators.
z.insert(z.begin(), 20, 0);             // Insert 20 copies of the
                                        // number 0.
\end{codeblock}

\exitexampleb

\pnum
Table~\ref{tab:containers.sequence.optional} lists sequence operations
that are provided for some types of
sequential containers but not others.
An implementation shall provide
these operations for all container types shown in the ``container''
column, and shall implement them so as to take amortized constant
time.

\begin{libreqtab4a}
{Optional sequence operations}
{tab:containers.sequence.optional}
\\ \topline
\lhdr{expression}       &   \chdr{return type}  &   \chdr{operational semantics}       &   \rhdr{container}    \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{expression}       &   \chdr{return type}  &   \chdr{operational semantics}       &   \rhdr{container}    \\ \capsep
\endhead

\tcode{a.front()}       &
 \tcode{reference; const_reference} for constant \tcode{a}    &
 \tcode{*a.begin()}     &
 \tcode{vector},
 \tcode{list},
 \tcode{deque}
 \\ \rowsep

\tcode{a.back()}        &
 \tcode{reference; const_reference} for constant \tcode{a}    &
 \tcode{*-{-}a.end()}     &
 \tcode{vector},
 \tcode{list},
 \tcode{deque}
 \\ \rowsep

\tcode{a.push_front(x)} &
  \tcode{void}          &
  \tcode{a.insert(a.begin(),x)}  &
  \tcode{list},
  \tcode{deque}
  \\ \rowsep

\tcode{a.push_back(x)} &
  \tcode{void}          &
  \tcode{a.insert(a.end(),x)}  &
  \tcode{vector},
  \tcode{list},
  \tcode{deque}
  \\ \rowsep

\tcode{a.pop_front()}      &
 \tcode{void}               &
 \tcode{a.erase(a.begin())}  &
 \tcode{list},
 \tcode{deque}
 \\ \rowsep

\tcode{a.pop_back()}       &
 \tcode{void}               &
 \tcode{a.erase(-{-}a.end())}  &
 \tcode{vector},
 \tcode{list},
 \tcode{deque}
 \\ \rowsep

\tcode{a[n]}                &
 \tcode{reference; const_reference} for constant \tcode{a}    &
 \tcode{*(a.begin() + n)}   &
 \tcode{vector},
 \tcode{deque}
 \\ \rowsep

\tcode{a.at(n)}             &
 \tcode{reference; const_reference} for constant \tcode{a}    &
 \tcode{*(a.begin() + n)}   &
 \tcode{vector},
 \tcode{deque}
 \\

\end{libreqtab4a}

\pnum
The member function
\tcode{at()}
provides bounds-checked access to container elements.
\tcode{at()}
throws
\tcode{out_of_range}
if
\tcode{n >= a.size()}.

\rSec2[lib.associative.reqmts]{Associative containers}

\pnum
Associative containers provide an ability for fast retrieval of data based on keys.
The library provides four basic kinds of associative containers:
\tcode{set},
\tcode{multiset},
\tcode{map}
and
\tcode{multimap}.

\pnum
Each associative container is parameterized on
\tcode{Key}
and an ordering relation
\tcode{Compare}
that induces a strict weak ordering~(\ref{lib.alg.sorting}) on
elements of
\tcode{Key}.
In addition,
\tcode{map}
and
\tcode{multimap}
associate an arbitrary type
\tcode{T}
with the
\tcode{Key}.
The object of type
\tcode{Compare}
is called the
\term{comparison object}
of a container.
This comparison object may be a pointer to function or an object of a type
with an appropriate function call operator.

\pnum
The phrase ``equivalence of keys'' means the equivalence relation imposed by the
comparison and
\textit{not}
the
\tcode{operator==}
on keys.
That is, two keys
\tcode{k1}
and
\tcode{k2}
are considered to be equivalent if for the
comparison object
\tcode{comp},
\tcode{comp(k1, k2) == false \&\& comp(k2, k1) == false}.

\pnum
An associative container supports \term{unique keys} if it may contain at
most one element for each key. Otherwise, it supports \term{equivalent keys}.
The \tcode{set} and \tcode{map} classes support unique keys; the \tcode{multiset}
and \tcode{multimap} classes support equivalent keys.

\pnum
For \tcode{set} and \tcode{multiset} the value type is the same as the key type.
For \tcode{map} and \tcode{multimap} it is equal to \tcode{pair<const Key, T>}.

\pnum
\tcode{iterator}
of an associative container is of the bidirectional iterator category.

\pnum
In Table~\ref{tab:containers.associative.requirements},
\tcode{X} is an associative container class,
\tcode{a} is a value of \tcode{X},
\tcode{a_uniq} is a value of \tcode{X}
when \tcode{X} supports unique keys,
\tcode{a_eq} denotes a value of \tcode{X}
when \tcode{X} supports multiple keys,
\tcode{i} and \tcode{j}
satisfy input iterator requirements and refer to elements of
\tcode{value_type}, \range{i}{j}
is a valid range,
\tcode{p} is a valid iterator to \tcode{a},
\tcode{q} is a valid dereferenceable iterator to \tcode{a},
\tcode{[q1, q2)} is a valid range in \tcode{a},
\tcode{t} is a value of \tcode{X::value_type},
\tcode{k} is a value of \tcode{X::key_type}
and \tcode{c} is a value of type \tcode{X::key_compare}.

\begin{libreqtab4b}
{Associative container requirements (in addition to container)}
{tab:containers.associative.requirements}
\\ \topline
\lhdr{expression}       &   \chdr{return type}  &   \chdr{assertion/note}       &   \rhdr{complexity}   \\
                        &                       &   \chdr{pre/post-condition}   &                       \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{expression}       &   \chdr{return type}  &   \chdr{assertion/note}       &   \rhdr{complexity}   \\
                        &                       &   \chdr{pre/post-condition}   &                       \\ \capsep
\endhead

\tcode{X::key_type}     &
 \tcode{Key}            &
 \tcode{Key} is \tcode{Assignable}  &
  compile time \\ \rowsep

\tcode{X::key_compare}  &
  \tcode{Compare}       &
  defaults to \tcode{less<key_type>} &
  compile time   \\ \rowsep

\tcode{X::value_compare}           &
 a binary predicate type           &
 is the same as \tcode{key_compare} for \tcode{set} and
 \tcode{multiset}; is an ordering relation on pairs induced by the
 first component (i.e. \tcode{Key}) for \tcode{map} and \tcode{multimap}. &
 compile time                       \\ \rowsep

\tcode{X(c)}\br
\tcode{X a(c);}                         &
                                        &
  constructs an empty container;\br
  uses \tcode{c} as a comparison object.  &
 constant                               \\ \rowsep

\tcode{X()}\br\tcode{X a;}                      &
                                                &
  constructs an empty container;\br
  uses \tcode{Compare()} as a comparison object  &
  constant                                       \\ \rowsep

\tcode{X(i,j,c);}\br
\tcode{X~a(i,j,c);}     &
                        &
  constructs an empty container and inserts elements from the
  range \tcode{[i, j)} into it; uses \tcode{c} as a comparison object. &
  \tcode{NlogN} in general (\tcode{N} is the distance from \tcode{i} to \tcode{j});\br
  linear if \tcode{[i, j)} is sorted with \tcode{value_comp()} \\ \rowsep

\tcode{X(i,j)} \tcode{X~a(i,j);}    &
                                    &
  same as above, but uses \tcode{Compare()} as a comparison object  &
  same as above                      \\ \rowsep

\tcode{a.key_comp()}       &
 \tcode{X::key_compare}    &
 returns the comparison object out of which \tcode{a} was constructed. &
 constant                   \\ \rowsep

\tcode{a.value_comp()}     &
 \tcode{X::value_compare}  &
 returns an object of \tcode{value_compare} constructed out of the comparison object &
 constant                   \\ \rowsep

\tcode{a_uniq.} \tcode{insert(t)}      &
  \tcode{pair<iterator, bool>}   &
  inserts \tcode{t} if and only if there is no element in the container
  with key equivalent to the key of \tcode{t}. The \tcode{bool} component of
  the returned pair indicates whether the insertion
  takes place and the \tcode{iterator}
  component of the pair points to the element with key
  equivalent to the key of \tcode{t}.    &
  logarithmic                    \\ \rowsep

\tcode{a_eq.insert(t)}        &
  \tcode{iterator}               &
  inserts \tcode{t} and returns the iterator pointing
  to the newly inserted element.    &
  logarithmic                    \\ \rowsep

\tcode{a.insert(p,t)}            &
  \tcode{iterator}               &
  inserts \tcode{t} if and only if there is no element with key
  equivalent to the key of \tcode{t} in containers with unique keys;
  always inserts \tcode{t} in containers with equivalent keys. always
  returns the iterator pointing to the element with key equivalent to
  the key of \tcode{t}. iterator \tcode{p} is a hint pointing to where
  the insert should start to search.    &
  logarithmic in general, but amortized constant if \tcode{t}
  is inserted right after \tcode{p}. \\ \rowsep

\tcode{a.insert(i,j)}            &
  \tcode{void}                   &
  pre: \tcode{i},\tcode{j} are not iterators into \tcode{a}.
  inserts each element from the range \range{i}{j} if and only if there
  is no element with key equivalent to the key of that element in containers
  with unique keys; always inserts that element in containers with equivalent keys.  &
  \tcode{Nlog(size()+N)} (\tcode{N} is the distance from \tcode{i} to \tcode{j})
  in general; linear if \tcode{[i, j)} is sorted according to \tcode{value_comp()} \\ \rowsep

\tcode{a.erase(k)}              &
 \tcode{size_type}             &
 erases all the elements in the container with key equivalent to
 \tcode{k}. returns the number of erased elements.  &
 \tcode{log(size()) + count(k)}       \\ \rowsep

\tcode{a.erase(q)}              &
 \tcode{void}               &
 erases the element pointed to by \tcode{q}.     &
 amortized constant             \\ \rowsep

\tcode{a.erase(q1,q2)}  &
 \tcode{void}        &
 erases all the elements in the range \range{q1}{q2}.  &
 \tcode{log(size())+ N} where \tcode{N} is the distance from
 \tcode{q1} to \tcode{q2}.    \\ \rowsep

\tcode{a.clear()}       &
 \tcode{void}           &
 \tcode{erase(a.begin(),a.end())}\br
 post: \tcode{size == 0}  &
 Linear in \tcode{size()}.  \\ \rowsep

\tcode{a.find(k)}       &
 \tcode{iterator}; \tcode{const_iterator} for constant \tcode{a}.  &
 returns an iterator pointing to an element with the key equivalent
 to \tcode{k}, or \tcode{a.end()} if such an element is not found    &
 logarithmic            \\ \rowsep

\tcode{a.count(k)}        &
 \tcode{size_type}        &
 returns the number of elements with key equivalent to \tcode{k}    &
 \tcode{log(size()) + count(k)}   \\ \rowsep

\tcode{a.lower_bound(k)}   &
 \tcode{iterator}; \tcode{const_iterator} for constant \tcode{a}.  &
 returns an iterator pointing to the first element with
 key not less than \tcode{k}.   &
 logarithmic            \\ \rowsep

\tcode{a.upper_bound(k)}       &
 \tcode{iterator}; \tcode{const_iterator} for constant \tcode{a}.  &
 returns an iterator pointing to the first element with
 key greater than \tcode{k}.   &
 logarithmic                    \\ \rowsep

\tcode{a.equal_range(k)}       &
 \tcode{pair<iterator, iterator>};
 \tcode{pair<const_iterator, const_iterator>} for constant \tcode{a}.     &
 equivalent to \tcode{make_pair(a.lower_bound(k), a.upper_bound(k))}.    &
 logarithmic                    \\
\end{libreqtab4b}

\pnum
The insert members shall not affect the validity of
iterators and references to the container,
and the erase members shall invalidate only iterators and
references to the erased elements.

\pnum
The fundamental property of iterators of associative containers is that they iterate through the containers
in the non-descending order of keys where non-descending is defined by the comparison that was used to
construct them.
For any two dereferenceable iterators
\tcode{i}
and
\tcode{j}
such that distance from
\tcode{i}
to
\tcode{j}
is positive,

\begin{codeblock}
value_comp(*j, *i) == false
\end{codeblock}

\pnum
For associative containers with unique keys the stronger condition holds,

\begin{codeblock}
value_comp(*i, *j) != false.
\end{codeblock}

\pnum
When an associative container is constructed by passing a comparison object the
container shall not store a pointer or reference to the passed object,
even if that object is passed by reference.
When an associative container is copied, either through a copy constructor
or an assignment operator,
the target container shall then use the comparison object from the container
being copied,
as if that comparison object had been passed to the target container in
its constructor.

\rSec1[lib.sequences]{Sequences}

\pnum
Headers \tcode{<deque>}, \tcode{<list>}, \tcode{<queue>}, 
\tcode{<stack>}, and \tcode{<vector>}.

\synopsis{Header \tcode{<deque>} synopsis}%
\indexlibrary{\idxhdr{deque}}

\begin{codeblock}
namespace std {
  template <class T, class Allocator = allocator<T> > class deque;
  template <class T, class Allocator>
    bool operator==
      (const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator<
      (const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator!=
      (const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator>
      (const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator>=
      (const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator<=
      (const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <class T, class Allocator>
    void swap(deque<T,Allocator>& x, deque<T,Allocator>& y);
}
\end{codeblock}

\synopsis{Header \tcode{<list>} synopsis}%
\indexlibrary{\idxhdr{list}}

\begin{codeblock}
namespace std {
  template <class T, class Allocator = allocator<T> > class list;
  template <class T, class Allocator>
    bool operator==(const list<T,Allocator>& x, const list<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator< (const list<T,Allocator>& x, const list<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator!=(const list<T,Allocator>& x, const list<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator> (const list<T,Allocator>& x, const list<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator>=(const list<T,Allocator>& x, const list<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator<=(const list<T,Allocator>& x, const list<T,Allocator>& y);
  template <class T, class Allocator>
    void swap(list<T,Allocator>& x, list<T,Allocator>& y);
}
\end{codeblock}

\synopsis{Header \tcode{<queue>} synopsis}%
\indexlibrary{\idxhdr{queue}}

\begin{codeblock}
namespace std {
  template <class T, class Container = deque<T> > class queue;
  template <class T, class Container>
    bool operator==(const queue<T, Container>& x,
                    const queue<T, Container>& y);
  template <class T, class Container>
    bool operator< (const queue<T, Container>& x,
                    const queue<T, Container>& y);
  template <class T, class Container>
    bool operator!=(const queue<T, Container>& x,
                    const queue<T, Container>& y);
  template <class T, class Container>
    bool operator> (const queue<T, Container>& x,
                    const queue<T, Container>& y);
  template <class T, class Container>
    bool operator>=(const queue<T, Container>& x,
                    const queue<T, Container>& y);
  template <class T, class Container>
    bool operator<=(const queue<T, Container>& x,
                    const queue<T, Container>& y);

  template <class T, class Container = vector<T>,
            class Compare = less<typename Container::value_type> >
  class priority_queue;
}
\end{codeblock}

\synopsis{Header \tcode{<stack>} synopsis}%
\indexlibrary{\idxhdr{stack}}

\begin{codeblock}
namespace std {
  template <class T, class Container = deque<T> > class stack;
  template <class T, class Container>
    bool operator==(const stack<T, Container>& x,
                    const stack<T, Container>& y);
  template <class T, class Container>
    bool operator< (const stack<T, Container>& x,
                    const stack<T, Container>& y);
  template <class T, class Container>
    bool operator!=(const stack<T, Container>& x,
                    const stack<T, Container>& y);
  template <class T, class Container>
    bool operator> (const stack<T, Container>& x,
                    const stack<T, Container>& y);
  template <class T, class Container>
    bool operator>=(const stack<T, Container>& x,
                    const stack<T, Container>& y);
  template <class T, class Container>
    bool operator<=(const stack<T, Container>& x,
                    const stack<T, Container>& y);
}
\end{codeblock}

\synopsis{Header \tcode{<vector>} synopsis}%
\indexlibrary{\idxhdr{vector}}

\begin{codeblock}
namespace std {
  template <class T, class Allocator = allocator<T> > class vector;
  template <class T, class Allocator>
    bool operator==(const vector<T,Allocator>& x,
                    const vector<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator< (const vector<T,Allocator>& x,
                    const vector<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator!=(const vector<T,Allocator>& x,
                    const vector<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator> (const vector<T,Allocator>& x,
                    const vector<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator>=(const vector<T,Allocator>& x,
                    const vector<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator<=(const vector<T,Allocator>& x,
                    const vector<T,Allocator>& y);
  template <class T, class Allocator>
    void swap(vector<T,Allocator>& x, vector<T,Allocator>& y);

  template <class Allocator> class vector<bool,Allocator>;
  template <class Allocator>
    bool operator==(const vector<bool,Allocator>& x,
                    const vector<bool,Allocator>& y);
  template <class Allocator>
    bool operator< (const vector<bool,Allocator>& x,
                    const vector<bool,Allocator>& y);
  template <class Allocator>
    bool operator!=(const vector<bool,Allocator>& x,
                    const vector<bool,Allocator>& y);
  template <class Allocator>
    bool operator> (const vector<bool,Allocator>& x,
                    const vector<bool,Allocator>& y);
  template <class Allocator>
    bool operator>=(const vector<bool,Allocator>& x,
                    const vector<bool,Allocator>& y);
  template <class Allocator>
    bool operator<=(const vector<bool,Allocator>& x,
                    const vector<bool,Allocator>& y);
  template <class Allocator>
    void swap(vector<bool,Allocator>& x, vector<bool,Allocator>& y);
}
\end{codeblock}

\rSec2[lib.deque]{Class template \tcode{deque}}

\pnum
A
\indexlibrary{\idxcode{deque}}%
\tcode{deque}
is a kind of sequence that, like a
\tcode{vector}~(\ref{lib.vector}), supports random access iterators.
In addition, it supports constant time insert and erase operations at the beginning or the end;
insert and erase in the middle take linear time.
That is, a deque is especially optimized for pushing and popping elements at the beginning and end.
As with vectors, storage management is handled automatically.

\pnum
A
\tcode{deque}
satisfies all of the requirements of a container and of a reversible container
(given in tables in~\ref{lib.container.requirements}) and of a sequence,
including the optional sequence requirements~(\ref{lib.sequence.reqmts}).
Descriptions are provided here only for operations on
\tcode{deque}
that are not described in one of these tables
or for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template <class T, class Allocator = allocator<T> >
  class deque {
  public:
    // types:
    typedef typename Allocator::reference         reference;
    typedef typename Allocator::const_reference   const_reference;
    typedef @\impdef@                iterator;       // See \ref{lib.container.requirements}
    typedef @\impdef@                const_iterator; // See \ref{lib.container.requirements}
    typedef @\impdef@                size_type;      // See \ref{lib.container.requirements}
    typedef @\impdef@                difference_type;// See \ref{lib.container.requirements}
    typedef T                                     value_type;
    typedef Allocator                             allocator_type;
    typedef typename Allocator::pointer           pointer;
    typedef typename Allocator::const_pointer     const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    // \ref{lib.deque.cons}, construct/copy/destroy:
    explicit deque(const Allocator& = Allocator());
    explicit deque(size_type n, const T& value = T(),
        const Allocator& = Allocator());
    template <class InputIterator>
      deque(InputIterator first, InputIterator last,
            const Allocator& = Allocator());
    deque(const deque<T,Allocator>& x);
   ~deque();
    deque<T,Allocator>& operator=(const deque<T,Allocator>& x);
    template <class InputIterator>
      void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const T& t);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;
    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    // \ref{lib.deque.capacity}, capacity:
    size_type size() const;
    size_type max_size() const;
    void      resize(size_type sz, T c = T());
    bool      empty() const;

    // element access:
    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    reference       at(size_type n);
    const_reference at(size_type n) const;
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    // \ref{lib.deque.modifiers}, modifiers:
    void push_front(const T& x);
    void push_back(const T& x);

    iterator insert(iterator position, const T& x);
    iterator insert(iterator position, size_type n, const T& x);
    template <class InputIterator>
      void insert (iterator position,
                   InputIterator first, InputIterator last);

    void pop_front();
    void pop_back();

    iterator erase(iterator position);
    iterator erase(iterator first, iterator last);
    void     swap(deque<T,Allocator>&);
    void     clear();
  };

  template <class T, class Allocator>
    bool operator==(const deque<T,Allocator>& x,
                    const deque<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator< (const deque<T,Allocator>& x,
                    const deque<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator!=(const deque<T,Allocator>& x,
                    const deque<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator> (const deque<T,Allocator>& x,
                    const deque<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator>=(const deque<T,Allocator>& x,
                    const deque<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator<=(const deque<T,Allocator>& x,
                    const deque<T,Allocator>& y);

  // specialized algorithms:
  template <class T, class Allocator>
    void swap(deque<T,Allocator>& x, deque<T,Allocator>& y);
}
\end{codeblock}

\rSec3[lib.deque.cons]{\tcode{deque} constructors, copy, and assignment}

\indexlibrary{\idxcode{deque}!\idxcode{deque}}%
\indexlibrary{\idxcode{deque}!\idxcode{deque}}%
\begin{itemdecl}
explicit deque(const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an empty
\tcode{deque},
using the specified allocator.

\pnum
\complexity
Constant.
\end{itemdescr}

\indexlibrary{\idxcode{deque}!\idxcode{deque}}%
\indexlibrary{\idxcode{deque}!\idxcode{deque}}%
\begin{itemdecl}
explicit deque(size_type n, const T& value = T(),
               const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a
\tcode{deque}
with \tcode{n} copies of \tcode{value},
using the specified allocator.

\pnum
\complexity
Linear in \tcode{n}.
\end{itemdescr}

\indexlibrary{\idxcode{deque}!\idxcode{deque}}%
\indexlibrary{\idxcode{deque}!\idxcode{deque}}%
\begin{itemdecl}
template <class InputIterator>
  deque(InputIterator first, InputIterator last,
        const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a
\tcode{deque}
equal to the range
\range{first}{last},
using the specified allocator.

\pnum
\complexity
Makes
\tcode{distance(first, last)}
calls to the copy constructor of \tcode{T}.

\addtocounter{footnote}{1}%
\footnotetext{This footnote is intentionally empty.}
\end{itemdescr}

\indexlibrary{\idxcode{assign}!\tcode{deque}}%
\begin{itemdecl}
template <class InputIterator>
  void assign(InputIterator first, InputIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
    erase(begin(), end());
    insert(begin(), first, last);
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{assign}!\idxcode{deque}}%
\indexlibrary{\idxcode{deque}!\idxcode{assign}}%
\begin{itemdecl}
void assign(size_type n, const T& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
    erase(begin(), end());
    insert(begin(), n, t);
\end{codeblock}
\end{itemdescr}

\rSec3[lib.deque.capacity]{\tcode{deque} capacity}

\indexlibrary{\idxcode{resize}!\tcode{deque}}%
\begin{itemdecl}
void resize(size_type sz, T c = T());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
    if (sz > size())
      insert(end(), sz-size(), c);
    else if (sz < size())
      erase(begin()+sz, end());
    else
      ;                             // do nothing
\end{codeblock}
\end{itemdescr}

\rSec3[lib.deque.modifiers]{\tcode{deque} modifiers}

\indexlibrary{\idxcode{insert}!\tcode{deque}}%
\begin{itemdecl}
iterator insert(iterator position, const T& x);
void     insert(iterator position, size_type n, const T& x);
template <class InputIterator>
  void insert(iterator position,
              InputIterator first, InputIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
An insert in the middle of the deque invalidates all the iterators and
references to elements of the deque.
An insert at either end of the
deque invalidates all the iterators to the deque, but has no effect on
the validity of references to elements of the deque.

\pnum
\notes
If an exception is thrown other than by the
copy constructor or assignment operator of
\tcode{T}
there are no effects.

\pnum
\complexity
In the worst case, inserting a single element into a deque takes time linear
in the minimum of the distance from the insertion point to the beginning of the
deque and the distance from the insertion point to the end of the deque.
Inserting a single element either at the beginning or end of a deque always takes constant time
and causes a single call to the copy constructor of
\tcode{T}.
\end{itemdescr}

\indexlibrary{\idxcode{erase}!\tcode{deque}}%
\begin{itemdecl}
iterator erase(iterator position);
iterator erase(iterator first, iterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
An erase in the middle of the deque invalidates all the iterators and references
to elements of the deque.
An erase at either end of the deque invalidates only the iterators and the
references to the erased elements.

\pnum
\complexity
The number of calls to the destructor is the same as the
number of elements erased, but the number of the calls to the assignment operator is
at most equal to the minimum of the number of elements before the erased elements
and the number of elements after the erased elements.

\pnum
\throws
Nothing unless an exception is thrown by the copy constructor or
assignment operator of
\tcode{T}.
\end{itemdescr}

\rSec3[lib.deque.special]{\tcode{deque} specialized algorithms}

\indexlibrary{\idxcode{swap}!\idxcode{deque}}%
\indexlibrary{\idxcode{deque}!\idxcode{swap}}%
\begin{itemdecl}
template <class T, class Allocator>
  void swap(deque<T,Allocator>& x, deque<T,Allocator>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
    x.swap(y);
\end{codeblock}
\end{itemdescr}

\rSec2[lib.list]{Class template \tcode{list}}

\pnum
\indexlibrary{\idxcode{list}}%
A
\tcode{list}
is a kind of sequence that supports
bidirectional iterators and allows constant time insert and erase
operations anywhere within the sequence, with storage management handled
automatically. Unlike vectors~(\ref{lib.vector}) and deques~(\ref{lib.deque}),
fast random access to list elements is not supported, but many
algorithms only need sequential access anyway.

\pnum
A \tcode{list} satisfies all of the requirements of a container and of
a reversible container (given in two tables in
\ref{lib.container.requirements}) and of a sequence,
including most of the optional sequence
requirements~(\ref{lib.sequence.reqmts}).
The exceptions are the
\tcode{operator[]}
and
\tcode{at}
member functions, which are not provided.\footnote{These member functions
are only provided by containers whose iterators
are random access iterators.
}
Descriptions are provided here only for operations on
\tcode{list}
that are not described in one of these tables
or for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template <class T, class Allocator = allocator<T> >
  class list {
  public:
    // types:
    typedef typename Allocator::reference         reference;
    typedef typename Allocator::const_reference   const_reference;
    typedef @\impdef@                iterator;       // see \ref{lib.container.requirements}
    typedef @\impdef@                const_iterator; // see \ref{lib.container.requirements}
    typedef @\impdef@                size_type;      // see \ref{lib.container.requirements}
    typedef @\impdef@                difference_type;// see \ref{lib.container.requirements}
    typedef T                                     value_type;
    typedef Allocator                             allocator_type;
    typedef typename Allocator::pointer           pointer;
    typedef typename Allocator::const_pointer     const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    // \ref{lib.list.cons}, construct/copy/destroy:
    explicit list(const Allocator& = Allocator());
    explicit list(size_type n, const T& value = T(),
                  const Allocator& = Allocator());
    template <class InputIterator>
      list(InputIterator first, InputIterator last,
           const Allocator& = Allocator());
    list(const list<T,Allocator>& x);
   ~list();
    list<T,Allocator>& operator=(const list<T,Allocator>& x);
    template <class InputIterator>
      void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const T& t);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;
    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    // \ref{lib.list.capacity}, capacity:
    bool      empty() const;
    size_type size() const;
    size_type max_size() const;
    void      resize(size_type sz, T c = T());

    // element access:
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    // \ref{lib.list.modifiers}, modifiers:
    void push_front(const T& x);
    void pop_front();
    void push_back(const T& x);
    void pop_back();

    iterator insert(iterator position, const T& x);
    void     insert(iterator position, size_type n, const T& x);
    template <class InputIterator>
      void insert(iterator position, InputIterator first,
                  InputIterator last);

    iterator erase(iterator position);
    iterator erase(iterator position, iterator last);
    void     swap(list<T,Allocator>&);
    void     clear();

    // \ref{lib.list.ops}, list operations:
    void splice(iterator position, list<T,Allocator>& x);
    void splice(iterator position, list<T,Allocator>& x, iterator i);
    void splice(iterator position, list<T,Allocator>& x, iterator first,
                iterator last);

    void remove(const T& value);
    template <class Predicate> void remove_if(Predicate pred);

    void unique();
    template <class BinaryPredicate>
      void unique(BinaryPredicate binary_pred);

    void merge(list<T,Allocator>& x);
    template <class Compare> void merge(list<T,Allocator>& x, Compare comp);

    void sort();
    template <class Compare> void sort(Compare comp);

    void reverse();
  };

  template <class T, class Allocator>
    bool operator==(const list<T,Allocator>& x, const list<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator< (const list<T,Allocator>& x, const list<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator!=(const list<T,Allocator>& x, const list<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator> (const list<T,Allocator>& x, const list<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator>=(const list<T,Allocator>& x, const list<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator<=(const list<T,Allocator>& x, const list<T,Allocator>& y);

  // specialized algorithms:
  template <class T, class Allocator>
    void swap(list<T,Allocator>& x, list<T,Allocator>& y);
}
\end{codeblock}

\rSec3[lib.list.cons]{\tcode{list} constructors, copy, and assignment}

\indexlibrary{\idxcode{list}!\idxcode{list}}%
\indexlibrary{\idxcode{list}!\idxcode{list}}%
\begin{itemdecl}
explicit list(const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an empty list, using the specified allocator.

\pnum
\complexity
Constant.
\end{itemdescr}

\indexlibrary{\idxcode{list}!\idxcode{list}}%
\indexlibrary{\idxcode{list}!\idxcode{list}}%
\begin{itemdecl}
explicit list(size_type n, const T& value = T(),
              const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a
\tcode{list}
with
\tcode{n}
copies of
\tcode{value},
using the specified allocator.

\pnum
\complexity
Linear in
\tcode{n}.
\end{itemdescr}

\indexlibrary{\idxcode{list}!\idxcode{list}}%
\indexlibrary{\idxcode{list}!\idxcode{list}}%
\begin{itemdecl}
template <class InputIterator>
list(InputIterator first, InputIterator last,
     const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a
\tcode{list}
equal to the range
\range{first}{last}.

\pnum
\complexity
Linear in
\tcode{first - last}.
\end{itemdescr}

\indexlibrary{\idxcode{assign}!\tcode{list}}%
\begin{itemdecl}
template <class InputIterator>
  void assign(InputIterator first, InputIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
    erase(begin(), end());
    insert(begin(), first, last);
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{assign}!\idxcode{list}}%
\indexlibrary{\idxcode{list}!\idxcode{assign}}%
\begin{itemdecl}
void assign(size_type n, const T& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
    erase(begin(), end());
    insert(begin(), n, t);
\end{codeblock}
\end{itemdescr}

\rSec3[lib.list.capacity]{\tcode{list} capacity}

\indexlibrary{\idxcode{resize}!\tcode{list}}%
\begin{itemdecl}
void resize(size_type sz, T c = T());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
    if (sz > size())
      insert(end(), sz-size(), c);
    else if (sz < size()) {
      iterator i = begin();
      advance(i, sz);
      erase(i, end());
    }
    else
      ;                             // do nothing
\end{codeblock}
\end{itemdescr}

\rSec3[lib.list.modifiers]{\tcode{list} modifiers}

\indexlibrary{\idxcode{insert}!\tcode{list}}%
\begin{itemdecl}
iterator insert(iterator position, const T& x);
void     insert(iterator position, size_type n, const T& x);
template <class InputIterator>
  void insert(iterator position, InputIterator first,
              InputIterator last);

void push_front(const T& x);
void push_back(const T& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\notes
Does not affect the validity of iterators and references.
If an exception is thrown there are no effects.

\pnum
\complexity
Insertion of a single element into a list takes constant time and
exactly one call to the copy constructor of
\tcode{T}. Insertion of multiple elements into a list is linear in the
number of elements inserted, and the number of calls to the copy
constructor of \tcode{T} is exactly equal
to the number of elements inserted.
\end{itemdescr}

\indexlibrary{\idxcode{erase}!\tcode{list}}%
\begin{itemdecl}
iterator erase(iterator position);
iterator erase(iterator first, iterator last);

void pop_front();
void pop_back();
void clear();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Invalidates only the iterators and references to the erased elements.

\pnum
\throws Nothing.

\pnum
\complexity
Erasing a single element is a constant time operation with a single call to the destructor of
\tcode{T}.
Erasing a range in a list is linear time in the
size of the range and the number of calls to the destructor of type
\tcode{T}
is exactly equal to the size of the range.
\end{itemdescr}

\rSec3[lib.list.ops]{\tcode{list} operations}

\pnum
Since lists allow fast insertion and erasing from the middle of a list, certain
operations are provided specifically for them.

\pnum
\tcode{list} provides three splice operations that destructively move elements from one list to
another.

\indexlibrary{\idxcode{splice}!\tcode{list}}%
\begin{itemdecl}
void splice(iterator position, list<T,Allocator>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{\&x != this}.

\pnum
\effects
Inserts the contents of
\tcode{x}
before
\tcode{position}
and
\tcode{x}
becomes empty.
Invalidates all iterators and references to the list
\tcode{x}.

\pnum
\throws Nothing.

\pnum
\complexity
Constant time.
\end{itemdescr}

\indexlibrary{\idxcode{splice}!\idxcode{list}}%
\indexlibrary{\idxcode{list}!\idxcode{splice}}%
\begin{itemdecl}
void splice(iterator position, list<T,Allocator>& x, iterator i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Inserts an element pointed to by
\tcode{i}
from list
\tcode{x}
before position and removes the element from
\tcode{x}.
The result is unchanged if
\tcode{position == i}
or
\tcode{position == ++i}.
Invalidates only the iterators and references to the spliced element.

\pnum
\throws Nothing.

\pnum
\requires
\tcode{i}
is a valid dereferenceable iterator of
\tcode{x}.

\pnum
\complexity
Constant time.
\end{itemdescr}

\indexlibrary{\idxcode{splice}!\idxcode{list}}%
\indexlibrary{\idxcode{list}!\idxcode{splice}}%
\begin{itemdecl}
void splice(iterator position, list<T,Allocator>& x, iterator first,
            iterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Inserts elements in the range
\range{first}{last}
before
\tcode{position}
and removes the elements from
\tcode{x}.

\pnum
\requires
\tcode{[first, last)}
is a valid range in
\tcode{x}.
The result is undefined if
\tcode{position}
is an iterator in the range
\range{first}{last}.
Invalidates only the iterators and references to the spliced elements.

\pnum
\throws Nothing.

\pnum
\complexity
Constant time if
\tcode{\&x == this};
otherwise, linear time.
\end{itemdescr}

\indexlibrary{\idxcode{remove}!\tcode{list}}%
\begin{itemdecl}
                           void remove(const T& value);
template <class Predicate> void remove_if(Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Erases all the elements in the list referred by a list iterator \tcode{i} for which the
following conditions hold: \tcode{*i == value, pred(*i) != false}.

\pnum
\throws
Nothing unless an exception is thrown by
\tcode{*i == value}
or
\tcode{pred(*i) != false}.

\pnum
\notes
Stable: the relative order of the elements that are not removed is the same
as their relative order in the original list.

\pnum
\complexity
Exactly
\tcode{size()}
applications of the corresponding predicate.
\end{itemdescr}

\indexlibrary{\idxcode{unique}!\tcode{list}}%
\begin{itemdecl}
                                 void unique();
template <class BinaryPredicate> void unique(BinaryPredicate binary_pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Eliminates all but the first element from every
consecutive group of equal elements referred to by the iterator \tcode{i} in the range
\range{first + 1}{last} for which \tcode{*i == *(i-1)} (for the version of
\tcode{unique} with no arguments) or \tcode{pred(*i, *(i - 1))} (for the version of
\tcode{unique} with a predicate argument) holds.

\pnum
\throws
Nothing unless an exception in thrown by
\tcode{*i == *(i-1)}
or
\tcode{pred(*i, *(i - 1))}

\pnum
\complexity
If the range
\tcode{(last - first)}
is not empty, exactly
\tcode{(last - first) - 1}
applications of the corresponding predicate,
otherwise no applications of the predicate.
\end{itemdescr}

\indexlibrary{\idxcode{merge}!\tcode{list}}%
\begin{itemdecl}
void   merge(list<T,Allocator>& x);
template <class Compare> void merge(list<T,Allocator>& x, Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{comp} defines a strict weak ordering~(\ref{lib.alg.sorting}), and the list and the argument list are both
sorted according to this ordering.

\pnum
\effects
Merges the argument list into the list.

\pnum
\notes
Stable: for equivalent elements in the two lists, the elements from the list
always precede the elements from the argument list.
\tcode{x} is empty after the merge.

\pnum
\complexity
At most
\tcode{size() + x.size() - 1}
comparisons.
If an exception is thrown other than by a comparison there are no effects.
\end{itemdescr}

\indexlibrary{\idxcode{reverse}!\tcode{list}}%
\begin{itemdecl}
void reverse();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Reverses the order of the elements in the list.

\pnum
\throws
Nothing.

\pnum
\complexity
Linear time.
\end{itemdescr}

\indexlibrary{\idxcode{sort}!\tcode{list}}%
\begin{itemdecl}
                         void sort();
template <class Compare> void sort(Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{operator<}
(for the first version) or
\tcode{comp}
(for the second version)
defines a strict weak ordering~(\ref{lib.alg.sorting}).

\pnum
\effects
Sorts the list according to the \tcode{operator<} or a \tcode{Compare} function object.

\pnum
\notes
Stable: the relative order of the equivalent elements is preserved.
If an exception is thrown the order of the elements in the list is indeterminate.

\pnum
\complexity
Approximately
\tcode{NlogN}
comparisons, where
\tcode{N == size()}.
\end{itemdescr}

\rSec3[lib.list.special]{\tcode{list} specialized algorithms}

\indexlibrary{\idxcode{swap}!\idxcode{list}}%
\indexlibrary{\idxcode{list}!\idxcode{swap}}%
\begin{itemdecl}
template <class T, class Allocator>
  void swap(list<T,Allocator>& x, list<T,Allocator>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
    x.swap(y);
\end{codeblock}
\end{itemdescr}

\rSec2[lib.container.adaptors]{Container adaptors}

\pnum
The container adaptors each take a Container template parameter, and each
constructor takes a Container reference argument. This container is copied
into the Container member of each adaptor.

\rSec3[lib.queue]{Class template \tcode{queue}}

\pnum
\indexlibrary{\idxcode{queue}}%
Any sequence supporting operations
\tcode{front()},
\tcode{back()},
\tcode{push_back()}
and
\tcode{pop_front()}
can be used to instantiate
\tcode{queue}.
In particular,
\tcode{list}~(\ref{lib.list})
and
\tcode{deque}~(\ref{lib.deque})
can be used.

\begin{codeblock}
namespace std {
  template <class T, class Container = deque<T> >
  class queue {
  public:
    typedef typename Container::value_type            value_type;
    typedef typename Container::size_type             size_type;
    typedef          Container                        container_type;
  protected:
    Container c;

  public:
    explicit queue(const Container& = Container());

    bool      empty() const             { return c.empty(); }
    size_type size()  const             { return c.size(); }
    value_type&       front()           { return c.front(); }
    const value_type& front() const     { return c.front(); }
    value_type&       back()            { return c.back(); }
    const value_type& back() const      { return c.back(); }
    void push(const value_type& x)      { c.push_back(x); }
    void pop()                          { c.pop_front(); }
  };

  template <class T, class Container>
    bool operator==(const queue<T, Container>& x,
                    const queue<T, Container>& y);
  template <class T, class Container>
    bool operator< (const queue<T, Container>& x,
                    const queue<T, Container>& y);
  template <class T, class Container>
    bool operator!=(const queue<T, Container>& x,
                    const queue<T, Container>& y);
  template <class T, class Container>
    bool operator> (const queue<T, Container>& x,
                    const queue<T, Container>& y);
  template <class T, class Container>
    bool operator>=(const queue<T, Container>& x,
                    const queue<T, Container>& y);
  template <class T, class Container>
    bool operator<=(const queue<T, Container>& x,
                    const queue<T, Container>& y);
}
\end{codeblock}

\indexlibrary{\idxcode{operator==}!\idxcode{queue}}%
\begin{itemdecl}
operator==
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.c == y.c}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{queue}}%
\begin{itemdecl}
operator<
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.c < y.c}.
\end{itemdescr}

\rSec3[lib.priority.queue]{Class template \tcode{priority_queue}}

\pnum
\indexlibrary{\idxcode{priority_queue}}%
Any sequence with random access iterator and supporting operations
\tcode{front()},
\tcode{push_back()}
and
\tcode{pop_back()}
can be used to instantiate
\tcode{priority_queue}.
In particular,
\tcode{vector}~(\ref{lib.vector})
and
\tcode{deque}~(\ref{lib.deque})
can be used.
Instantiating
\tcode{priority_queue}
also involves supplying a function or function object for making
priority comparisons; the library assumes that the function or function
object defines a strict weak ordering~(\ref{lib.alg.sorting}).

\begin{codeblock}
namespace std {
  template <class T, class Container = vector<T>,
            class Compare = less<typename Container::value_type> >
  class priority_queue {
  public:
    typedef typename Container::value_type            value_type;
    typedef typename Container::size_type             size_type;
    typedef          Container                        container_type;
  protected:
    Container c;
    Compare comp;

  public:
    explicit priority_queue(const Compare& x = Compare(),
                            const Container& = Container());
    template <class InputIterator>
      priority_queue(InputIterator first, InputIterator last,
                     const Compare& x = Compare(),
                     const Container& = Container());

    bool      empty() const       { return c.empty(); }
    size_type size()  const       { return c.size(); }
    const value_type& top() const { return c.front(); }
    void push(const value_type& x);
    void pop();
  };
                                // no equality is provided
}
\end{codeblock}

\rSec4[lib.priqueue.cons]{\tcode{priority_queue} constructors}

\indexlibrary{\idxcode{priority_queue}!\idxcode{priority_queue}}%
\begin{itemdecl}
priority_queue(const Compare& x = Compare(),
               const Container& y = Container());
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{x} defines a strict weak ordering~(\ref{lib.alg.sorting}).

\pnum
\effects
Initializes
\tcode{comp} with
\tcode{x} and
\tcode{c} with
\tcode{y};
calls
\tcode{make_heap(c.begin(), c.end(), comp)}.
\end{itemdescr}

\indexlibrary{\idxcode{priority_queue}!\idxcode{priority_queue}}%
\begin{itemdecl}
template <class InputIterator>
  priority_queue(InputIterator first, InputIterator last,
                 const Compare& x = Compare(),
                 const Container& y = Container());
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{x} defines a strict weak ordering~(\ref{lib.alg.sorting}).

\pnum
\effects
Initializes
\tcode{c} with
\tcode{y} and
\tcode{comp} with
\tcode{x};
calls
\tcode{c.insert(c.end(), first, last)};
and finally calls
\tcode{make_heap(c.begin(), c.end(), comp)}.
\end{itemdescr}

\rSec4[lib.priqueue.members]{\tcode{priority_queue} members}

\indexlibrary{\idxcode{push}!\tcode{priority_queue}}%
\begin{itemdecl}
void push(const value_type& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
        c.push_back(x);
        push_heap(c.begin(), c.end(), comp);
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{pop}!\tcode{priority_queue}}%
\begin{itemdecl}
void pop();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
        pop_heap(c.begin(), c.end(), comp);
        c.pop_back();
\end{codeblock}
\end{itemdescr}

\rSec3[lib.stack]{Class template \tcode{stack}}

\pnum
\indexlibrary{\idxcode{stack}}%
Any sequence supporting operations
\tcode{back()},
\tcode{push_back()}
and
\tcode{pop_back()}
can be used to instantiate
\tcode{stack}.
In particular,
\tcode{vector}~(\ref{lib.vector}),
\tcode{list}~(\ref{lib.list})
and
\tcode{deque}~(\ref{lib.deque})
can be used.

\begin{codeblock}
namespace std {
  template <class T, class Container = deque<T> >
  class stack {
  public:
    typedef typename Container::value_type            value_type;
    typedef typename Container::size_type             size_type;
    typedef          Container                        container_type;
  protected:
    Container c;

  public:
    explicit stack(const Container& = Container());

    bool      empty() const             { return c.empty(); }
    size_type size()  const             { return c.size(); }
    value_type&       top()             { return c.back(); }
    const value_type& top() const       { return c.back(); }
    void push(const value_type& x)      { c.push_back(x); }
    void pop()                          { c.pop_back(); }
  };

  template <class T, class Container>
    bool operator==(const stack<T, Container>& x,
                    const stack<T, Container>& y);
  template <class T, class Container>
    bool operator< (const stack<T, Container>& x,
                    const stack<T, Container>& y);
  template <class T, class Container>
    bool operator!=(const stack<T, Container>& x,
                    const stack<T, Container>& y);
  template <class T, class Container>
    bool operator> (const stack<T, Container>& x,
                    const stack<T, Container>& y);
  template <class T, class Container>
    bool operator>=(const stack<T, Container>& x,
                    const stack<T, Container>& y);
  template <class T, class Container>
    bool operator<=(const stack<T, Container>& x,
                    const stack<T, Container>& y);
}
\end{codeblock}

\rSec2[lib.vector]{Class template \tcode{vector}}

\pnum
\indexlibrary{\idxcode{vector}}%
A
\tcode{vector}
is a kind of sequence that supports random access iterators.
In addition, it supports (amortized) constant time insert and erase operations at the end;
insert and erase in the middle take linear time.
Storage management is handled automatically, though hints can be given
to improve efficiency.
The elements of a vector are stored contiguously, meaning that if
\tcode{v}
is a
\tcode{vector<T, Allocator>}
where
\tcode{T}
is some type other than
\tcode{bool},
then it obeys the identity
\tcode{\&v[n] == \&v[0] + n}
for all
\tcode{0 <= n < v.size()}.

\pnum
A \tcode{vector} satisfies all of the requirements of a container and of a
reversible container (given in two tables in~\ref{lib.container.requirements})
and of a sequence, including most of the optional sequence
requirements~(\ref{lib.sequence.reqmts}). The exceptions are the
\tcode{push_front} and \tcode{pop_front} member functions, which are not
provided. Descriptions are provided here only for operations on \tcode{vector}
that are not described in one of these tables or for operations where there is
additional semantic information.

\begin{codeblock}
namespace std {
  template <class T, class Allocator = allocator<T> >
  class vector {
  public:
    // types:
    typedef typename Allocator::reference         reference;
    typedef typename Allocator::const_reference   const_reference;
    typedef @\impdef@                iterator;       // see \ref{lib.container.requirements}
    typedef @\impdef@                const_iterator; // see \ref{lib.container.requirements}
    typedef @\impdef@                size_type;      // see \ref{lib.container.requirements}
    typedef @\impdef@                difference_type;// see \ref{lib.container.requirements}
    typedef T                                     value_type;
    typedef Allocator                             allocator_type;
    typedef typename Allocator::pointer           pointer;
    typedef typename Allocator::const_pointer     const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    // \ref{lib.vector.cons}, construct/copy/destroy:
    explicit vector(const Allocator& = Allocator());
    explicit vector(size_type n, const T& value = T(),
        const Allocator& = Allocator());
    template <class InputIterator>
      vector(InputIterator first, InputIterator last,
        const Allocator& = Allocator());
    vector(const vector<T,Allocator>& x);
   ~vector();
    vector<T,Allocator>& operator=(const vector<T,Allocator>& x);
    template <class InputIterator>
      void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const T& u);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;
    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    // \ref{lib.vector.capacity}, capacity:
    size_type size() const;
    size_type max_size() const;
    void      resize(size_type sz, T c = T());
    size_type capacity() const;
    bool      empty() const;
    void      reserve(size_type n);

    // element access:
    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    const_reference at(size_type n) const;
    reference       at(size_type n);
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    // \ref{lib.vector.modifiers}, modifiers:
    void push_back(const T& x);
    void pop_back();
    iterator insert(iterator position, const T& x);
    void     insert(iterator position, size_type n, const T& x);
    template <class InputIterator>
        void insert(iterator position,
                    InputIterator first, InputIterator last);
    iterator erase(iterator position);
    iterator erase(iterator first, iterator last);
    void     swap(vector<T,Allocator>&);
    void     clear();
  };

  template <class T, class Allocator>
    bool operator==(const vector<T,Allocator>& x,
                    const vector<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator< (const vector<T,Allocator>& x,
                    const vector<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator!=(const vector<T,Allocator>& x,
                    const vector<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator> (const vector<T,Allocator>& x,
                    const vector<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator>=(const vector<T,Allocator>& x,
                    const vector<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator<=(const vector<T,Allocator>& x,
                    const vector<T,Allocator>& y);

  // specialized algorithms:
  template <class T, class Allocator>
    void swap(vector<T,Allocator>& x, vector<T,Allocator>& y);
}
\end{codeblock}%
\indexlibrary{\idxcode{vector}!\tcode{operator==}}%
\indexlibrary{\idxcode{vector}!\tcode{operator<}}

\rSec3[lib.vector.cons]{\tcode{vector} constructors, copy, and assignment}

\indexlibrary{\idxcode{vector}!\tcode{vector}}
\begin{itemdecl}
vector(const Allocator& = Allocator());
explicit vector(size_type n, const T& value = T(),
                const Allocator& = Allocator());
template <class InputIterator>
  vector(InputIterator first, InputIterator last,
         const Allocator& = Allocator());
vector(const vector<T,Allocator>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\complexity
The constructor \tcode{template <class InputIterator> vector(InputIterator first,
Inp\-utIterator last)}
makes only \tcode{N}
calls to the copy constructor of
\tcode{T}
(where \tcode{N}
is the distance between
\tcode{first}
and
\tcode{last})
and no reallocations if iterators first and last are of forward, bidirectional, or random access categories.
It makes order
\tcode{N}
calls to the copy constructor of
\tcode{T}
and order
\tcode{logN}
reallocations if they are just input iterators.
\end{itemdescr}

\indexlibrary{\idxcode{assign}!\idxcode{vector}}%
\begin{itemdecl}
template <class InputIterator>
  void assign(InputIterator first, InputIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
    erase(begin(), end());
    insert(begin(), first, last);
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{assign}!\idxcode{vector}}%
\indexlibrary{\idxcode{vector}!\idxcode{assign}}%
\begin{itemdecl}
void assign(size_type n, const T& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
    erase(begin(), end());
    insert(begin(), n, t);
\end{codeblock}
\end{itemdescr}

\rSec3[lib.vector.capacity]{\tcode{vector} capacity}

\indexlibrary{\idxcode{capacity}!\idxcode{vector}}%
\begin{itemdecl}
size_type capacity() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The total number of elements that the vector can hold
without requiring reallocation.
\end{itemdescr}

\indexlibrary{\idxcode{reserve}!\idxcode{vector}}%
\begin{itemdecl}
void reserve(size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
A directive that informs a
\tcode{vector}
of a planned change in size, so that it can manage the storage allocation accordingly.
After
\tcode{reserve()},
\tcode{capacity()}
is greater or equal to the argument of
\tcode{reserve}
if reallocation happens; and equal to the previous value of
\tcode{capacity()}
otherwise.
Reallocation happens at this point if and only if the current capacity is less than the
argument of
\tcode{reserve()}.

\pnum
\complexity
It does not change the size of the sequence and takes at most linear
time in the size of the sequence.

\pnum
\throws
\tcode{length_error} if \tcode{n >
max_size()}.\footnote{\tcode{reserve()} uses \tcode{Allocator::allocate()} which
may throw an appropriate exception.}

\pnum
\notes
Reallocation invalidates all the references, pointers, and iterators
referring to the elements in the sequence.
It is guaranteed that no reallocation takes place during insertions that happen
after a call to
\tcode{reserve()}
until the time when an insertion would make the size of the vector
greater than the size specified in the most recent call to
\tcode{reserve()}.
\end{itemdescr}

\indexlibrary{\idxcode{resize}!\idxcode{vector}}%
\begin{itemdecl}
void resize(size_type sz, T c = T());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
    if (sz > size())
      insert(end(), sz-size(), c);
    else if (sz < size())
      erase(begin()+sz, end());
    else
      ;                           // do nothing
\end{codeblock}
\end{itemdescr}

\rSec3[lib.vector.modifiers]{\tcode{vector} modifiers}

\indexlibrary{\idxcode{insert}!\idxcode{vector}}%
\begin{itemdecl}
iterator insert(iterator position, const T& x);
void     insert(iterator position, size_type n, const T& x);
template <class InputIterator>
  void insert(iterator position, InputIterator first, InputIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\notes
Causes reallocation if the new size is greater than the old capacity.
If no reallocation happens, all the iterators and references before the insertion point remain valid.
If an exception is thrown other than by
the copy constructor or assignment operator of
\tcode{T} there are no effects.

\pnum
\complexity
If \tcode{first} and \tcode{last} are forward iterators, bidirectional iterators,
or random access iterators,
the complexity is linear in the number of elements in the range
\tcode{[first, last)} plus the distance to the end of the vector.
If they are input iterators, the complexity is proportional to the number of
elements in the range
\tcode{[first, last)} times the distance to the end of the vector.
\end{itemdescr}

\indexlibrary{\idxcode{erase}!\idxcode{vector}}%
\begin{itemdecl}
iterator erase(iterator position);
iterator erase(iterator first, iterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Invalidates all the iterators and references after the point of the erase.

\pnum
\complexity
The destructor of \tcode{T} is called the number of times equal to the
number of the elements erased, but the assignment operator
of \tcode{T} is called the number of times equal to the number of
elements in the vector after the erased elements.

\pnum
\throws
Nothing unless an exception is thrown by the
copy constructor or assignment operator of
\tcode{T}.
\end{itemdescr}

\rSec3[lib.vector.special]{\tcode{vector} specialized algorithms}

\indexlibrary{\idxcode{swap}!\idxcode{vector}}%
\indexlibrary{\idxcode{vector}!\idxcode{swap}}%
\begin{itemdecl}
template <class T, class Allocator>
  void swap(vector<T,Allocator>& x, vector<T,Allocator>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
    x.swap(y);
\end{codeblock}
\end{itemdescr}

\rSec2[lib.vector.bool]{Class \tcode{vector<bool>}}

\pnum
\indexlibrary{\idxcode{vector<bool>}}%
To optimize space allocation, a specialization of vector for
\tcode{bool}
elements is provided:

\begin{codeblock}
namespace std {
  template <class Allocator> class vector<bool, Allocator> {
  public:
    // types:
    typedef bool                                  const_reference;
    typedef @\impdef@                iterator;       // see \ref{lib.container.requirements}
    typedef @\impdef@                const_iterator; // see \ref{lib.container.requirements}
    typedef @\impdef@                size_type;      // see \ref{lib.container.requirements}
    typedef @\impdef@                difference_type;// see \ref{lib.container.requirements}
    typedef bool                                  value_type;
    typedef Allocator                             allocator_type;
    typedef @\impdef@                pointer;
    typedef @\impdef@                const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    // bit reference:
    class reference {
      friend class vector;
      reference();
    public:
     ~reference();
      operator bool() const;
      reference& operator=(const bool x);
      reference& operator=(const reference& x);
      void flip();              // flips the bit
    };

    // construct/copy/destroy:
    explicit vector(const Allocator& = Allocator());
    explicit vector(size_type n, const bool& value = bool(),
                    const Allocator& = Allocator());
    template <class InputIterator>
      vector(InputIterator first, InputIterator last,
        const Allocator& = Allocator());
    vector(const vector<bool,Allocator>& x);
   ~vector();
    vector<bool,Allocator>& operator=(const vector<bool,Allocator>& x);
    template <class InputIterator>
      void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const T& t);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;
    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    // capacity:
    size_type size() const;
    size_type max_size() const;
    void      resize(size_type sz, bool c = false);
    size_type capacity() const;
    bool      empty() const;
    void      reserve(size_type n);

    // element access:
    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    const_reference at(size_type n) const;
    reference       at(size_type n);
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    // modifiers:
    void push_back(const bool& x);
    void pop_back();
    iterator insert(iterator position, const bool& x);
    void     insert (iterator position, size_type n, const bool& x);
    template <class InputIterator>
        void insert(iterator position,
                    InputIterator first, InputIterator last);

    iterator erase(iterator position);
    iterator erase(iterator first, iterator last);
    void swap(vector<bool,Allocator>&);
    static void swap(reference x, reference y);
    void flip();                // flips all bits
    void clear();
  };

  template <class Allocator>
    bool operator==(const vector<bool,Allocator>& x,
                    const vector<bool,Allocator>& y);
  template <class Allocator>
    bool operator< (const vector<bool,Allocator>& x,
                    const vector<bool,Allocator>& y);
  template <class Allocator>
    bool operator!=(const vector<bool,Allocator>& x,
                    const vector<bool,Allocator>& y);
  template <class Allocator>
    bool operator> (const vector<bool,Allocator>& x,
                    const vector<bool,Allocator>& y);
  template <class Allocator>
    bool operator>=(const vector<bool,Allocator>& x,
                    const vector<bool,Allocator>& y);
  template <class Allocator>
    bool operator<=(const vector<bool,Allocator>& x,
                    const vector<bool,Allocator>& y);

  // specialized algorithms:
  template <class Allocator>
    void swap(vector<bool,Allocator>& x, vector<bool,Allocator>& y);
}
\end{codeblock}%

\pnum
\tcode{reference}
is a class that simulates the behavior of references of a single bit in
\tcode{vector<bool>}.

\rSec1[lib.associative]{Associative containers}

\pnum
Headers \tcode{<map>} and \tcode{<set>}:

\synopsis{Header \tcode{<map>} synopsis}%
\indexlibrary{\idxhdr{map}}

\begin{codeblock}
namespace std {
  template <class Key, class T, class Compare = less<Key>,
            class Allocator = allocator<pair<const Key, T> > >
    class map;
  template <class Key, class T, class Compare, class Allocator>
    bool operator==(const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator< (const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator!=(const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator> (const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator>=(const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator<=(const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    void swap(map<Key,T,Compare,Allocator>& x,
              map<Key,T,Compare,Allocator>& y);

  template <class Key, class T, class Compare = less<Key>,
            class Allocator = allocator<pair<const Key, T> > >
    class multimap;
  template <class Key, class T, class Compare, class Allocator>
    bool operator==(const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator< (const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator!=(const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator> (const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator>=(const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator<=(const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    void swap(multimap<Key,T,Compare,Allocator>& x,
              multimap<Key,T,Compare,Allocator>& y);
}
\end{codeblock}

\synopsis{Header \tcode{<set>} synopsis}%
\indexlibrary{\idxhdr{set}}

\begin{codeblock}
namespace std {
  template <class Key, class Compare = less<Key>,
            class Allocator = allocator<Key> >
    class set;
  template <class Key, class Compare, class Allocator>
    bool operator==(const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator< (const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator!=(const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator> (const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator>=(const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator<=(const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);
  template <class Key, class Compare, class Allocator>
    void swap(set<Key,Compare,Allocator>& x,
              set<Key,Compare,Allocator>& y);

  template <class Key, class Compare = less<Key>,
            class Allocator = allocator<Key> >
    class multiset;
  template <class Key, class Compare, class Allocator>
    bool operator==(const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator< (const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator!=(const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator> (const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator>=(const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator<=(const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);
  template <class Key, class Compare, class Allocator>
    void swap(multiset<Key,Compare,Allocator>& x,
              multiset<Key,Compare,Allocator>& y);
}
\end{codeblock}

\rSec2[lib.map]{Class template \tcode{map}}

\indexlibrary{\idxcode{map}}%
\pnum
A \tcode{map} is a kind of associative container that
supports unique keys (contains at most one of each key value) and
provides for fast retrieval of values of another type \tcode{T} based
on the keys. The \tcode{map} class supports bidirectional iterators.

\pnum
A
\tcode{map}
satisfies all of the requirements of a container and of a reversible container~(\ref{lib.container.requirements}) and of
an associative container~(\ref{lib.associative.reqmts}).
A
\tcode{map}
also provides most operations described in~(\ref{lib.associative.reqmts})
for unique keys.
This means that a
\tcode{map}
supports the
\tcode{a_uniq}
operations in~(\ref{lib.associative.reqmts})
but not the
\tcode{a_eq}
operations.
For a
\tcode{map<Key,T>}
the
\tcode{key_type}
is
\tcode{Key}
and the
\tcode{value_type}
is
\tcode{pair<const Key,T>}.
Descriptions are provided here only for operations on
\tcode{map}
that are not described in one of those tables
or for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template <class Key, class T, class Compare = less<Key>,
            class Allocator = allocator<pair<const Key, T> > >
  class map {
  public:
    // types:
    typedef Key                                   key_type;
    typedef T                                     mapped_type;
    typedef pair<const Key, T>                    value_type;
    typedef Compare                               key_compare;
    typedef Allocator                             allocator_type;
    typedef typename Allocator::reference         reference;
    typedef typename Allocator::const_reference   const_reference;
    typedef @\impdef@                iterator;       // see \ref{lib.container.requirements}
    typedef @\impdef@                const_iterator; // see \ref{lib.container.requirements}
    typedef @\impdef@                size_type;      // see \ref{lib.container.requirements}
    typedef @\impdef@                difference_type;// see \ref{lib.container.requirements}
    typedef typename Allocator::pointer           pointer;
    typedef typename Allocator::const_pointer     const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    class value_compare
      : public binary_function<value_type,value_type,bool> {
    friend class map;
    protected:
      Compare comp;
      value_compare(Compare c) : comp(c) {}
    public:
      bool operator()(const value_type& x, const value_type& y) const {
        return comp(x.first, y.first);
      }
    };

    // \ref{lib.map.cons}, construct/copy/destroy:
    explicit map(const Compare& comp = Compare(),
                 const Allocator& = Allocator());
    template <class InputIterator>
      map(InputIterator first, InputIterator last,
          const Compare& comp = Compare(), const Allocator& = Allocator());
    map(const map<Key,T,Compare,Allocator>& x);
   ~map();
    map<Key,T,Compare,Allocator>&
      operator=(const map<Key,T,Compare,Allocator>& x);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;
    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    // capacity:
    bool      empty() const;
    size_type size() const;
    size_type max_size() const;

    // \ref{lib.map.access}, element access:
    T& operator[](const key_type& x);

    // modifiers:
    pair<iterator, bool> insert(const value_type& x);
    iterator             insert(iterator position, const value_type& x);
    template <class InputIterator>
      void insert(InputIterator first, InputIterator last);

    void      erase(iterator position);
    size_type erase(const key_type& x);
    void      erase(iterator first, iterator last);
    void swap(map<Key,T,Compare,Allocator>&);
    void clear();

    // observers:
    key_compare   key_comp() const;
    value_compare value_comp() const;

    // \ref{lib.map.ops}, map operations:
    iterator       find(const key_type& x);
    const_iterator find(const key_type& x) const;
    size_type      count(const key_type& x) const;

    iterator       lower_bound(const key_type& x);
    const_iterator lower_bound(const key_type& x) const;
    iterator       upper_bound(const key_type& x);
    const_iterator upper_bound(const key_type& x) const;

    pair<iterator,iterator>
      equal_range(const key_type& x);
    pair<const_iterator,const_iterator>
      equal_range(const key_type& x) const;
  };

  template <class Key, class T, class Compare, class Allocator>
    bool operator==(const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator< (const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator!=(const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator> (const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator>=(const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator<=(const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);

  // specialized algorithms:
  template <class Key, class T, class Compare, class Allocator>
    void swap(map<Key,T,Compare,Allocator>& x,
              map<Key,T,Compare,Allocator>& y);
}
\end{codeblock}


\rSec3[lib.map.cons]{\tcode{map} constructors, copy, and assignment}%
\indexlibrary{\idxcode{map}!\idxcode{operator==}}%
\indexlibrary{\idxcode{map}!\idxcode{operator<}}

\indexlibrary{\idxcode{map}!\idxcode{map}}%
\indexlibrary{\idxcode{map}!\idxcode{map}}%
\begin{itemdecl}
explicit map(const Compare& comp = Compare(),
             const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an empty
\tcode{map}
using the specified comparison object and allocator.

\pnum
\complexity
Constant.
\end{itemdescr}

\indexlibrary{\idxcode{map}!constructor}%
\begin{itemdecl}
template <class InputIterator>
  map(InputIterator first, InputIterator last,
      const Compare& comp = Compare(), const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an empty
\tcode{map}
using the specified comparison object and allocator,
and inserts elements from the range
\range{first}{last}.

\pnum
\complexity
Linear in \tcode{N} if the range
\range{first}{last}
is already sorted using \tcode{comp}
and otherwise \tcode{N log N}, where \tcode{N}
is \tcode{last} - \tcode{first}.
\end{itemdescr}

\rSec3[lib.map.access]{\tcode{map} element access}

\indexlibrary{\idxcode{operator[]}!\idxcode{map}}%
\begin{itemdecl}
T& operator[](const key_type& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{(*((insert(make_pair(x, T()))).first)).second}.
\end{itemdescr}

\rSec3[lib.map.ops]{\tcode{map} operations}

\indexlibrary{\idxcode{find}!\idxcode{map}}%
\indexlibrary{\idxcode{map}!\idxcode{find}}%
\begin{itemdecl}
iterator       find(const key_type& x);
const_iterator find(const key_type& x) const;

iterator       lower_bound(const key_type& x);
const_iterator lower_bound(const key_type& x) const;

iterator       upper_bound(const key_type& x);
const_iterator upper_bound(const key_type &x) const;

pair<iterator, iterator>
  equal_range(const key_type &x);
pair<const_iterator, const_iterator>
  equal_range(const key_type& x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
The
\tcode{find},
\tcode{lower_bound},
\tcode{upper_bound}
and
\tcode{equal_range}
member functions each have two versions,
one const and the other non-const.
In each case the behavior of the two functions is identical
except that the const version returns a
\tcode{const_iterator}
and the non-const version an
\tcode{iterator}~(\ref{lib.associative.reqmts}).
\end{itemdescr}

\rSec3[lib.map.special]{\tcode{map} specialized algorithms}

\indexlibrary{\idxcode{swap}!\idxcode{map}}%
\indexlibrary{\idxcode{map}!\idxcode{swap}}%
\begin{itemdecl}
template <class Key, class T, class Compare, class Allocator>
  void swap(map<Key,T,Compare,Allocator>& x,
            map<Key,T,Compare,Allocator>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
    x.swap(y);
\end{codeblock}
\end{itemdescr}

\rSec2[lib.multimap]{Class template \tcode{multimap}}

\pnum
\indexlibrary{\idxcode{multimap}}%
A
\tcode{multimap}
is a kind of associative container that supports equivalent keys (possibly containing multiple copies of
the same key value) and provides for fast retrieval of values of another type
\tcode{T}
based on the keys.
The
\tcode{multimap}
class
supports bidirectional iterators.

\pnum
A
\tcode{multimap} satisfies all of the requirements of a container and of a
reversible container~(\ref{lib.container.requirements}) and of an associative
container~(\ref{lib.associative.reqmts}).
A
\tcode{multimap}
also provides most operations described in~(\ref{lib.associative.reqmts})
for equal keys.
This means that a
\tcode{multimap}
supports the
\tcode{a_eq}
operations in~(\ref{lib.associative.reqmts})
but not the
\tcode{a_uniq}
operations.
For a
\tcode{multimap<Key,T>}
the
\tcode{key_type}
is
\tcode{Key}
and the
\tcode{value_type}
is
\tcode{pair<const Key,T>}.
Descriptions are provided here only for operations on
\tcode{multimap}
that are not described in one of those tables
or for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template <class Key, class T, class Compare = less<Key>,
            class Allocator = allocator<pair<const Key, T> > >
  class multimap {
  public:
    // types:
    typedef Key                                   key_type;
    typedef T                                     mapped_type;
    typedef pair<const Key,T>                     value_type;
    typedef Compare                               key_compare;
    typedef Allocator                             allocator_type;
    typedef typename Allocator::reference         reference;
    typedef typename Allocator::const_reference   const_reference;
    typedef @\impdef@                iterator;       // see \ref{lib.container.requirements}
    typedef @\impdef@                const_iterator; // see \ref{lib.container.requirements}
    typedef @\impdef@                size_type;      // see \ref{lib.container.requirements}
    typedef @\impdef@                difference_type;// see \ref{lib.container.requirements}
    typedef typename Allocator::pointer           pointer;
    typedef typename Allocator::const_pointer     const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    class value_compare
      : public binary_function<value_type,value_type,bool> {
    friend class multimap;
    protected:
      Compare comp;
      value_compare(Compare c) : comp(c) {}
    public:
      bool operator()(const value_type& x, const value_type& y) const {
        return comp(x.first, y.first);
      }
    };

    // construct/copy/destroy:
    explicit multimap(const Compare& comp = Compare(),
                      const Allocator& = Allocator());
    template <class InputIterator>
      multimap(InputIterator first, InputIterator last,
               const Compare& comp = Compare(),
               const Allocator& = Allocator());
    multimap(const multimap<Key,T,Compare,Allocator>& x);
   ~multimap();
    multimap<Key,T,Compare,Allocator>&
      operator=(const multimap<Key,T,Compare,Allocator>& x);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;
    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    // capacity:
    bool           empty() const;
    size_type      size() const;
    size_type      max_size() const;

    // modifiers:
    iterator insert(const value_type& x);
    iterator insert(iterator position, const value_type& x);
    template <class InputIterator>
      void insert(InputIterator first, InputIterator last);

    void      erase(iterator position);
    size_type erase(const key_type& x);
    void      erase(iterator first, iterator last);
    void swap(multimap<Key,T,Compare,Allocator>&);
    void clear();

    // observers:
    key_compare    key_comp() const;
    value_compare  value_comp() const;

    // map operations:
    iterator       find(const key_type& x);
    const_iterator find(const key_type& x) const;
    size_type      count(const key_type& x) const;

    iterator       lower_bound(const key_type& x);
    const_iterator lower_bound(const key_type& x) const;
    iterator       upper_bound(const key_type& x);
    const_iterator upper_bound(const key_type& x) const;

    pair<iterator,iterator>
      equal_range(const key_type& x);
    pair<const_iterator,const_iterator>
      equal_range(const key_type& x) const;
  };

  template <class Key, class T, class Compare, class Allocator>
    bool operator==(const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator< (const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator!=(const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator> (const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator>=(const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator<=(const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);

  // specialized algorithms:
  template <class Key, class T, class Compare, class Allocator>
    void swap(multimap<Key,T,Compare,Allocator>& x,
              multimap<Key,T,Compare,Allocator>& y);
}
\end{codeblock}%
\indexlibrary{\idxcode{multimap}!\idxcode{operator==}}%
\indexlibrary{\idxcode{multimap}!\idxcode{operator<}}

\rSec3[lib.multimap.cons]{\tcode{multimap} constructors}

\indexlibrary{\idxcode{multimap}!\idxcode{multimap}}%
\indexlibrary{\idxcode{multimap}!\idxcode{multimap}}%
\begin{itemdecl}
explicit multimap(const Compare& comp = Compare(),
                  const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an empty
\tcode{multimap}
using the specified comparison object and allocator.

\pnum
\complexity
Constant.
\end{itemdescr}

\indexlibrary{\idxcode{multimap}!\idxcode{multimap}}%
\indexlibrary{\idxcode{multimap}!\idxcode{multimap}}%
\begin{itemdecl}
template <class InputIterator>
  multimap(InputIterator first, InputIterator last,
           const Compare& comp = Compare(),
           const Allocator& = Allocator()0;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an empty
\tcode{multimap}
using the specified comparison object and allocator,
and inserts elements from the range
\range{first}{last}.

\pnum
\complexity
Linear in \tcode{N} if the range
\range{first}{last}.
is already sorted using \tcode{comp}
and otherwise \tcode{N log N},
where \tcode{N} is
\tcode{last - first}.
\end{itemdescr}

\rSec3[lib.multimap.ops]{\tcode{multimap} operations}

\indexlibrary{\idxcode{find}!\idxcode{multimap}}%
\indexlibrary{\idxcode{multimap}!\idxcode{find}}%
\begin{itemdecl}
iterator       find(const key_type &x);
const_iterator find(const key_type& x) const;

iterator       lower_bound(const key_type& x);
const_iterator lower_bound(const key_type& x) const;

pair<iterator, iterator>
  equal_range(const key_type& x);
pair<const_iterator, const_iterator>
  equal_range(const key_type& x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
The
\tcode{find},
\tcode{lower_bound},
\tcode{upper_bound},
and
\tcode{equal_range}
member functions each have two versions, one const and one non-const.
In each case the behavior of the two versions is identical
except that the const version returns a
\tcode{const_iterator}
and the non-const version an
\tcode{iterator}~(\ref{lib.associative.reqmts}).
\end{itemdescr}

\rSec3[lib.multimap.special]{\tcode{multimap} specialized algorithms}

\indexlibrary{\idxcode{swap}!\idxcode{multimap}}%
\indexlibrary{\idxcode{multimap}!\idxcode{swap}}%
\begin{itemdecl}
template <class Key, class T, class Compare, class Allocator>
  void swap(multimap<Key,T,Compare,Allocator>& x,
            multimap<Key,T,Compare,Allocator>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
    x.swap(y);
\end{codeblock}
\end{itemdescr}

\rSec2[lib.set]{Class template \tcode{set}}

\pnum
\indexlibrary{\idxcode{set}}%
A
\tcode{set}
is a kind of associative container that supports unique keys (contains at most one of each key value) and
provides for fast retrieval of the keys themselves.
Class
\tcode{set}
supports bidirectional iterators.

\pnum
A \tcode{set} satisfies all of the requirements of a container and of a reversible
container~(\ref{lib.container.requirements}), and of an associative
container~(\ref{lib.associative.reqmts}).
A
\tcode{set}
also provides most operations described in~(\ref{lib.associative.reqmts})
for unique keys.
This means that a
\tcode{set}
supports the
\tcode{a_uniq}
operations in~(\ref{lib.associative.reqmts})
but not the
\tcode{a_eq}
operations.
For a
\tcode{set<Key>}
both the
\tcode{key_type}
and
\tcode{value_type}
are
\tcode{Key}.
Descriptions are provided here only for operations on
\tcode{set}
that are not described in one of these tables
and for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template <class Key, class Compare = less<Key>,
            class Allocator = allocator<Key> >
  class set {
  public:
    // types:
    typedef Key                                   key_type;
    typedef Key                                   value_type;
    typedef Compare                               key_compare;
    typedef Compare                               value_compare;
    typedef Allocator                             allocator_type;
    typedef typename Allocator::reference         reference;
    typedef typename Allocator::const_reference   const_reference;
    typedef @\impdef@                iterator;       // See \ref{lib.container.requirements}
    typedef @\impdef@                const_iterator; // See \ref{lib.container.requirements}
    typedef @\impdef@                size_type;      // See \ref{lib.container.requirements}
    typedef @\impdef@                difference_type;// See \ref{lib.container.requirements}
    typedef typename Allocator::pointer           pointer;
    typedef typename Allocator::const_pointer     const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    // \ref{lib.set.cons}, construct/copy/destroy:
    explicit set(const Compare& comp = Compare(),
                 const Allocator& = Allocator());
    template <class InputIterator>
      set(InputIterator first, InputIterator last,
          const Compare& comp = Compare(), const Allocator& = Allocator());
    set(const set<Key,Compare,Allocator>& x);
   ~set();
    set<Key,Compare,Allocator>& operator=
      (const set<Key,Compare,Allocator>& x);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;
    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    // capacity:
    bool          empty() const;
    size_type     size() const;
    size_type     max_size() const;

    // modifiers:
    pair<iterator,bool> insert(const value_type& x);
    iterator            insert(iterator position, const value_type& x);
    template <class InputIterator>
        void insert(InputIterator first, InputIterator last);

    void      erase(iterator position);
    size_type erase(const key_type& x);
    void      erase(iterator first, iterator last);
    void swap(set<Key,Compare,Allocator>&);
    void clear();

    // observers:
    key_compare   key_comp() const;
    value_compare value_comp() const;

    // set operations:
    iterator  find(const key_type& x) const;
    size_type count(const key_type& x) const;

    iterator  lower_bound(const key_type& x) const;
    iterator  upper_bound(const key_type& x) const;
    pair<iterator,iterator> equal_range(const key_type& x) const;
  };

  template <class Key, class Compare, class Allocator>
    bool operator==(const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator< (const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator!=(const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator> (const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator>=(const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator<=(const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);

  // specialized algorithms:
  template <class Key, class Compare, class Allocator>
    void swap(set<Key,Compare,Allocator>& x,
              set<Key,Compare,Allocator>& y);
}
\end{codeblock}%
\indexlibrary{\idxcode{set}!\idxcode{operator==}}%
\indexlibrary{\idxcode{set}!\idxcode{operator<}}

\rSec3[lib.set.cons]{\tcode{set} constructors, copy, and assignment}

\indexlibrary{\idxcode{set}!\idxcode{set}}%
\indexlibrary{\idxcode{set}!\idxcode{set}}%
\begin{itemdecl}
explicit set(const Compare& comp = Compare(),
             const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an empty set using the specified comparison objects and allocator.

\pnum
\complexity
Constant.
\end{itemdescr}

\indexlibrary{\idxcode{set}!\idxcode{set}}%
\indexlibrary{\idxcode{set}!\idxcode{set}}%
\begin{itemdecl}
template <class InputIterator>
  set(InputIterator first, last,
      const Compare& comp = Compare(), const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an empty
\tcode{set}
using the specified comparison object and allocator,
and inserts elements from the range
\range{first}{last}.

\pnum
\complexity
Linear in \tcode{N} if the range
\range{first}{last}
is already sorted using \tcode{comp}
and otherwise \tcode{N log N},
where \tcode{N} is
\tcode{last - first}.
\end{itemdescr}

\rSec3[lib.set.special]{\tcode{set} specialized algorithms}

\indexlibrary{\idxcode{swap}!\idxcode{set}}%
\indexlibrary{\idxcode{set}!\idxcode{swap}}%
\begin{itemdecl}
template <class Key, class Compare, class Allocator>
  void swap(set<Key,Compare,Allocator>& x,
            set<Key,Compare,Allocator>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
    x.swap(y);
\end{codeblock}
\end{itemdescr}

\rSec2[lib.multiset]{Class template \tcode{multiset}}

\pnum
\indexlibrary{\idxcode{multiset}}%
A
\tcode{multiset}
is a kind of associative container that supports equivalent keys (possibly contains multiple copies of
the same key value) and provides for fast retrieval of the keys themselves.
Class
\tcode{multiset}
supports bidirectional iterators.

\pnum
A \tcode{multiset} satisfies all of the requirements of a container and of a
reversible container~(\ref{lib.container.requirements}), and of an associative
container~(\ref{lib.associative.reqmts}).
\tcode{multiset}
also provides most operations described in~(\ref{lib.associative.reqmts})
for duplicate keys.
This means that a
\tcode{multiset}
supports the
\tcode{a_eq}
operations in~(\ref{lib.associative.reqmts})
but not the
\tcode{a_uniq}
operations.
For a
\tcode{multiset<Key>}
both the
\tcode{key_type}
and
\tcode{value_type}
are
\tcode{Key}.
Descriptions are provided here only for operations on
\tcode{multiset}
that are not described in one of these tables
and for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template <class Key, class Compare = less<Key>,
            class Allocator = allocator<Key> >
  class multiset {
  public:
    // types:
    typedef Key                                   key_type;
    typedef Key                                   value_type;
    typedef Compare                               key_compare;
    typedef Compare                               value_compare;
    typedef Allocator                             allocator_type;
    typedef typename Allocator::reference         reference;
    typedef typename Allocator::const_reference   const_reference;
    typedef @\impdef@                iterator;       // see \ref{lib.container.requirements}
    typedef @\impdef@                const_iterator; // see \ref{lib.container.requirements}
    typedef @\impdef@                size_type;      // see \ref{lib.container.requirements}
    typedef @\impdef@                difference_type;// see \ref{lib.container.requirements}
    typedef typename Allocator::pointer           pointer;
    typedef typename Allocator::const_pointer     const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    // construct/copy/destroy:
    explicit multiset(const Compare& comp = Compare(),
                      const Allocator& = Allocator());
    template <class InputIterator>
      multiset(InputIterator first, InputIterator last,
               const Compare& comp = Compare(),
               const Allocator& = Allocator());
    multiset(const multiset<Key,Compare,Allocator>& x);
   ~multiset();
    multiset<Key,Compare,Allocator>&
        operator=(const multiset<Key,Compare,Allocator>& x);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;
    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    // capacity:
    bool          empty() const;
    size_type     size() const;
    size_type     max_size() const;

    // modifiers:
    iterator insert(const value_type& x);
    iterator insert(iterator position, const value_type& x);
    template <class InputIterator>
      void insert(InputIterator first, InputIterator last);

    void      erase(iterator position);
    size_type erase(const key_type& x);
    void      erase(iterator first, iterator last);
    void swap(multiset<Key,Compare,Allocator>&);
    void clear();

    // observers:
    key_compare   key_comp() const;
    value_compare value_comp() const;

    // set operations:
    iterator  find(const key_type& x) const;
    size_type count(const key_type& x) const;

    iterator  lower_bound(const key_type& x) const;
    iterator  upper_bound(const key_type& x) const;
    pair<iterator,iterator> equal_range(const key_type& x) const;
  };

  template <class Key, class Compare, class Allocator>
    bool operator==(const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator< (const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator!=(const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator> (const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator>=(const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator<=(const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);

  // specialized algorithms:
  template <class Key, class Compare, class Allocator>
    void swap(multiset<Key,Compare,Allocator>& x,
              multiset<Key,Compare,Allocator>& y);
}
\end{codeblock}%
\indexlibrary{\idxcode{multiset}!\idxcode{operator==}}%
\indexlibrary{\idxcode{multiset}!\idxcode{operator<}}

\rSec3[lib.multiset.cons]{\tcode{multiset} constructors}

\indexlibrary{\idxcode{multiset}!\idxcode{multiset}}%
\indexlibrary{\idxcode{multiset}!\idxcode{multiset}}%
\begin{itemdecl}
explicit multiset(const Compare& comp = Compare(),
                  const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an empty set using the specified comparison object and allocator.

\pnum
\complexity
Constant.
\end{itemdescr}

\indexlibrary{\idxcode{multiset}!\idxcode{multiset}}%
\indexlibrary{\idxcode{multiset}!\idxcode{multiset}}%
\begin{itemdecl}
template <class InputIterator>
  multiset(InputIterator first, last,
           const Compare& comp = Compare(), const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an empty
\tcode{multiset}
using the specified comparison object and allocator,
and inserts elements from the range
\range{first}{last}.

\pnum
\complexity
Linear in \tcode{N}
if the range
\range{first}{last}
is already sorted using \tcode{comp} and otherwise \tcode{N log N},
where \tcode{N} is
\tcode{last - first}.
\end{itemdescr}

\rSec3[lib.multiset.special]{\tcode{multiset} specialized algorithms}

\indexlibrary{\idxcode{swap}!\idxcode{multiset}}%
\indexlibrary{\idxcode{multiset}!\idxcode{swap}}%
\begin{itemdecl}
template <class Key, class Compare, class Allocator>
  void swap(multiset<Key,Compare,Allocator>& x,
            multiset<Key,Compare,Allocator>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
    x.swap(y);
\end{codeblock}
\end{itemdescr}

\rSec2[lib.template.bitset]{Class template \tcode{bitset}}%
\indexlibrary{\idxcode{bitset}}

\synopsis{Header \tcode{<bitset>} synopsis}%
\indexlibrary{\idxhdr{bitset}}

\begin{codeblock}
#include <cstddef>              // for \tcode{size_t}
#include <string>
#include <stdexcept>            // for \tcode{invalid_argument},
                                //       \tcode{out_of_range}, \tcode{overflow_error}
#include <iosfwd>               // for \tcode{istream}, \tcode{ostream}
namespace std {
  template <size_t N> class bitset;

  // \ref{lib.bitset.operators} bitset operators:
  template <size_t N>
    bitset<N> operator&(const bitset<N>&, const bitset<N>&);
  template <size_t N>
    bitset<N> operator|(const bitset<N>&, const bitset<N>&);
  template <size_t N>
    bitset<N> operator^(const bitset<N>&, const bitset<N>&);
  template <class charT, class traits, size_t N>
    basic_istream<charT, traits>&
    operator>>(basic_istream<charT, traits>& is, bitset<N>& x);
  template <class charT, class traits, size_t N>
    basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, const bitset<N>& x);
}
\end{codeblock}

\pnum
The header
\tcode{<bitset>}
defines a
class template
and several related functions for representing
and manipulating fixed-size sequences of bits.

\begin{codeblock}
namespace std {
  template<size_t N> class bitset {
  public:
    // bit reference:
    class reference {
      friend class bitset;
      reference();
    public:
     ~reference();
      reference& operator=(bool x);             // for \tcode{b[i] = x;}
      reference& operator=(const reference&);   // for \tcode{b[i] = b[j];}
      bool operator~() const;                   // flips the bit
      operator bool() const;                    // for \tcode{x = b[i];}
      reference& flip();                        // for \tcode{b[i].flip();}
    };

    // \ref{lib.bitset.cons} constructors:
    bitset();
    bitset(unsigned long val);
    template<class charT, class traits, class Allocator>
      explicit bitset(
        const basic_string<charT,traits,Allocator>& str,
        typename basic_string<charT,traits,Allocator>::size_type pos = 0,
        typename basic_string<charT,traits,Allocator>::size_type n =
          basic_string<charT,traits,Allocator>::npos);

    // \ref{lib.bitset.members} bitset operations:
    bitset<N>& operator&=(const bitset<N>& rhs);
    bitset<N>& operator|=(const bitset<N>& rhs);
    bitset<N>& operator^=(const bitset<N>& rhs);
    bitset<N>& operator<<=(size_t pos);
    bitset<N>& operator>>=(size_t pos);
    bitset<N>& set();
    bitset<N>& set(size_t pos, int val = true);
    bitset<N>& reset();
    bitset<N>& reset(size_t pos);
    bitset<N>  operator~() const;
    bitset<N>& flip();
    bitset<N>& flip(size_t pos);

    // element access:
    bool operator[](size_t pos) const;        // for \tcode{b[i];}
    reference operator[](size_t pos);         // for \tcode{b[i];}

    unsigned long  to_ulong() const;
    template <class charT, class traits, class Allocator>
      basic_string<charT, traits, Allocator> to_string() const;
    size_t count() const;
    size_t size()  const;
    bool operator==(const bitset<N>& rhs) const;
    bool operator!=(const bitset<N>& rhs) const;
    bool test(size_t pos) const;
    bool all() const;
    bool none() const;
    bitset<N> operator<<(size_t pos) const;
    bitset<N> operator>>(size_t pos) const;
  };
}
\end{codeblock}

\pnum
The template class
\tcode{bitset<N>}%
describes an object that can store a sequence consisting of a fixed number of
bits, \tcode{N}.

\pnum
Each bit represents either the value zero (reset) or one (set).
To
\term{toggle}
a bit is to change the value zero to one, or the value one to
zero.
Each bit has a non-negative position \tcode{pos}.
When converting
between an object of class
\tcode{bitset<N>}
and a value of some
integral type, bit position \tcode{pos} corresponds to the
\term{bit value}
\tcode{1 \shl{} pos}.
The integral value corresponding to two
or more bits is the sum of their bit values.

\pnum
The functions described in this subclause can report three kinds of
errors, each associated with a distinct exception:

\begin{itemize}
\item
an
\term{invalid-argument}
error is associated with exceptions of type
\tcode{invalid_argument}~(\ref{lib.invalid.argument});
\indexlibrary{\idxcode{invalid_argument}}%
\item
an
\term{out-of-range}
error is associated with exceptions of type
\tcode{out_of_range}~(\ref{lib.out.of.range});
\indexlibrary{\idxcode{out_of_range}}%
\item
an
\term{overflow}
error is associated with exceptions of type
\tcode{overflow_error}~(\ref{lib.overflow.error}).
\indexlibrary{\idxcode{overflow_error}}%
\end{itemize}

\rSec3[lib.bitset.cons]{\tcode{bitset} constructors}

\indexlibrary{\idxcode{bitset}!\idxcode{bitset}}%
\begin{itemdecl}
bitset();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{bitset<N>},
initializing all bits to zero.
\end{itemdescr}

\indexlibrary{\idxcode{bitset}!\idxcode{bitset}}
\indexlibrary{\idxcode{bitset}!\idxcode{bitset}}
\begin{itemdecl}
bitset(unsigned long val);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{bitset<N>},
initializing the first \tcode{M} bit positions to the corresponding bit
values in \tcode{val}.
\tcode{M} is the smaller of \tcode{N} and the value
\tcode{CHAR_BIT * sizeof (unsigned long)}.\footnote{The macro
\tcode{CHAR_BIT} is defined in \tcode{<climits>}~(\ref{lib.support.limits}).}

If \tcode{M < N}, remaining bit positions are initialized to zero.
\end{itemdescr}

\indexlibrary{\idxcode{bitset}!\idxcode{bitset}}
\indexlibrary{\idxcode{bitset}!\idxcode{bitset}}
\begin{itemdecl}
template <class charT, class traits, class Allocator>
explicit
bitset(const basic_string<charT, traits, Allocator>& str,
       typename basic_string<charT, traits, Allocator>::size_type pos = 0,
       typename basic_string<charT, traits, Allocator>::size_type n =
         basic_string<charT, traits, Allocator>::npos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos <= str.size()}.

\pnum
\throws
\tcode{out_of_range}
if
\tcode{pos > str.size()}.%
\indexlibrary{\idxcode{out_of_range}}

\pnum
\effects
Determines the effective length
\tcode{rlen} of the initializing string as the smaller of
\tcode{n} and
\tcode{str.size() - pos}.

The function then throws%
\indexlibrary{\idxcode{invalid_argument}}
\tcode{invalid_argument}
if any of the \tcode{rlen}
characters in \tcode{str} beginning at position \tcode{pos} is
other than \tcode{0} or \tcode{1}.

Otherwise, the function constructs an object of class
\tcode{bitset<N>},
initializing the first \tcode{M} bit
positions to values determined from the corresponding characters in the string
\tcode{str}.
\tcode{M} is the smaller of \tcode{N} and \tcode{rlen}.

\pnum
An element of the constructed string has value zero if the
corresponding character in \tcode{str}, beginning at position
\tcode{pos}, is
\tcode{0}.
Otherwise, the element has the value one.
Character position \tcode{pos + M - 1} corresponds to bit position zero.
Subsequent decreasing character positions correspond to increasing bit positions.

\pnum
If \tcode{M < N}, remaining bit positions are initialized to zero.
\end{itemdescr}


\rSec3[lib.bitset.members]{\tcode{bitset} members}

\indexlibrary{\idxcode{operator\&=}!\idxcode{bitset}}%
\begin{itemdecl}
bitset<N>& operator&=(const bitset<N>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Clears each bit in
\tcode{*this}
for which the corresponding bit in \tcode{rhs} is clear, and leaves all other bits unchanged.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator"|=}!\idxcode{bitset}}%
\begin{itemdecl}
bitset<N>& operator|=(const bitset<N>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Sets each bit in
\tcode{*this}
for which the corresponding bit in \tcode{rhs} is set, and leaves all other bits unchanged.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator\^{}=}!\idxcode{bitset}}%
\begin{itemdecl}
bitset<N>& operator^=(const bitset<N>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Toggles each bit in
\tcode{*this}
for which the corresponding bit in \tcode{rhs} is set, and leaves all other bits unchanged.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{operator<<=@\tcode{operator\shl=}!\idxcode{bitset}}%
\begin{itemdecl}
bitset<N>& operator<<=(size_t pos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Replaces each bit at position \tcode{I} in
\tcode{*this}
with a value determined as follows:

\begin{itemize}
\item
If \tcode{I < pos}, the new value is zero;
\item
If \tcode{I >= pos}, the new value is the previous
value of the bit at position \tcode{I - pos}.
\end{itemize}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{operator>>=@\tcode{operator\shr=}!\idxcode{bitset}}%
\begin{itemdecl}
bitset<N>& operator>>=(size_t pos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Replaces each bit at position \tcode{I} in
\tcode{*this}
with a value determined as follows:

\begin{itemize}
\item
If \tcode{pos >= N - I}, the new value is zero;
\item
If \tcode{pos < N - I}, the new value is the previous value of the bit at position \tcode{I + pos}.
\end{itemize}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{set}!\idxcode{bitset}}
\indexlibrary{\idxcode{bitset}!\idxcode{set}}
\begin{itemdecl}
bitset<N>& set();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Sets all bits in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{set}!\idxcode{bitset}}
\indexlibrary{\idxcode{bitset}!\idxcode{set}}
\begin{itemdecl}
bitset<N>& set(size_t pos, int val = 1);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos} is valid

\pnum
\throws
\tcode{out_of_range}
if \tcode{pos} does not correspond to a valid bit position.%
\indexlibrary{\idxcode{out_of_range}}

\pnum
\effects
Stores a new value in the bit at position \tcode{pos} in
\tcode{*this}.
If \tcode{val} is nonzero, the stored value is one, otherwise it is zero.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{reset}!\idxcode{bitset}}
\indexlibrary{\idxcode{bitset}!\idxcode{reset}}
\begin{itemdecl}
bitset<N>& reset();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Resets all bits in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{reset}!\idxcode{bitset}}
\indexlibrary{\idxcode{bitset}!\idxcode{reset}}
\begin{itemdecl}
bitset<N>& reset(size_t pos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos} is valid

\pnum
\throws
\tcode{out_of_range}
if \tcode{pos} does not correspond to a valid bit position.
\indexlibrary{\idxcode{out_of_range}}%

\pnum
\effects
Resets the bit at position \tcode{pos} in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator\~{}}!\idxcode{bitset}}%
\begin{itemdecl}
bitset<N> operator~() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object \tcode{x} of class
\tcode{bitset<N>}
and initializes it with
\tcode{*this}.

\pnum
\returns
\tcode{x.flip()}.
\end{itemdescr}

\indexlibrary{\idxcode{flip}!\tcode{bitset}}%
\begin{itemdecl}
bitset<N>& flip();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Toggles all bits in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{flip}!\idxcode{bitset}}
\indexlibrary{\idxcode{bitset}!\idxcode{flip}}
\begin{itemdecl}
bitset<N>& flip(size_t pos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos} is valid

\pnum
\throws
\tcode{out_of_range}
if \tcode{pos} does not correspond to a valid bit position.%
\indexlibrary{\idxcode{out_of_range}}

\pnum
\effects
Toggles the bit at position \tcode{pos} in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{to_ulong}!\idxcode{bitset}}%
\begin{itemdecl}
unsigned long to_ulong() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\throws
\tcode{overflow_error}%
\indexlibrary{\idxcode{overflow_error}}
if the integral value \tcode{x} corresponding to the bits in
\tcode{*this}
cannot be represented as type
\tcode{unsigned long}.

\pnum
\returns
\tcode{x}.
\end{itemdescr}

\indexlibrary{\idxcode{to_string}!\idxcode{bitset}}%
\begin{itemdecl}
template <class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator> to_string() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a string object of the appropriate type
and initializes it to a string of length \tcode{N} characters.
Each character is determined by the value of its corresponding bit position in
\tcode{*this}.
Character position \tcode{N - 1} corresponds to bit position zero.
Subsequent decreasing character positions correspond to increasing bit
positions.
Bit value zero becomes the character \tcode{0},
bit value one becomes the character
\tcode{1}.

\pnum
\returns
The created object.
\end{itemdescr}

\indexlibrary{\idxcode{count}!\idxcode{bitset}}%
\begin{itemdecl}
size_t count() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A count of the number of bits set in
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{size}!\idxcode{bitset}}%
\begin{itemdecl}
size_t size() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{N}.
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{bitset}}%
\begin{itemdecl}
bool operator==(const bitset<N>& rhs) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A nonzero value if the value of each bit in
\tcode{*this}
equals the value of the corresponding bit in \tcode{rhs}.
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{bitset}}%
\begin{itemdecl}
bool operator!=(const bitset<N>& rhs) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A nonzero value if
\tcode{!(*this == rhs)}.
\end{itemdescr}

\indexlibrary{\idxcode{test}!\idxcode{bitset}}%
\begin{itemdecl}
bool test(size_t pos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos} is valid

\pnum
\throws
\tcode{out_of_range}
if \tcode{pos} does not correspond to a valid bit position.%
\indexlibrary{\idxcode{out_of_range}}

\pnum
\returns
\tcode{true}
if the bit at position \tcode{pos}
in
\tcode{*this}
has the value one.
\end{itemdescr}

\indexlibrary{\idxcode{any}!\idxcode{bitset}}%
\begin{itemdecl}
bool any() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true}
if any bit in
\tcode{*this}
is one.
\end{itemdescr}

\indexlibrary{\idxcode{none}!\idxcode{bitset}}%
\begin{itemdecl}
bool none() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true}
if no bit in
\tcode{*this}
is one.
\end{itemdescr}

\indexlibrary{operator<<@\tcode{operator\shl}!\idxcode{bitset}}%
\begin{itemdecl}
bitset<N> operator<<(size_t pos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{bitset<N>(*this) \shl= pos}.
\end{itemdescr}

\indexlibrary{operator>>@\tcode{operator\shr}!\idxcode{bitset}}%
\begin{itemdecl}
bitset<N> operator>>(size_t pos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{bitset<N>(*this) \shr= pos}.
\end{itemdescr}

\indexlibrary{\idxcode{operator[]}!\idxcode{bitset}}
\indexlibrary{\idxcode{bitset}!\idxcode{operator[]}}
\begin{itemdecl}
bool operator[](size_t pos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos} is valid.

\pnum
\throws nothing.

\pnum
\returns
\tcode{test(pos)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator[]}!\idxcode{bitset}}
\indexlibrary{\idxcode{bitset}!\idxcode{operator[]}}
\begin{itemdecl}
bitset<N>::reference operator[](size_t pos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos} is valid.

\pnum
\throws nothing.

\pnum
\returns
An object of type
\tcode{bitset<N>::reference}
such that
\tcode{(*this)[pos] == this->test(pos)},
and such that
\tcode{(*this)[pos] = val}
is equivalent to
\tcode{this->set(pos, val)}.
\end{itemdescr}

\rSec3[lib.bitset.operators]{\tcode{bitset} operators}

\indexlibrary{\idxcode{operator\&}!\idxcode{bitset}}%
\begin{itemdecl}
bitset<N> operator&(const bitset<N>& lhs, const bitset<N>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{bitset<N>(lhs) \&= rhs}.
\end{itemdescr}

\indexlibrary{\idxcode{operator"|}!\idxcode{bitset}}%
\begin{itemdecl}
bitset<N> operator|(const bitset<N>& lhs, const bitset<N>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{bitset<N>(lhs) |= rhs}.
\end{itemdescr}

\indexlibrary{\idxcode{operator\^{}}!\idxcode{bitset}}%
\begin{itemdecl}
bitset<N> operator^(const bitset<N>& lhs, const bitset<N>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{bitset<N>(lhs) \^{}= rhs}.
\end{itemdescr}

\indexlibrary{operator>>@\tcode{operator\shr}!\idxcode{bitset}}%
\begin{itemdecl}
template <class charT, class traits, size_t N>
  basic_istream<charT, traits>&
  operator>>(basic_istream<charT, traits>& is, bitset<N>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
A formatted input function~(\ref{lib.istream.formatted}).

\pnum
\effects
Extracts up to \tcode{N} (single-byte) characters from \tcode{is}.
Stores these characters in a temporary object \tcode{str} of type
\tcode{string},
then evaluates the expression
\tcode{x = bitset<N>(str)}.
Characters are extracted and stored until any of the following occurs:

\begin{itemize}
\item
\tcode{N} characters have been extracted and stored;
\item
end-of-file occurs on the input sequence;%
\indextext{end-of-file}
\item
the next input character is neither
\tcode{0}
or
\tcode{1}
(in which case the input character is not extracted).
\end{itemize}

\pnum
If no characters are stored in \tcode{str}, calls
\tcode{is.setstate(ios_base::failbit)}
(which may throw
\tcode{ios_base::failure}~(\ref{lib.iostate.flags})).

\pnum
\returns
\tcode{is}.
\end{itemdescr}

\indexlibrary{operator<<@\tcode{operator\shl}!\idxcode{bitset}}%
\begin{itemdecl}
template <class charT, class traits, size_t N>
  basic_ostream<charT, traits>&
  operator<<(basic_ostream<charT, traits>& os, const bitset<N>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{os \shl{} x.template to_string<charT,traits,allocator<charT> >()}
(\ref{lib.ostream.formatted}).
\end{itemdescr}
