\rSec0[lib.library]{Library introduction}

\pnum
This clause describes the contents of the
\term{\Cpp Standard Library},
\indextext{library!C++ standard}%
how a well-formed \Cpp program makes use of the library, and
how a conforming implementation may provide the entities in the library.

\pnum
The \Cpp Standard Library provides an extensible framework, and contains
components for: language support, diagnostics, general utilities, strings,
locales, containers, iterators, algorithms, numerics, and input/output.
The language support components are required by certain parts of the \Cpp
language, such as memory allocation~(\ref{expr.new}, \ref{expr.delete})
and exception processing (clause~\ref{except}).

\pnum
The general utilities includes components used
by other library elements, such as a predefined storage allocator for dynamic
storage management~(\ref{basic.stc.dynamic}).
The diagnostics components provides a consistent framework for
reporting errors in a \Cpp program, including predefined exception classes.

\pnum
The strings components provide support for manipulating text represented 
as sequences of type \tcode{char}, sequences of type \tcode{wchar_t},
or sequences of any other ``character-like'' type.
The localization components extend internationalization
support for such text processing.

\pnum
The containers, iterators, and algorithms provide a \Cpp program with access
to a subset of the most widely used algorithms and data structures.

\pnum
Numeric algorithms and the complex number components extend support for numeric processing.
The
\tcode{valarray}
component provides support for
\textit{n}-at-a-time
processing,
potentially implemented as parallel operations on platforms that support such processing.

\pnum
The
\tcode{iostreams}
components are the primary mechanism for \Cpp program input/output.
They can be used with other elements of the library, particularly
strings, locales, and iterators.

\pnum
The library also makes available the facilities of the Standard C library,
\indextext{library!C standard}%
suitably adjusted to ensure static type safety.

\pnum
The following subclauses describe the definitions~(\ref{lib.definitions}),
and method of description~(\ref{lib.description}) for the library.
Clause~\ref{lib.requirements} and clauses~\ref{\firstlibchapter} through
\ref{\lastlibchapter} specify the contents of the library, and library
requirements and constraints on both well-formed \Cpp programs and
conforming implementations.

\rSec1[lib.definitions]{Definitions}

\definition{arbitrary-positional stream}{defns.arbitrary.stream}
\indexdefn{stream!arbitrary-positional}%
a stream (described in clause~\ref{lib.input.output}) that can seek to any integral position within
the length of the stream.
Every arbitrary-positional stream is also a repositional stream~(\ref{defns.repositional.stream}).

\definition{character}{defns.character}
\indexdefn{character}%
in clauses~\ref{lib.strings}, \ref{lib.localization}, and
\ref{lib.input.output}, means any object which,
when treated sequentially, can represent text.
The term does not only mean \tcode{char}, and \tcode{wchar_t} objects,
but any value that can be represented by a type
that provides the definitions specified in these clauses.

\definition{character container type}{defns.character.container}
\indexdefn{type!character container}%
a class or a type used to represent a
\term{character}~(\ref{defns.character}).
It is used for one of the template parameters of the string and
iostream class templates.
A character container class shall be a POD~(\ref{basic.types}) type.

\definition{comparison function}{defns.comparison}
\indexdefn{function!comparison}%
an operator function~(\ref{over.oper}) for any of the equality~(\ref{expr.eq}) or
relational~(\ref{expr.rel}) operators

\definition{component}{defns.component}
\indexdefn{component}%
a group of library entities directly related as members, parameters, or
return types.
For example, the class template
\tcode{basic_string}
and the non-member function templates that operate on
strings are referred to as the
\term{string component}.

\definition{default behavior}{defns.default.behavior}
\indexdefn{behavior!default}%
a description of
\term{replacement function}
and
\term{handler function}
semantics.
Any specific behavior provided by the implementation,
within the scope of the
\term{required behavior}.

\definition{handler function}{defns.handler}
\indexdefn{function!handler}%
a non-\term{reserved function}
whose definition may be provided by a \Cpp program.
A \Cpp program may designate a handler function at various points in its execution, by
supplying a pointer to the function when calling any of the library functions that install
handler functions (clause~\ref{lib.language.support}).

\definition{iostream class templates}{defns.iostream.templates}
templates, defined in clause~\ref{lib.input.output},
that take two template arguments: \tcode{charT} and \tcode{traits}.
The argument
\tcode{charT}
is a character container class,
and the argument
\tcode{traits}
is a structure which defines additional characteristics and functions
of the character type represented by
\tcode{charT}
necessary to implement the iostream class templates.

\definition{modifier function}{defns.modifier}
\indexdefn{function!modifier}%
a class member function~(\ref{class.mfct}), other than constructors,
assignment, or destructor,
that alters the state of an object of the class.

\definition{object state}{defns.obj.state}
\indexdefn{state!object}%
the current value of all nonstatic class members of an object~(\ref{class.mem}).
The state of an object can be obtained by using one or more
\term{observer functions}.

\definition{narrow-oriented iostream classes}{}
the instantiations of the iostream class templates on the character container
class \tcode{char} and the default value of the \tcode{traits} parameter.
The traditional iostream classes are regarded as the narrow-oriented
iostream classes~(\ref{lib.narrow.stream.objects}).

\definition{NTCTS}{defns.ntcts}
\indexdefn{NTCTS}%
\indexdefn{string!null-terminated character~type}%
a sequence of values that have
\term{character type},
that precede the terminating null character type
value
\tcode{charT()}.

\definition{observer function}{defns.observer}
\indexdefn{function!observer}%
a class member function~(\ref{class.mfct}) that accesses the state of an object of the class,
but does not alter that state.
Observer functions are specified as
\tcode{const}
member functions~(\ref{class.this}).

\definition{replacement function}{defns.replacement}
\indexdefn{function!replacement}%
a non-\term{reserved function}
whose definition is provided by a \Cpp program.
Only one definition for such a function is in effect for the duration of the program's
execution, as the result of creating the program~(\ref{lex.phases}) and resolving the
definitions of all translation units~(\ref{basic.link}).

\definition{required behavior}{defns.required.behavior}
\indexdefn{behavior!required}%
a description of
\term{replacement function}
and
\term{handler function}
semantics,
applicable to both the behavior provided by the implementation and
the behavior that shall be provided by any function definition in the program.
If a function defined in a \Cpp program fails to meet the required
behavior when it executes, the behavior is undefined.%
\indextext{undefined}

\definition{repositional stream}{defns.repositional.stream}
\indexdefn{stream!repositional}%
a stream (described in clause~\ref{lib.input.output}) that can seek only to a position that was
previously encountered.

\definition{reserved function}{defns.reserved.function}
\indexdefn{function!reserved}%
a function, specified as part of the \Cpp Standard Library, that must be defined by the
implementation.
If a \Cpp program provides a definition for any reserved function, the results are undefined.%
\indextext{undefined}

\definition{traits class}{defns.traits}
\indexdefn{traits}%
a class that encapsulates a set of types and functions necessary for class templates and
function templates to manipulate objects of types for which they are instantiated.
Traits classes defined in clauses~\ref{lib.strings}, \ref{lib.localization} and~\ref{lib.input.output} are
\term{character traits}, which provide the character handling support needed by the string and
iostream classes.

\definition{wide-oriented iostream classes}{}
the instantiations of the iostream class templates on the character container
class \tcode{wchar_t} and the default value of the \tcode{traits}
parameter~(\ref{lib.wide.stream.objects}).

\rSec1[defns.additional]{Additional definitions}

\pnum
\ref{intro.defs} defines additional terms used elsewhere in this International Standard.

\rSec1[lib.description]{Method of description (Informative)}

\pnum
\ref{lib.description} describes the conventions used to describe the \Cpp Standard
Library. It describes the structures of the normative
clauses~\ref{\firstlibchapter} through~\ref{\lastlibchapter} (\ref{lib.structure}),
and other editorial conventions~(\ref{lib.conventions}).

\rSec2[lib.structure]{Structure of each subclause}

\pnum
\ref{lib.organization} provides a summary of the \Cpp Standard library's
contents. Other Library clauses provide detailed specifications for each
of the components in the library, as shown in Table~\ref{tab:lib.categories}.

\begin{floattable}{Library Categories}{tab:lib.categories}
{ll}
\topline
\hdstyle{Clause}	    &   \hdstyle{Category}  \\ \capsep
\ref{lib.language.support}  &   Language support\\
\ref{lib.diagnostics}	    &   Diagnostics\\
\ref{lib.utilities}	    &   General utilities\\
\ref{lib.strings}	    &   Strings\\
\ref{lib.localization}	    &	Localization\\
\ref{lib.containers}	    &	Containers\\
\ref{lib.iterators}	    &	Iterators\\
\ref{lib.algorithms}	    &	Algorithms\\
\ref{lib.numerics}	    &	Numerics\\
\ref{lib.input.output}	    &	Input/output\\
\end{floattable}

\pnum
Each Library clause contains the following elements, as applicable:\footnote{To
save space, items that do not apply to a clause are omitted.
For example, if a clause does not specify any requirements,
there will be no ``Requirements'' subclause.}

\begin{itemize}
\item Summary
\item Requirements
\item Detailed specifications
\item References to the Standard C library
\end{itemize}

\rSec3[lib.structure.summary]{Summary}

\pnum
The Summary provides a synopsis of the category, and introduces the first-level subclauses.
Each subclause also provides a summary, listing the headers specified in the
subclause and the library entities provided in each header.

\pnum
Paragraphs labelled ``Note(s):'' or ``Example(s):'' are informative, other paragraphs
are normative.

\pnum
The summary and the detailed specifications are presented in the order:

\begin{itemize}
\item Macros
\item Values
\item Types
\item Classes
\item Functions
\item Objects
\end{itemize}

\rSec3[lib.structure.requirements]{Requirements}

\pnum
\indextext{requirements}%
The library can be extended by a \Cpp program. Each clause, as applicable,
describes the requirements that such extensions must meet.
Such extensions are generally one of the following:

\begin{itemize}
\item Template arguments
\item Derived classes
\item Containers, iterators, and/or algorithms that meet an interface convention
\end{itemize}

\pnum
The string and iostream components use an explicit representation of operations
required of template arguments. They use a class template \tcode{char_traits} to
define these constraints.

\pnum
Interface convention requirements are stated as generally as possible. Instead
of stating ``class X has to define a member function \tcode{operator++()},'' the
interface requires ``for any object \tcode{x} of class \tcode{X}, \tcode{++x} is
defined.'' That is, whether the operator is a member is unspecified.

\pnum
Requirements are stated in terms of well-defined expressions, which define valid terms of
the types that satisfy the requirements. For every set of
requirements there is a table that specifies an initial set of the valid expressions and
their semantics~(\ref{lib.allocator.requirements}, \ref{lib.container.requirements},
\ref{lib.iterator.requirements}). Any generic algorithm (clause~\ref{lib.algorithms}) that uses the
requirements is described in terms of the valid expressions for
its formal type parameters.

\pnum
Template argument requirements are sometimes referenced by name.
See~\ref{lib.type.descriptions}.

\pnum
In some cases the semantic requirements are presented as \Cpp code.
Such code is intended as a
specification of equivalence of a construct to another construct, not
necessarily as the way the construct
must be implemented.\footnote{Although in some cases the code given is
unambiguously the optimum implementation.}

\rSec3[lib.structure.specifications]{Specifications}

\pnum
The detailed specifications each contain the following elements:\footnote{The
form of these specifications was designed to follow the conventions
established by existing \Cpp library vendors.}%

\begin{itemize}
\item Name and brief description
\item Synopsis (class definition or function prototype, as appropriate)
\item Restrictions on template arguments, if any
\item Description of class invariants
\item Description of function semantics
\end{itemize}

\pnum
Descriptions of class member functions follow the order (as
appropriate):\footnote{To save space, items that do not apply to a class are omitted.
For example, if a class does not specify any comparison functions, there
will be no ``Comparison functions'' subclause.}

\begin{itemize}
\item Constructor(s) and destructor
\item Copying \& assignment functions
\item Comparison functions
\item Modifier functions
\item Observer functions
\item Operators and other non-member functions
\end{itemize}

\pnum
Descriptions of function semantics contain the following elements (as
appropriate):\footnote{To save space, items that do not apply to a function are omitted.
For example, if a function does not specify any
further
preconditions, there will be no ``Requires'' paragraph.}

\begin{itemize}
\item \requires the preconditions for calling the function
\item \effects the actions performed by the function
\item \postconditions the observable results established by the function
\item \returns a description of the value(s) returned by the function
\item \throws any exceptions thrown by the function, and the conditions that would cause the exception
\item \complexity the time and/or space complexity of the function
\end{itemize}

\pnum
For non-reserved replacement and handler functions,
Clause~\ref{lib.language.support} specifies two behaviors for the functions in question:
their required and default behavior.
The
\term{default behavior}
describes a function definition provided by the implementation.
\indextext{behavior!default}%
The
\term{required behavior}
describes the semantics of a function definition provided by
\indextext{behavior!required}%
either the implementation or a \Cpp program.
Where no distinction is explicitly made in the description, the
behavior described is the required behavior.

\pnum
Complexity requirements specified in the library clauses are upper bounds,
and implementations that provide better complexity guarantees satisfy
the requirements.

\rSec3[lib.structure.see.also]{C Library}

\pnum
Paragraphs labelled ``\xref'' contain cross-references to the relevant portions
of this Standard and the ISO C standard,
which is incorporated into this Standard by reference.

\rSec2[lib.conventions]{Other conventions}
\indextext{conventions}%

\pnum
This subclause describes several editorial conventions used to describe the contents
of the \Cpp Standard Library.
These conventions are for describing
implementation-defined types~(\ref{lib.type.descriptions}),
and member functions~(\ref{lib.functions.within.classes}).

\rSec3[lib.type.descriptions]{Type descriptions}

\pnum
The Requirements subclauses may describe names that are used to specify
constraints on template arguments.\footnote{Examples
from~\ref{lib.utility.requirements} include:
\tcode{EqualityComparable},
\tcode{LessThanComparable},
\tcode{CopyConstructible}, etc.
Examples from~\ref{lib.iterator.requirements} include:
\tcode{InputIterator},
\tcode{ForwardIterator},
\tcode{Function},
\tcode{Predicate}, etc.}
These names are used in clauses~\ref{lib.utilities}, \ref{lib.containers},
\ref{lib.algorithms}, and \ref{lib.numerics}
to describe the types that
may be supplied as arguments by a \Cpp program when instantiating template components from
the library.

\pnum
Certain types defined in clause~\ref{lib.input.output} are used to describe implementation-defined types.
\indextext{types!implementation-defined}%
They are based on other types, but with added constraints.

\rSec4[lib.enumerated.types]{Enumerated types}

\pnum
Several types defined in clause~\ref{lib.input.output} are
\term{enumerated types}.
\indextext{type!enumerated}%
Each enumerated type may be implemented as an enumeration or as a synonym for
an enumeration.\footnote{Such as an integer type, with constant integer
values~(\ref{basic.fundamental}).}

\pnum
The enumerated type \term{enumerated} can be written:

\begin{codeblock}
enum @\term{enumerated}@ { @\term{V0}@, @\term{V1}@, @\term{V2}@, @\term{V3}@, .....};

static const @\term{enumerated C0}@(@\term{V0}@);
static const @\term{enumerated C1}@(@\term{V1}@);
static const @\term{enumerated C2}@(@\term{V2}@);
static const @\term{enumerated C3}@(@\term{V3}@);
  .....
\end{codeblock}

\pnum
Here, the names \term{C0}, \term{C1}, etc. represent
\term{enumerated elements}
for this particular enumerated type.
\indextext{type!enumerated}%
All such elements have distinct values.

\rSec4[lib.bitmask.types]{Bitmask types}

\pnum
Several types defined in clauses~\ref{lib.input.output}
are
\term{bitmask types}.
\indextext{type!bitmask}%
Each bitmask type can be implemented as an
enumerated type that overloads certain operators, as an integer type,
or as a
\tcode{bitset}~(\ref{lib.template.bitset}).
\indextext{type!enumerated}%

\pnum
The bitmask type \term{bitmask} can be written:

\begin{codeblock}
enum @\term{bitmask}@ {
  @\term{V0}@ = 1 << 0, @\term{V1}@ = 1 << 1, @\term{V2}@ = 1 << 2, @\term{V3}@ = 1 << 3, .....
};

static const @\term{bitmask C0}@(@\term{V0}{}@);
static const @\term{bitmask C1}@(@\term{V1}{}@);
static const @\term{bitmask C2}@(@\term{V2}{}@);
static const @\term{bitmask C3}@(@\term{V3}{}@);
  .....

@\term{bitmask}{}@  operator& (@\term{bitmask}{}@  X, @\term{bitmask}{}@ Y)
	// For exposition only.
	// \tcode{int_type} is an integral type capable of
	// representing all values of \tcode{\term{bitmask}}
	{ return static_cast<@\term{bitmask}{}@>(
		     static_cast<int_type>(X) &
		     static_cast<int_type>(Y)); }

@\term{bitmask}{}@  operator| (@\term{bitmask}{}@  X, @\term{bitmask}{}@ Y)
	{ return static_cast<@\term{bitmask}{}@>(
		     static_cast<int_type>(X) |
		     static_cast<int_type>(Y)); }
@\term{bitmask}{}@  operator^ (@\term{bitmask}{}@  X, @\term{bitmask}{}@ Y)
	{ return static_cast<@\term{bitmask}{}@>(
		     static_cast<int_type>(X) ^
		     static_cast<int_type>(Y)); }
@\term{bitmask}{}@  operator~ (@\term{bitmask}{}@  X)
	{ return static_cast<@\term{bitmask}{}@>(static_cast<int_type>(~X)); }

@\term{bitmask}{}@& operator&=(@\term{bitmask}{}@& X, @\term{bitmask}{}@ Y)
	{ X = X & Y; return X; }
@\term{bitmask}{}@& operator|=(@\term{bitmask}{}@& X, @\term{bitmask}{}@ Y)
	{ X = X | Y; return X; }
@\term{bitmask}{}@& operator^=(@\term{bitmask}{}@& X, @\term{bitmask}{}@ Y)
	{ X = X ^ Y; return X; }
\end{codeblock}

\pnum
Here, the names \term{C0}, \term{C1}, etc. represent
\term{bitmask elements}
for this particular bitmask type.
\indextext{type!bitmask}%
All such elements have distinct values such that, for any pair \term{Ci}
and \term{Cj}, \term{Ci} \& \term{Ci} is nonzero and
\term{Ci} \& \term{Cj} is zero.

\pnum
The following terms apply to objects and values of
bitmask types:

\begin{itemize}
\item
To
\term{set}
a value \textit{Y} in an object \textit{X}
is to evaluate the expression \textit{X} $|$= \textit{Y}.
\item
To
\term{clear}
a value \textit{Y} in an object
\textit{X} is to evaluate the expression \textit{X} \&= $\sim$\textit{Y}.
\item
The value \textit{Y}
\term{is set}
in the object
\textit{X} if the expression \textit{X} \& \textit{Y} is nonzero.
\end{itemize}

\rSec4[lib.character.seq]{Character sequences}

\pnum
The Standard C library makes widespread use
\indextext{library!C standard}%
of characters and character sequences that follow a few uniform conventions:

\begin{itemize}
\item
A
\term{letter}
is any of the 26 lowercase or 26
\indextext{lowercase}%
\indextext{uppercase}%
uppercase letters in the basic execution character set.\footnote{Note that
this definition differs from the definition in ISO C subclause 7.1.1.}
\item
The
\term{decimal-point character}
is the
\indextext{character!decimal-point}%
(single-byte) character used by functions that convert between a (single-byte)
character sequence and a value of one of the floating-point types.
It is used
in the character sequence to denote the beginning of a fractional part.
It is
represented in clauses~\ref{\firstlibchapter} through~\ref{\lastlibchapter}
by a period,
\indextext{period}%
\tcode{'.'},
which is
also its value in the \tcode{"C"}
locale, but may change during program
execution by a call to
\tcode{setlocale(int, const char*)},\footnote{declared in
\tcode{<clocale>}~(\ref{lib.c.locales}).
\indextext{\idxcode{setlocale}}%
\indexlibrary{\idxcode{setlocale}}%
\indextext{\idxhdr{clocale}}%
\indexlibrary{\idxhdr{clocale}}}
or by a change to a
\tcode{locale}
object, as described in clauses~\ref{lib.locales} and~\ref{lib.input.output}.
\item
A
\term{character sequence}
is an array object~(\ref{dcl.array}) \textit{A} that
can be declared as
\tcode{\textit{T A}[\textit{N}]},
where \textit{T} is any of the types
\tcode{char},
\tcode{unsigned char},
or
\tcode{signed char}~(\ref{basic.fundamental}), optionally qualified by any combination of
\tcode{const}
or
\tcode{volatile}.
The initial elements of the
array have defined contents up to and including an element determined by some
predicate.
A character sequence can be designated by a pointer value
\textit{S} that points to its first element.
\end{itemize}

\rSec5[lib.byte.strings]{Byte strings}

\pnum
A
\indextext{string!null-terminated byte}%
\indextext{NTBS}%
\term{null-terminated byte string},
or \term{\ntbs},
is a character sequence whose highest-addressed element
with defined content has the value zero
(the
\term{terminating null}
character).\footnote{Many of the objects manipulated by
function signatures declared in
\tcode{<cstring>}~(\ref{lib.c.strings}) are character sequences or \ntbs{}s.
\indextext{\idxhdr{cstring}}%
\indexlibrary{\idxhdr{cstring}}%
The size of some of these character sequences is limited by
a length value, maintained separately from the character sequence.}

\pnum
The
\term{length of an \ntbs}
is the number of elements that
precede the terminating null character.
\indextext{NTBS}%
An
\term{empty \ntbs}
has a length of zero.

\pnum
The
\term{value of an \ntbs}
is the sequence of values of the
elements up to and including the terminating null character.
\indextext{NTBS}%

\pnum
A
\indextext{NTBS}%
\indextext{NTBS!static}%
\term{static \ntbs}
is an \ntbs with
static storage duration.\footnote{A string literal, such as \tcode{"abc"},
is a static \ntbs.}

\rSec5[lib.multibyte.strings]{Multibyte strings}

\pnum
A
\indextext{NTBS}%
\indextext{NTMBS}%
\term{null-terminated multibyte string,}
or \term{\ntmbs},
\indextext{string!null-terminated multibyte}%
is an \ntbs that constitutes a
sequence of valid multibyte characters, beginning and ending in the initial
shift state.\footnote{An \ntbs that contains characters only from the
basic execution character set is also an \ntmbs.
Each multibyte character then
consists of a single byte.}

\pnum
A
\term{static \ntmbs}
is an \ntmbs with static storage duration.
\indextext{NTMBS!static}%
\indextext{NTMBS}%

\rSec5[lib.wide.characters]{Wide-character sequences}

\pnum
A
\term{wide-character sequence}
is an array object~(\ref{dcl.array}) \textit{A} that
can be declared as
\tcode{\textit{T A}[\textit{N}]},
where \textit{T} is type
\tcode{wchar_t}~(\ref{basic.fundamental}),
optionally qualified by any combination of
\tcode{const}
or
\tcode{volatile}.
The initial elements of the
array have defined contents up to and including an element determined by some
predicate.
A character sequence can be designated by a pointer value
\textit{S} that points to its first element.

\pnum
A
\indextext{string!null-terminated wide-character}%
\indextext{NTWCS}%
\term{null-terminated wide-character string},
or \term{\ntwcs},
is a wide-character sequence whose highest-addressed element
with defined content has the value zero.\footnote{Many of the objects manipulated by
function signatures declared in
\tcode{<cwchar>} are wide-character sequences or \ntwcs{}s.
\indextext{\idxhdr{cwchar}}%
\indexlibrary{\idxhdr{cwchar}}%
}

\pnum
The
\term{length of an \ntwcs}
is the number of elements that
precede the terminating null wide character.
\indextext{NTWCS}%
An
\term{empty \ntwcs}
has a length of zero.

\pnum
The
\term{value of an \ntwcs}
is the sequence of values of the
elements up to and including the terminating null character.
\indextext{NTWCS}%

\pnum
A
\indextext{NTWCS}%
\indextext{NTWCS!static}%
\term{static \ntwcs}
is an \ntwcs with
static storage duration.\footnote{A wide string literal, such as \tcode{L"abc"},
is a static \ntwcs.}

\rSec3[lib.functions.within.classes]{Functions within classes}

\pnum
For the sake of exposition, clauses~\ref{\firstlibchapter} through~\ref{\lastlibchapter}
do not describe copy constructors, assignment
operators, or (non-virtual) destructors with the same apparent
semantics as those that can be generated by default~(\ref{class.ctor}, \ref{class.dtor}, \ref{class.copy}).

\pnum
\indextext{constructor!copy}%
\indextext{operator!assignment}%
\indextext{destructor}%
It is unspecified whether
the implementation provides explicit definitions for such member function
signatures, or for virtual destructors that can be generated by default.

\rSec3[lib.objects.within.classes]{Private members}

\pnum
Clauses~\ref{\firstlibchapter} through~\ref{\lastlibchapter}
do not specify the representation of classes, and intentionally
omit specification of class members~(\ref{class.mem}). An implementation may
define static or non-static class members, or both, as needed to implement the
semantics of the member functions specified in clauses~\ref{\firstlibchapter}
through~\ref{\lastlibchapter}.

\pnum
Objects of certain classes are sometimes required by the external specifications of
their classes to store data, apparently in member objects. For the sake of exposition,
some subclauses provide representative declarations, and semantic requirements, for
private member objects of classes that meet the external specifications of the classes.
The declarations for such member objects and the definitions of related member types are
enclosed in a comment that ends with \expos, as in:

\begin{codeblock}
//	streambuf* sb;  \expos
\end{codeblock}

\pnum
An alternate implementation that provides equivalent external behavior is equally acceptable.

\rSec1[lib.requirements]{Library-wide requirements}

\pnum
This subclause specifies requirements that apply to the entire \Cpp Standard library.
Clauses~\ref{\firstlibchapter} through~\ref{\lastlibchapter}
specify the requirements of individual entities within the library.

\pnum
The following subclauses describe the library's contents and
organization~(\ref{lib.organization}), how well-formed \Cpp programs gain
access to library entities~(\ref{lib.using}),
constraints on such programs~(\ref{lib.constraints}), and
constraints on conforming implementations~(\ref{lib.conforming}).

\rSec2[lib.organization]{Library contents and organization}

\pnum
This subclause provides a summary of the entities defined in the
\Cpp Standard Library.
In general, these entities are defined in library headers, which
subclause~\ref{lib.headers} lists alphabetically.

\rSec3[lib.contents]{Library contents}

\pnum
The \Cpp Standard Library provides definitions for the following types of entities:
Macros, Values, Types, Templates, Classes, Functions, Objects.

\pnum
All library entities except macros,
\tcode{operator new}
and
\tcode{operator delete}
are defined within the namespace
\tcode{std}
or namespaces nested within namespace
\tcode{std}.

\rSec3[lib.headers]{Headers}

\pnum
The elements of the \Cpp Standard Library are declared or defined (as appropriate) in a
\term{header}.\footnote{A header is not necessarily a source file, nor are the
sequences delimited by \tcode{<} and \tcode{>} in header names necessarily valid source
file names~(\ref{cpp.include}). }

\pnum
The \Cpp Standard Library provides
33
\term{\Cpp headers},
\indextext{header!C++ library}%
as shown in Table~\ref{tab:cpp.library.headers}.

\begin{floattable}{\Cpp Library Headers}{tab:cpp.library.headers}
{lllll}
\topline

\tcode{<algorithm>}         &
\tcode{<iomanip>}           &
\tcode{<list>}              &
\tcode{<queue>}             &
\tcode{<streambuf>}         \\

\tcode{<bitset>}            &
\tcode{<ios>}               &
\tcode{<locale>}            &
\tcode{<set>}               &
\tcode{<string>}            \\

\tcode{<complex>}           &
\tcode{<iosfwd>}            &
\tcode{<map>}               &
\tcode{<sstream>}           &
\tcode{<typeinfo>}          \\

\tcode{<deque>}             &
\tcode{<iostream>}          &
\tcode{<memory>}            &
\tcode{<stack>}             &
\tcode{<utility>}           \\

\tcode{<exception>}         &
\tcode{<istream>}           &
\tcode{<new>}               &
\tcode{<stdexcept>}         &
\tcode{<valarray>}          \\

\tcode{<fstream>}           &
\tcode{<iterator>}          &
\tcode{<numeric>}           &
\tcode{<strstream>}         &
\tcode{<vector>}            \\

\tcode{<functional>}        &
\tcode{<limits>}            &
\tcode{<ostream>}           & & \\

\end{floattable}


\pnum
The facilities of the Standard C Library are provided in 18
\indextext{library!C standard}%
additional headers, as shown in Table~\ref{tab:cpp.c.headers}.

\begin{floattable}{\Cpp Headers for C Library Facilities}{tab:cpp.c.headers}
{lllll}
\topline

\tcode{<cassert>}           &
\tcode{<ciso646>}           &
\tcode{<csetjmp>}           &
\tcode{<cstdio>}            &
\tcode{<ctime>}             \\

\tcode{<cctype>}            &
\tcode{<climits>}           &
\tcode{<csignal>}           &
\tcode{<cstdlib>}           &
\tcode{<cwchar>}            \\

\tcode{<cerrno>}            &
\tcode{<clocale>}           &
\tcode{<cstdarg>}           &
\tcode{<cstring>}           &
\tcode{<cwctype>}           \\

\tcode{<cfloat>}            &
\tcode{<cmath>}             &
\tcode{<cstddef>}           & & \\

\end{floattable}

\pnum
Except as noted in clauses~\ref{\firstlibchapter} through~\ref{\lastlibchapter},
the contents of each header \tcode{c\textit{name}} shall
be the same as that of the corresponding header \tcode{\textit{name}.h}, as
specified in ISO/IEC 9899:1990 Programming Languages C (Clause 7),
or ISO/IEC:1990 Programming Languages---C AMENDMENT 1: C Integrity, (Clause 7),
as appropriate, as if by inclusion. In the \Cpp Standard Library, however, the
declarations and definitions (except for names which are defined as macros in C) are within
namespace scope~(\ref{basic.scope.namespace}) of the namespace \tcode{std.}

\pnum
Names which are defined as macros in C shall be defined as macros in the \Cpp
Standard Library, even if C grants license for implementation as functions.
\enternote the names defined as macros in C include the following:
\tcode{assert}, \tcode{errno}, \tcode{offsetof}, \tcode{setjmp}, \tcode{va_arg},
\tcode{va_end}, and \tcode{va_start}. \exitnoteb

\pnum
Names that are defined as functions in C shall be defined as functions in the
\Cpp Standard Library.\footnote{This disallows the practice, allowed in C, of
providing a "masking macro" in addition to the function prototype. The only way to
achieve equivalent "inline" behavior in \Cpp is to provide a definition as an
extern inline function.}

\pnum
\ref{depr.c.headers}, Standard C library headers, describes the effects of using
the \tcode{\textit{name}.h} (C header) form in a \Cpp program.\footnote{ The
\tcode{".h"} headers dump all their names into the global namespace, whereas the
newer forms keep their names in namespace \tcode{std}. Therefore, the newer
forms are the preferred forms for all uses except for \Cpp programs which are
intended to be strictly compatible with C. }

\rSec3[lib.compliance]{Freestanding implementations}

\pnum
Two kinds of implementations are defined:
\term{hosted}
and
\term{freestanding}~(\ref{intro.compliance}).
For a hosted implementation, this International Standard
\indextext{implementation!hosted}%
describes the set of available headers.

\pnum
A freestanding implementation\indextext{implementation!freestanding} has an
\impldef{headers for freestanding implementation} set of headers. This set shall
include at least the following headers, as shown in Table~\ref{tab:cpp.headers.freestanding}.

\begin{libsumtab}{\Cpp Headers for Freestanding Implementations}{tab:cpp.headers.freestanding}
\ref{lib.support.types} & Types                       &   \tcode{<cstddef>}       \\ \rowsep
\ref{lib.support.limits}& Implementation properties  &  \tcode{<limits>}        \\ \rowsep
\ref{lib.support.start.term}& Start and termination  &   \tcode{<cstdlib>}       \\ \rowsep
\ref{lib.support.dynamic} & Dynamic memory management &   \tcode{<new>}           \\ \rowsep
\ref{lib.support.rtti}  & Type identification          &   \tcode{<typeinfo>}      \\ \rowsep
\ref{lib.support.exception} & Exception handling      &   \tcode{<exception>}     \\ \rowsep
\ref{lib.support.runtime} & Other runtime support     &   \tcode{<cstdarg>}       \\
\end{libsumtab}

\pnum
The supplied version of the header
\tcode{<cstdlib>}
\indextext{\idxhdr{cstdlib}}%
\indexlibrary{\idxhdr{cstdlib}}%
shall declare at least the functions
\tcode{abort()},
\tcode{atexit()},
and \tcode{exit()}
\indexlibrary{\idxcode{abort}}%
\indexlibrary{\idxcode{atexit}}%
\indexlibrary{\idxcode{exit}}%
(\ref{lib.support.start.term}).

\rSec2[lib.using]{Using the library}

\pnum
This subclause describes how a \Cpp program gains access to the facilities of the
\Cpp Standard Library. \ref{lib.using.headers} describes effects during translation
phase 4, while~\ref{lib.using.linkage} describes effects during phase
8~(\ref{lex.phases}).

\rSec3[lib.using.headers]{Headers}

\pnum
The entities in the \Cpp Standard Library are defined in headers,
whose contents are made available to a translation unit when it contains the appropriate
\indextext{unit!translation}%
\tcode{\#include}
preprocessing directive~(\ref{cpp.include}).%
\indextext{\idxcode{\#include}}%
\indextext{source file}

\pnum
A translation unit may include library headers in any order (clause~\ref{lex}).
\indextext{unit!translation}%
Each may be included more than once, with no effect different from
being included exactly once, except that the effect of including either
\tcode{<cassert>}
or
\tcode{<assert.h>}
depends each time on the lexically
\indextext{\idxhdr{cassert}}%
\indexlibrary{\idxhdr{cassert}}%
\indextext{\idxhdr{assert.h}}%
\indexlibrary{\idxhdr{assert.h}}%
current definition of
\indextext{\idxcode{NDEBUG}}%
\indexlibrary{\idxcode{NDEBUG}}%
\tcode{NDEBUG}.\footnote{This is the same as the Standard C library.}

\pnum
A translation unit shall include a header only outside of any
\indextext{unit!translation}%
external declaration or definition, and shall include the header lexically
before the first reference to any of the entities it declares or first
defines in that translation unit.

\rSec3[lib.using.linkage]{Linkage}

\pnum
Entities in the \Cpp Standard Library have external linkage~(\ref{basic.link}).
Unless otherwise specified, objects and functions have the default
\tcode{extern "C++"}
linkage~(\ref{dcl.link}).

\pnum
\indextext{library!C standard}%
It is \impldef{linkage of names from Standard C library} whether a name
from the Standard C library declared with
external linkage has
\indextext{linkage!external}%
\indextext{header!C library}%
\indextext{\idxcode{extern ""C""}}%
\tcode{extern "C"}
or
\indextext{\idxcode{extern ""C++""}}%
\tcode{extern "C++"}
linkage.\footnote{The only reliable way to declare an object or
function signature from the Standard C library is by including the header that
declares it, notwithstanding the latitude granted in 7.1.7 of the C
Standard.} It is recommended that an
implementation use
\tcode{extern "C++"}
linkage for this purpose.

\pnum
Objects and functions
defined in the library and required by a \Cpp program are included in
the program prior to program startup.

\indextext{startup!program}%
\xref
replacement functions~(\ref{lib.replacement.functions}),
run-time changes~(\ref{lib.handler.functions}).

\rSec2[lib.constraints]{Constraints on programs}

\pnum
This subclause describes restrictions on \Cpp programs that use the facilities of
the \Cpp Standard Library. The following subclauses specify constraints on the
program's namespaces~(\ref{lib.reserved.names}), its use of
headers~(\ref{lib.alt.headers}), classes derived from standard library
classes~(\ref{lib.derived.classes}), definitions of replacement
functions~(\ref{lib.replacement.functions}), and installation of handler
functions during execution~(\ref{lib.handler.functions}).

\rSec3[lib.reserved.names]{Reserved names}%
\indextext{name!reserved}

\pnum
It is undefined for a \Cpp program to add declarations or definitions to
namespace \tcode{std} or namespaces within namespace \tcode{std} unless
otherwise specified. A program may add template specializations for any
standard library template to namespace \tcode{std}. Such a specialization
(complete or partial) of a standard library template results in undefined
behavior unless the declaration depends on a user-defined name of external
linkage and unless the specialization meets the standard library requirements
for the original template.\footnote{Any library code that instantiates other
library templates must be prepared to work adequately with any user-supplied
specialization that meets the minimum requirements of the Standard.}

\pnum
The \Cpp Standard Library reserves the following kinds of names:
\begin{itemize}
\item Macros
\item Global names
\item Names with external linkage
\end{itemize}

\pnum
If the program declares or defines a name in a context where it is
reserved, other than as explicitly allowed by this clause, its behavior is
undefined.%
\indextext{undefined}

\rSec4[lib.macro.names]{Macro names}

\pnum
\indextext{\idxcode{\#undef}}%
\indextext{unit!translation}%
Each name defined as a macro in a header is reserved to the implementation
for any use if the translation unit includes the header.\footnote{It is not
permissible to remove a library macro definition by using the \tcode{\#undef}
directive.}

\pnum
\indextext{unit!translation}%
A translation unit that includes a header shall not contain any macros that
define names declared or defined in that header. Nor shall such a translation
unit define macros for names lexically identical to keywords.

\rSec4[lib.global.names]{Global names}

\pnum
Certain sets of names and function signatures are always reserved to the implementation:

\begin{itemize}
\item
Each name that contains a double underscore
(\tcode{\unun})
\indextext{character!underscore}%
or begins with an underscore followed by
an uppercase letter
\indextext{uppercase}%
(\ref{lex.key}) is reserved to the implementation for any use.
\item
Each name that begins with an underscore is
\indextext{character!underscore}%
reserved to the implementation for use as a name in the global namespace.%
\indextext{namespace!global}\footnote{Such names are also reserved in namespace
\tcode{::std}~(\ref{lib.reserved.names}).}
\end{itemize}

\rSec4[lib.extern.names]{External linkage}

\pnum
Each name declared as an object with external linkage
\indextext{linkage!external}%
in a header is reserved to the implementation to designate that library
object with external linkage,%
\indextext{linkage!external}\footnote{The list of such reserved names includes
\tcode{errno},
declared or defined in
\indextext{\idxhdr{cerrno}}%
\indexlibrary{\idxhdr{cerrno}}%
\tcode{<cerrno>}.}
both in namespace
\tcode{std}
and in the global namespace.

\pnum
Each
\indextext{function!global}%
global function signature declared with
\indextext{linkage!external}%
external linkage in a header is reserved to the
implementation to designate that function signature with
\indextext{linkage!external}%
external linkage.
\footnote{The list of such reserved function
signatures with external linkage includes
\indexlibrary{\idxcode{setjmp}}%
\tcode{setjmp(jmp_buf)},
declared or defined in
\indexlibrary{\idxhdr{csetjmp}}%
\tcode{<csetjmp>},
and
\indexlibrary{\idxcode{va_end}}%
\indexlibrary{\idxcode{va_list}}%
\tcode{va_end(va_list)},
declared or defined in
\indexlibrary{\idxhdr{cstdarg}}%
\tcode{<cstdarg>}.}

\pnum
Each name having two consecutive underscores~(\ref{lex.key}) is reserved
to the implementation for use as a name with both
\indextext{\idxcode{extern ""C""}}%
\tcode{extern "C"}
and
\indextext{\idxcode{extern ""C++""}}%
\tcode{extern "C++"} linkage.

\pnum
Each name from the Standard C library declared with external linkage
\indextext{linkage!external}%
is reserved to the implementation for use as a name with
\indextext{header!C}%
\indextext{\idxcode{extern ""C""}}%
\tcode{extern "C"}
linkage,
both in namespace std and in the global namespace.

\pnum
Each function signature from the Standard C library declared with
\indextext{linkage!external}%
external linkage
is reserved to the implementation for use as
a function signature with both
\indextext{\idxcode{extern ""C""}}%
\tcode{extern "C"}
and
\indextext{\idxcode{extern ""C++""}}%
\tcode{extern "C++"}
linkage,
\footnote{
The function
signatures declared in
\indextext{Amendment~1}%
\indextext{\idxhdr{cwchar}}%
\indexlibrary{\idxhdr{cwchar}}%
\indextext{\idxhdr{cwctype}}%
\tcode{<cwchar>},
and
\tcode{<cwctype>}
are always reserved, notwithstanding the restrictions imposed in subclause
4.5.1 of Amendment 1 to the C Standard for these headers.}
or as a name of namespace scope in the global namespace.

\rSec4[lib.extern.types]{Types}

\pnum
For each type T from the Standard C library,\footnote{These types are
\tcode{clock_t},
\tcode{div_t},
\tcode{FILE},
\tcode{fpos_t},
\tcode{lconv},
\tcode{ldiv_t},
\tcode{mbstate_t},
\tcode{ptrdiff_t},
\tcode{sig_atomic_t},
\tcode{size_t},
\tcode{time_t},
\tcode{tm},
\tcode{va_list},
\tcode{wctrans_t},
\tcode{wctype_t},
and
\tcode{wint_t}.}
the types
\tcode{::T}
and
\tcode{std::T}
are reserved to the implementation and, when defined,
\tcode{::T}
shall be identical to
\tcode{std::T}.

\rSec3[lib.alt.headers]{Headers}

\pnum
If a file with a name
\indextext{implementation-defined}%
equivalent to the derived file name for one of the \Cpp Standard Library headers
is not provided as part of the implementation, and a file with that name
is placed in any of the standard places for a source file to be included~(\ref{cpp.include}),
the behavior is undefined.%
\indextext{source file}%
\indextext{undefined}

\rSec3[lib.derived.classes]{Derived classes}

\pnum
Virtual member function signatures defined
\indextext{function!virtual member}%
for a base class in the \Cpp Standard
\indextext{class!base}%
\indextext{library!C++ standard}%
library may be overridden in a derived class defined in the program~(\ref{class.virtual}).

\rSec3[lib.replacement.functions]{Replacement functions}

\pnum
\indextext{definition!altermate}%
Clauses~\ref{\firstlibchapter} through~\ref{\lastlibchapter}
describe the behavior of numerous functions defined by
the \Cpp Standard Library.
Under some circumstances,
\indextext{library!C++ standard}%
however, certain of these function descriptions also apply to replacement functions defined
in the program~(\ref{lib.definitions}).

\pnum
A \Cpp program may provide the definition for any of eight
dynamic memory allocation function signatures declared in header
\tcode{<new>}~(\ref{basic.stc.dynamic}, clause~\ref{lib.language.support}):

\begin{itemize}
\item
\indextext{\idxcode{new}!\idxcode{operator}}%
\indexlibrary{\idxcode{new}!\idxcode{operator}}%
\tcode{operator new(size_t)}
\item
\tcode{operator new(size_t, const std::nothrow_t\&)}
\item
\indextext{\idxcode{new}!\idxcode{operator}}%
\indexlibrary{\idxcode{new}!\idxcode{operator}}%
\tcode{operator new[](size_t)}
\item
\tcode{operator new[](size_t, const std::nothrow_t\&)}
\item
\indextext{\idxcode{delete}!\idxcode{operator}}%
\indexlibrary{\idxcode{delete}!\idxcode{operator}}%
\tcode{operator delete(void*)}
\item
\tcode{operator delete(void*, const std::nothrow_t\&)}
\item
\indextext{\idxcode{delete}!\idxcode{operator}}%
\indexlibrary{\idxcode{delete}!\idxcode{operator}}%
\tcode{operator delete[](void*)}
\item
\tcode{operator delete[](void*, const std::nothrow_t\&)}
\end{itemize}

\pnum
The program's definitions are used instead of the default versions supplied by
the implementation~(\ref{lib.support.dynamic}).
Such replacement occurs prior to program startup~(\ref{basic.def.odr}, \ref{basic.start}).

\rSec3[lib.handler.functions]{Handler functions}

\pnum
The \Cpp Standard Library provides default versions of the following handler
functions (clause~\ref{lib.language.support}):

\begin{itemize}
\item
\tcode{unexpected_handler}
\indexlibrary{\idxcode{unexpected_handler}}%
\item
\tcode{terminate_handler}
\indexlibrary{\idxcode{terminate_handler}}%
\end{itemize}

\pnum
A \Cpp program may install different handler functions during execution, by
supplying a pointer to a function defined in the program or the library
as an argument to (respectively):

\begin{itemize}
\item
\indexlibrary{\idxcode{set_new_handler}}%
\tcode{set_new_handler}
\item
\indexlibrary{\idxcode{set_unexpected}}%
\tcode{set_unexpected}
\item
\indexlibrary{\idxcode{set_terminate}}
\tcode{set_terminate}
\end{itemize}

\xref
subclauses~\ref{lib.alloc.errors}, Storage allocation errors, and~\ref{lib.support.exception}, 
Exception handling.

\rSec3[lib.res.on.functions]{Other functions}

\pnum
In certain cases (replacement functions, handler functions, operations on types used to
instantiate standard library template components), the \Cpp Standard Library depends on
components supplied by a \Cpp program.
If these components do not meet their requirements, the Standard places no requirements
on the implementation.

\pnum
In particular, the effects are undefined in the following cases:

\begin{itemize}
\item
for replacement functions~(\ref{lib.new.delete}), if the installed replacement function does not
implement the semantics of the applicable
\required
paragraph.
\item
for handler functions~(\ref{lib.new.handler}, \ref{lib.terminate.handler}, \ref{lib.unexpected.handler}),
if the installed handler function does not implement the semantics of the applicable
\required
paragraph
\item
for types used as template arguments when instantiating a template component,
if the operations on the type do not implement the semantics of the applicable
\synopsis{Requirements}
subclause~(\ref{lib.allocator.requirements}, \ref{lib.container.requirements}, \ref{lib.iterator.requirements},
\ref{lib.numeric.requirements}).
Operations on such types can report a failure by throwing an exception
unless otherwise specified.
\item
if any replacement function or handler function or destructor operation throws an exception,
unless specifically allowed
in the applicable
\required
paragraph.
\item
if an incomplete type~(\ref{basic.types}) is used as a template
argument when instantiating a template component.
\end{itemize}

\rSec3[lib.res.on.arguments]{Function arguments}

\pnum
\indextext{restriction}%
\indextext{argument}%
Each of the following statements applies to all arguments
\indextext{argument}%
to functions defined in the \Cpp Standard Library,%
\indextext{library!C++ standard}
unless explicitly stated otherwise.

\begin{itemize}
\item
If an argument to a function has an invalid value (such
\indextext{argument}%
as a value outside the domain of the function, or a pointer invalid for its
intended use), the behavior is undefined.
\indextext{undefined}%

\item
If a function argument is described as being an array,
\indextext{argument}%
the pointer actually passed to the function shall have a value such that all
address computations and accesses to objects (that would be valid if the
pointer did point to the first element of such an array) are in fact valid.
\end{itemize}

\rSec3[lib.res.on.required]{Requires paragraph}

\pnum
\indextext{restriction}%
Violation of the preconditions specified in a function's
\required
paragraph results in undefined behavior unless the function's
\throws
paragraph specifies throwing an exception when the precondition is violated.

\rSec2[lib.conforming]{Conforming implementations}

\pnum
This subclause describes the constraints upon, and latitude of, implementations of the \Cpp Standard library.
The following subclauses describe an implementation's use of headers~(\ref{lib.res.on.headers}(,
macros~(\ref{lib.res.on.macro.definitions}),
global functions~(\ref{lib.global.functions}),
member functions~(\ref{lib.member.functions}),
reentrancy~(\ref{lib.reentrancy}),
access specifiers~(\ref{lib.protection.within.classes}),
class derivation~(\ref{lib.derivation}),
and exceptions~(\ref{lib.res.on.exception.handling}).

\rSec3[lib.res.on.headers]{Headers}

\pnum
A \Cpp header may include other \Cpp headers.\footnote{\Cpp headers must
include a \Cpp header that contains any needed definition~(\ref{basic.def.odr}).}

\pnum
Certain types and macros are defined in more than one header.
For such an entity, a second or subsequent header that also defines it may be
included after the header that provides its initial
definition~(\ref{basic.def.odr}).

\pnum
Header inclusion is limited as follows:

\begin{itemize}
\item
The C headers ( \tcode{.h} form, described in Annex~\ref{depr}, \ref{depr.c.headers})
shall include only their corresponding \Cpp header, as described above~(\ref{lib.headers}).
\end{itemize}

\rSec3[lib.res.on.macro.definitions]{Restrictions on macro definitions}
\indextext{restriction}%

\pnum
The names or global function signatures described in~\ref{lib.contents} are
\indextext{function!global}%
reserved to the implementation.
\indextext{argument}%
\indextext{header!C}%
\indextext{function!global}%
\indextext{inline}%
\indextext{macro!masking}%

\pnum
All object-like macros defined by the Standard C library and described in this
clause as expanding to integral constant expressions are also suitable for use
in \tcode{\#if}\indextext{\idxcode{\#if}} preprocessing directives, unless
explicitly stated otherwise.

\rSec3[lib.global.functions]{Global and non-member functions}

\pnum
It is unspecified whether any global
or non-member
functions in the \Cpp Standard Library are defined as
\tcode{inline}~(\ref{dcl.fct.spec}).

\pnum
\indextext{function!global}A call to a global or non-member function signature
described in Clauses~\ref{\firstlibchapter} through~\ref{\lastlibchapter}
behaves the same as if the implementation declared no additional
global or non-member function signatures.\footnote{A valid \Cpp program always
calls the expected library global or non-member function. An implementation may
also define additional global or non-member functions that would otherwise not
be called by a valid \Cpp program.}

\pnum
A global or non-member function cannot be declared by the implementation
as taking additional default arguments.

\rSec3[lib.member.functions]{Member functions}

\pnum
It is unspecified whether any member functions in the \Cpp Standard Library are defined as
\tcode{inline}~(\ref{dcl.fct.spec}).

\pnum
An implementation can declare additional
non-virtual member function signatures within a
\indextext{function!virtual member}%
class:

\begin{itemize}
\item
by adding arguments with default values to a member function signature;%
\indextext{argument}%
\indextext{function!global}\footnote{Hence, taking the address of a member function
has an unspecified type.\indextext{address~of~member~function!unspecified}}
The same latitude does \term{not} extend to the implementation of virtual
or global or non-member functions, however.
\item
by replacing a member function signature with default values by two
or more member function signatures with equivalent behavior;
\item
by adding a member function signature for a member function name.
\end{itemize}

\pnum
A call to a member function signature described in the \Cpp Standard library
behaves the same as if the implementation declares no additional member
function signatures.\footnote{A valid \Cpp program always calls the expected library
member function, or one with equivalent behavior.
An implementation may also
define additional member functions that would otherwise not be called by a
valid \Cpp program.}

\rSec3[lib.reentrancy]{Reentrancy}

\pnum
Which of the functions in the \Cpp Standard Library are not
\term{reentrant subroutines} is
\impldef{which functions in
Standard C++ library may be recursively reentered}.

\rSec3[lib.protection.within.classes]{Protection within classes}

\pnum
\indextext{protection}%
It is unspecified whether a function signature or class described in
clauses~\ref{\firstlibchapter} through~\ref{\lastlibchapter} is a
\tcode{friend}
of another class in the \Cpp Standard Library.
\indextext{specifier!\tcode{friend}}

\rSec3[lib.derivation]{Derived classes}

\pnum
\indextext{class!derived}%
\indextext{class!base}%
It is unspecified whether a class in the \Cpp Standard Library is itself
derived from other classes (with names reserved to the implementation).

\pnum
Certain classes defined in the \Cpp Standard Library are derived from
other classes in the \Cpp Standard Library:

\begin{itemize}
\indextext{library!C++ standard}%
\item It is unspecified whether a class described in the \Cpp Standard Library
as derived from another class is derived from that class directly, or through
other classes (with names reserved to the implementation) that are derived
from the specified base class.
\end{itemize}

\pnum
In any case:

\begin{itemize}
\item
A base class described as
\tcode{virtual}
is always virtual;
\indextext{class!base}%
\item
A base class described as
non-\tcode{virtual}
is never virtual;
\indextext{class!base}%
\item
Unless explicitly stated otherwise, types with distinct names are distinct
types.\footnote{An implicit exception to this rule are types
described as synonyms for basic integral types, such as
\tcode{size_t}~(\ref{lib.support.types}) and
\tcode{streamoff}~(\ref{lib.stream.types}).}
\end{itemize}

\rSec3[lib.res.on.exception.handling]{Restrictions on exception handling}%
\indextext{restriction}%
\indextext{exception handling!handler}

\pnum
Any of the functions defined in the \Cpp Standard Library
\indextext{library!C++ standard}%
can report a failure by throwing an exception of the type(s) described in their
\synopsis{Throws:}
paragraph and/or their
\grammarterm{exception-specification}~(\ref{except.spec}).
An implementation may strengthen the
\grammarterm{exception-specification}
for a non-virtual function by removing listed exceptions.\footnote{That is,
an implementation of the function will have an explicit
\grammarterm{exception-specification}
that lists fewer exceptions than those specified in this International
Standard. It may not, however, change the types of exceptions listed in the
\grammarterm{exception-specification}
from those specified, nor add others.}

\pnum
None of the functions from the Standard C library shall report an error by
throwing an exception,%
\indextext{specifications!C standard library exception}\footnote{That is, the C
library functions all have a \tcode{throw()} \grammarterm{exception-specification}.
This allows implementations to make performance optimizations
based on the absence of exceptions at runtime.}
unless it calls a program-supplied function that throws an
exception.\footnote{The functions
\tcode{qsort()}
and
\tcode{bsearch()}~(\ref{lib.alg.c.library}) meet this condition.}

\pnum
No destructor operation defined in the \Cpp Standard Library
will throw an exception.
Any other functions defined in the
\Cpp Standard Library
\indextext{specifications!C++}%
that do not have an
\grammarterm{exception-specification}
may throw \impldef{exceptions thrown by standard library functions that do not have an
exception specification} exceptions
unless otherwise specified.\footnote{In particular, they
can report a failure to allocate storage by throwing an exception of type
\tcode{bad_alloc},
or a class derived from
\tcode{bad_alloc}~(\ref{lib.bad.alloc}).
Library implementations are encouraged (but not required) to
report errors by throwing exceptions from (or derived
from) the standard exception classes~(\ref{lib.bad.alloc},
\ref{lib.support.exception}, \ref{lib.std.exceptions}).}
An implementation may strengthen this implicit
\grammarterm{exception-specification}
by adding an explicit one.\footnote{That is, an implementation may provide an explicit
\grammarterm{exception-specification}
that defines the subset of ``any'' exceptions thrown by that function.
This implies that the implementation may list implementation-defined types
in such an
\indextext{types!implementation-defined exception}%
\indextext{specifications!implementation-defined exception}%
\grammarterm{exception-specification}.}
