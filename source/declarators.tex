\rSec0[dcl.decl]{Declarators}%
\indextext{declarator|(}

%gram: \rSec1[gram.dcl.decl]{Declarators}
%gram:

\indextext{initialization!class~object|seealso{constructor}}%
\indextext{\idxcode{*}|see{declarator, pointer}}
\indextext{\idxcode{\&}|see{declarator, reference}}%
\indextext{\idxcode{::*}|see{declarator, pointer to member}}%
\indextext{\idxcode{[]}|see{declarator, array}}%
\indextext{\idxcode{()}|see{declarator, function}}%

\pnum
A declarator declares a single object, function, or type, within a declaration.
The
\grammarterm{init-declarator-list}
appearing in a declaration
is a comma-separated sequence of declarators,
each of which can have an initializer.

\begin{bnf}
\nontermdef{init-declarator-list}\br
    init-declarator\br
    init-declarator-list \terminal{,} init-declarator
\end{bnf}

\begin{bnf}
\nontermdef{init-declarator}\br
    declarator initializer\opt
\end{bnf}

\pnum
The two components of a \grammarterm{declaration} are the
specifiers (\grammarterm{decl-specifier-seq};
\ref{dcl.spec}) and the declarators (\grammarterm{init-declarator-list}).
The specifiers indicate the type, storage class or other properties of
the objects, functions or typedefs being declared.
The declarators specify the names of these objects, functions or typedefs,
and (optionally) modify the type of the specifiers with operators such as
\tcode{*}
(pointer
to)
and
\tcode{()}
(function returning).
Initial values can also be specified in a declarator;
initializers are discussed in~\ref{dcl.init} and~\ref{class.init}.

\pnum
Each
\grammarterm{init-declarator}
in a declaration is analyzed separately as if it was in a declaration by
itself.\footnote{A declaration with several declarators is usually equivalent
to the corresponding sequence of declarations each with a single declarator.
That is

\tcode{T  D1, D2, ... Dn;}

\noindent is usually equivalent to

\tcode{T  D1; T D2; ... T Dn;}

\noindent where
\tcode{T}
is a
\grammarterm{decl-specifier-seq}
and each
\tcode{Di}
is a
\grammarterm{init-declarator}.
The exception occurs when a name introduced by one of the
\grammarterm{declarator}{s}
hides a type name used by the
\grammarterm{decl-specifiers},
so that when the same
\grammarterm{decl-specifiers}
are used in a subsequent declaration, they do not have the same meaning,
as in

\tcode{struct S \{ ... \}}\\
\indent\tcode{S   S, T;} \textit{// declare two instances of} \tcode{struct S}

\noindent which is not equivalent to

\tcode{struct S \{ ... \}}\\
\indent\tcode{S   S;}\\
\indent\tcode{S   T;} \textit{// error}
}

\pnum
Declarators have the syntax

\begin{bnf}
\nontermdef{declarator}\br
    direct-declarator\br
    ptr-operator declarator
\end{bnf}

\begin{bnf}
\nontermdef{direct-declarator}\br
    declarator-id\br
    direct-declarator \terminal{(} parameter-declaration-clause \terminal{)}
	cv-qualifier-seq\opt exception-specification\opt\br
    direct-declarator \terminal{[} constant-expression\opt \terminal{]}\br
    \terminal{(} declarator \terminal{)}
\end{bnf}

\begin{bnf}
\nontermdef{ptr-operator}\br
    \terminal{*} cv-qualifier-seq\opt\br
    \terminal{\&} \br
    \terminal{::}\opt nested-name-specifier \terminal{*} cv-qualifier-seq\opt
\end{bnf}

\begin{bnf}
\nontermdef{cv-qualifier-seq}\br
    cv-qualifier cv-qualifier-seq\opt
\end{bnf}

\begin{bnf}
\nontermdef{cv-qualifier}\br
    \terminal{const}\br
    \terminal{volatile}
\end{bnf}

\begin{bnf}
\nontermdef{declarator-id}\br
    id-expression\br
    \terminal{::}\opt nested-name-specifier\opt type-name
\end{bnf}

\indextext{class~name}%
A
\grammarterm{class-name}
has special meaning in a declaration of the class of that name
and when qualified by that name using the scope resolution operator
\tcode{::}
(\ref{expr.prim}, \ref{class.ctor}, \ref{class.dtor}).

\rSec1[dcl.name]{Type names}

\pnum
\indextext{type~name}%
To specify type conversions explicitly,
\indextext{operator!cast}%
and as an argument of
\tcode{sizeof},
\tcode{new},
or
\tcode{typeid},
the name of a type shall be specified.
This can be done with a
\grammarterm{type-id},
which is syntactically a declaration for an object or function
of that type that omits the name of the object or function.

\begin{bnf}
\nontermdef{type-id}\br
    type-specifier-seq abstract-declarator\opt
\end{bnf}

\begin{bnf}
\nontermdef{type-specifier-seq}\br
    type-specifier type-specifier-seq\opt
\end{bnf}

\begin{bnf}
\nontermdef{abstract-declarator}\br
    ptr-operator abstract-declarator\opt\br
    direct-abstract-declarator
\end{bnf}

\begin{bnftab}
\nontermdef{direct-abstract-declarator}\br
    \>direct-abstract-declarator\opt\br
	\>\>\terminal{(} parameter-declaration-clause \terminal{)}
	cv-qualifier-seq\opt exception-specification\opt\br
    \>direct-abstract-declarator\opt \terminal{[} constant-expression\opt{} \terminal{]}\br
    \>\terminal{(} abstract-declarator \terminal{)}
\end{bnftab}

It is possible to identify uniquely the location in the
\grammarterm{abstract-declarator}
where the identifier would appear if the construction were a declarator
in a declaration.
The named type is then the same as the type of the
hypothetical identifier.
\enterexample

\indextext{example!type~name}%
\indextext{example!declarator}%
\begin{codeblock}
int				// \tcode{int i}
int *				// \tcode{int *pi}
int *[3]			// \tcode{int *p[3]}
int (*)[3]			// \tcode{int (*p3i)[3]}
int *()				// \tcode{int *f()}
int (*)(double)			// \tcode{int (*pf)(double)}
\end{codeblock}

name respectively the types
``\tcode{int},''
``pointer to
\tcode{int},''
``array of 3 pointers to
\tcode{int},''
``pointer to array of 3
\tcode{int},''
``function of (no parameters) returning pointer to
\tcode{int},''
and ``pointer to a function of
(\tcode{double})
returning
\tcode{int}.''
\exitexample

\pnum
A type can also be named (often more easily) by using a
\grammarterm{typedef}
(\ref{dcl.typedef}).

\rSec1[dcl.ambig.res]{Ambiguity resolution}%
\indextext{ambiguity!declaration~versus cast}%
\indextext{declaration!parentheses~in}

\pnum
The ambiguity arising from the similarity between a function-style cast and
a declaration mentioned in~\ref{stmt.ambig} can also occur in the context of a declaration.
In that context, the choice is between a function declaration with
a redundant set of parentheses around a parameter name and an object declaration
with a function-style cast as the initializer.
Just as for the ambiguities mentioned in~\ref{stmt.ambig},
the resolution is to consider any construct that could possibly
be a declaration a declaration.
\enternote
a declaration can be explicitly disambiguated by a nonfunction-style
cast, by a
\tcode{=}
to indicate initialization or
by removing the redundant parentheses around the parameter name.
\exitnote
\enterexample

\begin{codeblock}
struct S {
    S(int);
};

void foo(double a)
{
    S w(int(a));		// function declaration
    S x(int());			// function declaration
    S y((int)a);		// object declaration
    S z = int(a);		// object declaration
}
\end{codeblock}
\exitexampleb

\pnum
The ambiguity arising from the similarity between a function-style
cast and a
\grammarterm{type-id}
can occur in different contexts.
The ambiguity appears as a choice between a function-style cast
expression and a declaration of a type.
The resolution is that any construct that could possibly be a
\grammarterm{type-id}
in its syntactic context shall be considered a
\grammarterm{type-id}.

\pnum
\enterexample

\begin{codeblock}
#include <cstddef>
char *p;
void *operator new(size_t, int);
void foo()  {
	const int x = 63;
	new (int(*p)) int;      // new-placement expression
	new (int(*[x]));        // new type-id
}
\end{codeblock}

\pnum
For another example,

\begin{codeblock}
template <class T>
struct S {
	T *p;
};
S<int()> x;                     // type-id
S<int(1)> y;                    // expression (ill-formed)
\end{codeblock}

\pnum
For another example,

\begin{codeblock}
void foo()
{
	sizeof(int(1));         // expression
	sizeof(int());          // type-id (ill-formed)
}
\end{codeblock}

\pnum
For another example,

\begin{codeblock}
void foo()
{
	(int(1));               // expression
	(int())1;               // type-id (ill-formed)
}
\end{codeblock}
\exitexampleb

\pnum
Another ambiguity arises in a
\grammarterm{parameter-declaration-clause}
of a function declaration, or in a
\grammarterm{type-id}
that is the operand of a
\tcode{sizeof}
or
\tcode{typeid}
operator, when a
\grammarterm{type-name}
is nested in parentheses.
In this case, the choice is between the declaration of a parameter of type
pointer to function and the declaration of a parameter with redundant
parentheses around the
\grammarterm{declarator-id}.
The resolution is to consider the
\grammarterm{type-name}
as a
\grammarterm{simple-type-specifier}
rather than a
\grammarterm{declarator-id}.
\enterexample

\begin{codeblock}
class C { };
void f(int(C)) { }              // \tcode{void f(int(*fp)(C c)) \{ \}}
                                // not: \tcode{void f(int C)};

int g(C);

void foo() {
	f(1);                   // error: cannot convert \tcode{1} to function pointer
	f(g);                   // OK
}
\end{codeblock}

For another example,

\begin{codeblock}
class C { };
void h(int *(C[10]));           // \tcode{void h(int *(*_fp)(C _parm[10]));}
                                // not: \tcode{void h(int *C[10]);}
\end{codeblock}
\exitexampleb

\rSec1[dcl.meaning]{Meaning of declarators}%
\indextext{declarator!meaning~of|(}

\pnum
A list of declarators appears after an optional (clause~\ref{dcl.dcl})
\grammarterm{decl-specifier-seq}
(\ref{dcl.spec}).
\indextext{declaration!type}%
Each declarator contains exactly one
\grammarterm{declarator-id};
it names the identifier that is declared.
An
\grammarterm{unqualified-id}
occurring in
a
\grammarterm{declarator-id}
shall be a simple
\grammarterm{identifier}
except for the declaration of some special functions
(\ref{class.conv}, \ref{class.dtor}, \ref{over.oper}) and
for the declaration of template specializations
or partial specializations (\ref{temp.spec}).
A
\grammarterm{declarator-id}
shall not be qualified except for the definition of a member
function (\ref{class.mfct}) or static data member (\ref{class.static})
outside of its class,
the definition or explicit instantiation of a
function or variable
member of a namespace
outside of its namespace, or
the definition of a previously declared explicit specialization
outside of its namespace, or
the declaration of a friend function that is a member of
another class or namespace (\ref{class.friend}).
When the
\grammarterm{declarator-id}
is qualified, the declaration shall refer to a previously declared member
of the class or namespace to which the qualifier refers, and the member
shall not have been introduced by a
\grammarterm{using-declaration}
in the scope of the class or namespace nominated by the
\grammarterm{nested-name-specifier}
of the
\grammarterm{declarator-id}.
\enternote
if the qualifier is the global
\tcode{::}
scope resolution operator, the
\grammarterm{declarator-id}
refers to a name declared in the global namespace scope.
\exitnote

\pnum
An
\tcode{auto},
\tcode{static},
\tcode{extern},
\tcode{register},
\tcode{mutable},
\tcode{friend},
\tcode{inline},
\tcode{virtual},
or
\tcode{typedef}
specifier applies directly to each
\grammarterm{declarator-id}
in a
\grammarterm{init-declarator-list};
the type specified for each
\grammarterm{declarator-id}
depends on both the
\grammarterm{decl-specifier-seq}
and its
\grammarterm{declarator}.

\pnum
Thus, a declaration of a particular identifier has the form

\begin{ncsimplebnf}
\terminal{T D}
\end{ncsimplebnf}

where
\tcode{T}
is a
\grammarterm{decl-specifier-seq}
and
\tcode{D}
is a declarator.
Following is a recursive procedure for determining
the type specified for the contained
\grammarterm{declarator-id}
by such a declaration.

\pnum
First, the
\grammarterm{decl-specifier-seq}
determines a type.
In a declaration

\begin{ncsimplebnf}
\terminal{T D}
\end{ncsimplebnf}

the
\grammarterm{decl-specifier-seq}
\tcode{T}
determines the type
``\tcode{T}.''
\enterexample
in the declaration

\begin{codeblock}
int unsigned i;
\end{codeblock}

the type specifiers
\tcode{int}
\tcode{unsigned}
determine the type
``\tcode{unsigned int}''
(\ref{dcl.type.simple}).
\exitexample

\pnum
In a declaration
\tcode{T}
\tcode{D}
where
\tcode{D}
is an unadorned identifier the type of this identifier is
``\tcode{T}''.

\pnum
In a declaration
\tcode{T}
\tcode{D}
where
\tcode{D}
has the form

\begin{ncsimplebnf}
\terminal{( D1 )}
\end{ncsimplebnf}

the type of the contained
\grammarterm{declarator-id}
is the same as that of the contained
\grammarterm{declarator-id}
in the declaration

\begin{ncsimplebnf}
\terminal{T D1}
\end{ncsimplebnf}

\indextext{declaration!parentheses~in}%
Parentheses do not alter the type of the embedded
\grammarterm{declarator-id},
but they can alter the binding of complex declarators.

\rSec2[dcl.ptr]{Pointers}%
\indextext{declarator!pointer}%

\pnum
In a declaration
\tcode{T}
\tcode{D}
where
\tcode{D}
has the form

\begin{ncsimplebnf}
\terminal{*} cv-qualifier-seq\opt \terminal{D1}
\end{ncsimplebnf}

and the type of the identifier in the declaration
\tcode{T}
\tcode{D1}
is ``\nonterminal{derived-declarator-type-list}
\tcode{T},''
then the type of the identifier of
\tcode{D}
is ``\nonterminal{derived-declarator-type-list cv-qualifier-seq} pointer to
\tcode{T}.''
\indextext{declaration!pointer}%
\indextext{declaration!constant~pointer}%
The
\grammarterm{cv-qualifier}{s}
apply to the pointer and not to the object pointed to.

\pnum
\enterexample
the declarations
\indextext{example!\idxcode{const}}%
\indextext{example!constant pointer}%
\begin{codeblock}
const int ci = 10, *pc = &ci, *const cpc = pc, **ppc;
int i, *p, *const cp = &i;
\end{codeblock}

declare
\tcode{ci},
a constant integer;
\tcode{pc},
a pointer to a constant integer;
\tcode{cpc},
a constant pointer to a constant integer;
\tcode{ppc},
a pointer to a pointer to a constant integer;
\tcode{i},
an integer;
\tcode{p},
a pointer to integer; and
\tcode{cp},
a constant pointer to integer.
The value of
\tcode{ci},
\tcode{cpc},
and
\tcode{cp}
cannot be changed after initialization.
The value of
\tcode{pc}
can be changed, and so can the object pointed to by
\tcode{cp}.
Examples of
some correct operations are

\begin{codeblock}
i = ci;
*cp = ci;
pc++;
pc = cpc;
pc = p;
ppc = &pc;
\end{codeblock}

Examples of ill-formed operations are

\begin{codeblock}
ci = 1;				// error
ci++;				// error
*pc = 2;			// error
cp = &ci;			// error
cpc++;				// error
p = pc;				// error
ppc = &p;			// error
\end{codeblock}

Each is unacceptable because it would either change the value of an object declared
\tcode{const}
or allow it to be changed through a cv-unqualified pointer later, for example:

\begin{codeblock}
*ppc = &ci;			// OK, but would make \tcode{p} point to \tcode{ci} ...
				// ... because of previous error
*p = 5;				// clobber \tcode{ci}
\end{codeblock}
\exitexampleb

\pnum
See also~\ref{expr.ass} and~\ref{dcl.init}.

\pnum
\enternote
there are no pointers to references; see~\ref{dcl.ref}.
Since the address of a bit-field (\ref{class.bit}) cannot be taken,
a pointer can never point to a bit-field.
\exitnote

\rSec2[dcl.ref]{References}%
\indextext{declarator!reference}

\pnum
In a declaration
\tcode{T}
\tcode{D}
where
\tcode{D}
has the forms

\begin{ncsimplebnf}
\terminal{\&} \terminal{D1}
\end{ncsimplebnf}

and the type of the identifier in the declaration
\tcode{T}
\tcode{D1}
is ``\nonterminal{derived-declarator-type-list}
\tcode{T},''
then the type of the identifier of
\tcode{D}
is ``\nonterminal{derived-declarator-type-list} reference to
\tcode{T}.''
Cv-qualified references are ill-formed except when the cv-qualifiers
are introduced through the use of a typedef (\ref{dcl.typedef}) or
of a template type argument (\ref{temp.arg}),
in which case the cv-qualifiers are ignored.
\enterexample
in

\begin{codeblock}
typedef int& A;
const A aref = 3;		// ill-formed;
				// non-\tcode{const} reference initialized with rvalue
\end{codeblock}

the type of
\tcode{aref}
is ``reference to \tcode{int}'',
not ``\tcode{const} reference to \tcode{int}''.
\exitexample
\indextext{\idxcode{void\&}}%
\enternote
a reference can be thought of as a name of an object.
\exitnote
A declarator that specifies the type
``reference to \textit{cv} \tcode{void}''
is ill-formed.


\pnum
\indextext{declaration!reference}%
\indextext{parameter!reference}%
\enterexample

\begin{codeblock}
void f(double& a) { a += 3.14; }
// ...
double d = 0;
f(d);
\end{codeblock}

declares
\tcode{a}
to be a reference parameter of
\tcode{f}
so the call
\tcode{f(d)}
will add
\tcode{3.14}
to
\tcode{d}.

\begin{codeblock}
int v[20];
// ...
int& g(int i) { return v[i]; }
// ...
g(3) = 7;
\end{codeblock}

declares the function
\tcode{g()}
to return a reference to an integer so
\tcode{g(3)=7}
will assign
\tcode{7}
to the fourth element of the array
\tcode{v}.
For another example,

\begin{codeblock}
struct link {
    link* next;
};

link* first;

void h(link*& p)		// \tcode{p} is a reference to pointer
{
    p->next = first;
    first = p;
    p = 0;
}

void k()
{
	link* q = new link;
	h(q);
}
\end{codeblock}

declares
\tcode{p}
to be a reference to a pointer to
\tcode{link}
so
\tcode{h(q)}
will leave
\tcode{q}
with the value zero.
See also~\ref{dcl.init.ref}.
\exitexample

\pnum
It is unspecified whether or not
a reference requires storage (\ref{basic.stc}).

\pnum
\indextext{restriction!reference}%
There shall be no references to references,
no arrays of references, and no pointers to references.
\indextext{initialization!reference}%
The declaration of a reference shall contain an
\grammarterm{initializer}
(\ref{dcl.init.ref})
except when the declaration contains an explicit
\tcode{extern}
specifier (\ref{dcl.stc}),
is a class member (\ref{class.mem}) declaration within a class definition,
or is the declaration of a parameter or a return type (\ref{dcl.fct}); see~\ref{basic.def}.
A reference shall be initialized to refer to a valid object or function.
\enternote
\indextext{reference!null}%
in particular, a null reference cannot exist in a well-defined program,
because the only way to create such a reference would be to bind it to
the ``object'' obtained by dereferencing a null pointer,
which causes undefined behavior.
As described in~\ref{class.bit}, a reference cannot be bound directly
to a bit-field.
\exitnote

\rSec2[dcl.mptr]{Pointers to members}%
\indextext{declarator!pointer to member}

\pnum
In a declaration
\tcode{T}
\tcode{D}
where
\tcode{D}
has the form

\begin{ncsimplebnf}
\terminal{::}\opt nested-name-specifier \terminal{*} cv-qualifier-seq\opt \tcode{D1}
\end{ncsimplebnf}

and the
\grammarterm{nested-name-specifier}
names a class,
and the type of the identifier in the declaration
\tcode{T}
\tcode{D1}
is ``\nonterminal{derived-declarator-type-list}
\tcode{T},''
then the type of the identifier of
\tcode{D}
is ``\nonterminal{derived-declarator-type-list cv-qualifier-seq} pointer to member of class
\nonterminal{nested-name-specifier} of type
\tcode{T}.''

\pnum
\enterexample%
\indextext{example!pointer~to~member}

\begin{codeblock}
class X {
public:
    void f(int);
    int a;
};
class Y;

int X::* pmi = &X::a;
void (X::* pmf)(int) = &X::f;
double X::* pmd;
char Y::* pmc;
\end{codeblock}

declares
\tcode{pmi},
\tcode{pmf},
\tcode{pmd}
and
\tcode{pmc}
to be a pointer to a member of
\tcode{X}
of type
\tcode{int},
a pointer to a member of
\tcode{X}
of type
\tcode{void(int)},
a pointer to a member of
\tcode{X}
of type
\tcode{double}
and a pointer to a member of
\tcode{Y}
of type
\tcode{char}
respectively.
The declaration of
\tcode{pmd}
is well-formed even though
\tcode{X}
has no members of type
\tcode{double}.
Similarly, the declaration of
\tcode{pmc}
is well-formed even though
\tcode{Y}
is an incomplete type.
\tcode{pmi}
and
\tcode{pmf}
can be used like this:

\begin{codeblock}
X obj;
// ...
obj.*pmi = 7;			// assign \tcode{7} to an integer
				// member of \tcode{obj}
(obj.*pmf)(7);			// call a function member of \tcode{obj}
				// with the argument \tcode{7}
\end{codeblock}
\exitexampleb

\pnum
A pointer to member shall not point to a static member
of a class (\ref{class.static}),
a member with reference type,
or
``\textit{cv}
\tcode{void}.''
\enternote
see also~\ref{expr.unary} and~\ref{expr.mptr.oper}.
The type ``pointer to member'' is distinct from the type ``pointer'',
that is, a pointer to member is declared only by the pointer to member
declarator syntax, and never by the pointer declarator syntax.
There is no ``reference-to-member'' type in \Cpp.
\exitnote

\rSec2[dcl.array]{Arrays}%
\indextext{declarator!array}

\pnum
In a declaration
\tcode{T}
\tcode{D}
where
\tcode{D}
has the form

\begin{ncsimplebnf}
\terminal{D1 [} constant-expression\opt \terminal{]}
\end{ncsimplebnf}

and the type of the identifier in the declaration
\tcode{T}
\tcode{D1}
is
``\grammarterm{derived-declarator-type-list}
\tcode{T},''
then the type of the identifier of
\tcode{D}
is an array type.
\tcode{T}
is called the array
\term{element type};
this type shall not be a reference type, the (possibly cv-qualified) type
\tcode{void},
a function type or an abstract class type.
\indextext{declaration!array}%
If the
\grammarterm{constant-expression}
(\ref{expr.const}) is present, it shall be an integral constant expression and
its value shall be greater than zero.
The constant expression specifies the
\indextext{array!bound}%
\indextext{bound,~of~array}%
\term{bound}
of (number of elements in) the array.
If the value of the constant expression is
\tcode{N},
the array has
\tcode{N}
elements numbered
\tcode{0}
to
\tcode{N-1},
and the type of the identifier of
\tcode{D}
is ``\nonterminal{derived-declarator-type-list} array of
\tcode{N}
\tcode{T}.''
An object of array type contains a contiguously allocated non-empty set of
\tcode{N}
sub-objects of type
\tcode{T}.
If the constant expression is omitted, the type of the identifier of
\tcode{D}
is ``\nonterminal{derived-declarator-type-list} array of unknown bound of
\tcode{T},''
an incomplete object type.
The type ``\nonterminal{derived-declarator-type-list} array of
\tcode{N}
\tcode{T}''
is a different type from the type
``\nonterminal{derived-declarator-type-list} array of unknown bound of
\tcode{T},''
see~\ref{basic.types}.
Any type of the form
``\nonterminal{cv-qualifier-seq} array of
\tcode{N}
\tcode{T}''
is adjusted to
``array of
\tcode{N}
\nonterminal{cv-qualifier-seq}
\tcode{T},''
and similarly for
``array of unknown bound of
\tcode{T}.''
\enterexample

\begin{codeblock}
typedef int A[5], AA[2][3];
typedef const A CA;             // type is ``array of 5 const int''
typedef const AA CAA;           // type is ``array of 2 array of 3 const int''
\end{codeblock}
\exitexampleb
\enternote
an
``array of
\tcode{N}
\nonterminal{cv-qualifier-seq}
\tcode{T}''
has cv-qualified type; such an array has internal linkage unless explicitly
declared \tcode{extern}~(\ref{dcl.type.cv}) and must be initialized as
specified in~\ref{dcl.init}.
\exitnote

\pnum
An array can be constructed from one of the fundamental types
(except
\tcode{void}),
from a pointer,
from a pointer to member, from a class,
from an enumeration type,
or from another array.

\pnum
When several ``array of'' specifications are adjacent, a multidimensional
array is created;
the constant expressions that specify the bounds
of the arrays can be omitted only for the first member of the sequence.
\enternote
this elision is useful for function parameters of array types, and when the
array is external and the definition, which allocates storage, is given
elsewhere.
\exitnote
The first \grammarterm{constant-expression} can
also be omitted
when the declarator is followed by an
\grammarterm{initializer}
(\ref{dcl.init}).
In this case the bound is calculated from the number
\indextext{array~size!default}%
of initial elements (say,
\tcode{N})
supplied
(\ref{dcl.init.aggr}), and the type of the identifier of
\tcode{D}
is ``array of
\tcode{N}
\tcode{T}.''

\pnum
\enterexample
\indextext{example!subscripting}%
\indextext{example!array}%
\begin{codeblock}
float fa[17], *afp[17];
\end{codeblock}

declares an array of
\tcode{float}
numbers and an array of
pointers to
\tcode{float}
numbers.
\indextext{declarator!multidimensional array}%
For another example,

\begin{codeblock}
static int x3d[3][5][7];
\end{codeblock}

declares a static three-dimensional array of integers,
with rank $3 \times 5 \times 7$.
In complete detail,
\tcode{x3d}
is an array of three items;
each item is an array of five arrays;
each of the latter arrays is an array of seven
integers.
Any of the expressions
\tcode{x3d},
\tcode{x3d[i]},
\tcode{x3d[i][j]},
\tcode{x3d[i][j][k]}
can reasonably appear in an expression.
\exitexample

\pnum
\enternote
conversions affecting lvalues of array type are described in~\ref{conv.array}.
Objects of array types cannot be modified, see~\ref{basic.lval}.
\exitnote

\pnum
Except where it has been declared for a class (\ref{over.sub}),
the subscript operator
\tcode{[]}
is interpreted
in such a way that
\tcode{E1[E2]}
is identical to
\tcode{*((E1)+(E2))}.
Because of the conversion rules
that apply to
\tcode{+},
if
\tcode{E1}
is an array and
\tcode{E2}
an integer,
then
\tcode{E1[E2]}
refers to the
\tcode{E2}-th
member of
\tcode{E1}.
Therefore,
despite its asymmetric
appearance, subscripting is a commutative operation.

\pnum
A consistent rule is followed for
\indextext{array!multidimensional}%
multidimensional arrays.
If
\tcode{E}
is an
\textit{n}-dimensional
array
of rank
$i \times j \times \ldots \times k$,
then
\tcode{E}
appearing in an expression
is converted to
a pointer to an $(n-1)$-dimensional
array with rank
$j \times \ldots \times k$.
If the
\tcode{*}
operator, either explicitly
or implicitly as a result of subscripting,
is applied to this pointer,
the result is the pointed-to $(n-1)$-dimensional array,
which itself is immediately converted into a pointer.

\pnum
\enterexample
consider

\begin{codeblock}
int x[3][5];
\end{codeblock}

Here
\tcode{x}
is a $3 \times 5$ array of integers.
When
\tcode{x}
appears in an expression, it is converted
to a pointer to (the first of three) five-membered arrays of integers.
In the expression
\tcode{x[i]},
which is equivalent to
\tcode{*(x+i)},
\tcode{x}
is first converted to a pointer as described;
then
\tcode{x+i}
is converted to the type of
\tcode{x},
which involves multiplying
\tcode{i}
by the
length of the object to which the pointer points,
namely five integer objects.
The results are added and indirection applied to
yield an array (of five integers), which in turn is converted to
a pointer to the first of the integers.
If there is another subscript the same argument applies
again; this time the result is an integer.
\exitexample

\pnum
\enternote
it follows from all this that arrays in \Cpp are stored
row-wise (last subscript varies fastest)
\indextext{array!storage~of}%
and that the first subscript in the declaration helps determine
the amount of storage consumed by an array
but plays no other part in subscript calculations.
\exitnote

\rSec2[dcl.fct]{Functions}%
\indextext{declarator!function|(}

\pnum
\indextext{type!function}%
In a declaration
\tcode{T}
\tcode{D}
where
\tcode{D}
has the form

\begin{ncsimplebnf}
\terminal{D1 (} parameter-declaration-clause \terminal{)} cv-qualifier-seq\opt
exception-specification\opt
\end{ncsimplebnf}

and the type of the contained
\grammarterm{declarator-id}
in the declaration
\tcode{T}
\tcode{D1}
is
``\grammarterm{derived-declarator-type-list}
\tcode{T},''
the type of the
\grammarterm{declarator-id}
in
\tcode{D}
is ``\nonterminal{derived-declarator-type-list} function of
(\nonterminal{parameter-declaration-clause} )
\nonterminal{cv-qualifier-seq\opt} returning
\tcode{T}'';
a type of this form is a \term{function type}\footnote{As indicated by the
syntax, cv-qualifiers are a significant component in function return types.}.

\indextext{declaration!function}%
\begin{bnf}
\nontermdef{parameter-declaration-clause}\br
    parameter-declaration-list\opt \terminal{...}\opt\br
    parameter-declaration-list \terminal{,} \terminal{...}
\end{bnf}

\begin{bnf}
\nontermdef{parameter-declaration-list}\br
    parameter-declaration\br
    parameter-declaration-list \terminal{,} parameter-declaration
\end{bnf}

\begin{bnf}
\nontermdef{parameter-declaration}\br
    decl-specifier-seq declarator\br
    decl-specifier-seq declarator \terminal{=} assignment-expression\br
    decl-specifier-seq abstract-declarator\opt\br
    decl-specifier-seq abstract-declarator\opt \terminal{=} assignment-expression
\end{bnf}

\pnum
\indextext{declaration!parameter}%
The
\grammarterm{parameter-declaration-clause}
determines the arguments that can be specified, and their processing, when the function is called.
\enternote
\indextext{conversion!argument}%
the
\grammarterm{parameter-declaration-clause}
is used to convert the arguments specified on the function call;
see~\ref{expr.call}.
\exitnote
\indextext{argument~list!empty}%
If the
\grammarterm{parameter-declaration-clause}
is empty, the function takes no arguments.
The parameter list
\tcode{(void)}
is equivalent to the empty parameter list.
\indextext{parameter!\idxcode{void}}%
Except for this special case,
\tcode{void}
shall not be a parameter type
(though types derived from
\tcode{void},
such as
\tcode{void*},
can).
If the
\grammarterm{parameter-declaration-clause}
\indextext{argument~type!unknown}%
\indextext{\idxcode{...}|see{ellipsis}}%
\indextext{declaration!ellipsis~in function}%
\indextext{argument~list!variable}%
\indextext{parameter~list!variable}%
terminates with an ellipsis, the number of arguments shall be equal
to or greater than the number of parameters specified.
Where syntactically correct,
``\tcode{, ...}''
is synonymous with
``\tcode{...}''.
\enterexample
\indextext{example!ellipsis}%
\indextext{example!variable parameter~list}%
the declaration

\begin{codeblock}
int printf(const char*, ...);
\end{codeblock}

declares a function that can be called with varying numbers and types of arguments.

\begin{codeblock}
printf("hello world");
printf("a=%d b=%d", a, b);
\end{codeblock}

However, the first argument must be of a type
that can be converted to a
\tcode{const}
\tcode{char*}
\exitexample
\enternote
the standard header
\tcode{<cstdarg>}
\indextext{\idxhdr{cstdarg}}%
contains a mechanism for accessing arguments passed using the ellipsis
(see~\ref{expr.call} and~\ref{lib.support.runtime}).
\exitnote

\pnum
\indextext{overloading}%
\indextext{type!function}%
A single name can be used for several different functions in a single scope;
this is function overloading (clause~\ref{over}).
All declarations for a function with a given parameter list shall agree exactly
both in the type of the value returned and in the number and type of
parameters; the presence or absence of the ellipsis is considered part of the
function type.
The type of a function is determined using the following rules.
The type of each parameter is
determined from its own
\grammarterm{decl-specifier-seq}
and
\grammarterm{declarator}.
After determining the type of each parameter, any parameter of type ``array of
\indextext{array}%
\indextext{type!array}%
\tcode{T}''
\indextext{function}%
\indextext{type!function}%
or ``function returning
\tcode{T}''
is adjusted to be ``pointer to
\tcode{T}''
or ``pointer to function returning
\tcode{T},''
respectively.
After producing the list of parameter types,
several transformations take place upon these types to determine the function
type. Any
\grammarterm{cv-qualifier}
modifying a parameter type is deleted.
\enterexample
the type \tcode{void(*)(const int)} becomes \tcode{void(*)(int)}
\exitexampleb
Such \grammarterm{cv-qualifier}{s} affect only the definition of the
parameter within the body of the function; they do not affect the function
type. If a \grammarterm{storage-class-specifier} modifies a parameter type,
the specifier is deleted.
\enterexample
\tcode{register char*} becomes \tcode{char*}
\exitexampleb
Such \grammarterm{storage-class-specifier}{s} affect only the definition
of the parameter within the body of the function; they do not affect the
function type. The resulting list of transformed parameter type is the
function's \term{parameter type list}.

\pnum
A
\grammarterm{cv-qualifier-seq}
shall only be part of
the function type for a nonstatic member function,
the function type to which a pointer to member refers,
or the top-level function type of a function typedef declaration.
The effect of a
\grammarterm{cv-qualifier-seq}
in a function declarator is not the same as
adding cv-qualification on top of the function type, i.e., it does not
create a cv-qualified function type.
In fact, if at any time in the determination of a type a cv-qualified
function type is formed, the program is ill-formed.
\enterexample

\begin{codeblock}
typedef void F();
struct S {
	const F f;		// ill-formed:
				// not equivalent to: \tcode{void f() const;}
};
\end{codeblock}
\exitexampleb
The return type, the parameter type list and the
\grammarterm{cv-qualifier-seq},
but not the default arguments (\ref{dcl.fct.default})
or the exception specification (\ref{except.spec}),
are part of the function type.
\enternote
function types are checked during the assignments and initializations of
pointers-to functions, references-to-functions, and pointers-to-member-functions.
\exitnote

\pnum
\enterexample
\indextext{example!function declaration}%
the declaration

\begin{codeblock}
int fseek(FILE*, long, int);
\end{codeblock}

declares a function taking three arguments of the specified types,
and returning
\tcode{int}
(\ref{dcl.type}).
\exitexample

\pnum
If the type of a parameter includes a type of the form
``pointer to array of unknown bound of \tcode{T}'' or
``reference to array of unknown bound of \tcode{T},''
the program is ill-formed.\footnote{This excludes parameters of type
``\nonterminal{ptr-arr-seq} \tcode{T2}'' where \tcode{T2} is
``pointer to array of unknown bound of \tcode{T}'' and where
\nonterminal{ptr-arr-seq} means any sequence of ``pointer to'' and
``array of'' derived declarator types.
This exclusion applies to the parameters of the function,
and if a parameter is a pointer to function
or pointer to member function then to its
parameters also, etc.
}
\indextext{function~return~type|see{return~type}}%
\indextext{return~type}%
Functions shall not have a return type of type array or function,
although they may have a return type of type pointer or reference to such things.
There shall be no arrays of functions, although there can be arrays of pointers
to functions.
Types shall not be defined in return or parameter types.
The type of a parameter or the return type for a function
definition shall not be an incomplete class type (possibly
cv-qualified) unless the function definition is nested
within the
\grammarterm{member-specification}
for that class (including definitions in nested classes
defined within the class).

\pnum
\indextext{typedef!function}%
A typedef of function type may be used to declare a function but shall not be
used to define a function (\ref{dcl.fct.def}).
\enterexample

\begin{codeblock}
typedef void F();
F  fv;				// OK: equivalent to \tcode{void fv();}
F  fv { }			// ill-formed
void fv() { }			// OK: definition of \tcode{fv}
\end{codeblock}
\exitexampleb
A typedef of a function type whose declarator includes a
\grammarterm{cv-qualifier-seq}
shall be used only to declare the function type for a nonstatic member function,
to declare the function type to which a pointer to member refers,
or to declare the top-level function type of another function typedef
declaration.
\enterexample

\begin{codeblock}
typedef int FIC(int) const;
FIC f;				// ill-formed: does not declare a member function
struct S {
	FIC f;			// OK
};
FIC S::*pm = &S::f;		// OK
\end{codeblock}
\exitexampleb

\pnum
An identifier can optionally be provided as a parameter name;
if present in a function definition (\ref{dcl.fct.def}), it names a parameter (sometimes called ``formal argument'').
\enternote
in particular, parameter names are also optional in function definitions
and names used for a parameter in different declarations and the definition
of a function need not be the same.
If a parameter name is present in a function declaration that is not a definition,
it cannot be used outside of
the \grammarterm{parameter-declaration-clause} since it goes out of scope
at the end of the function declarator~(\ref{basic.scope}).
\exitnote

\pnum
\enterexample
the declaration

\indextext{example!declaration}%
\begin{codeblock}
int i,
    *pi,
    f(),
    *fpi(int),
    (*pif)(const char*, const char*),
    (*fpif(int))(int);
\end{codeblock}

declares an integer
\tcode{i},
a pointer
\tcode{pi}
to an integer,
a function
\tcode{f}
taking no arguments and returning an integer,
a function
\tcode{fpi}
taking an integer argument and returning a pointer to an integer,
a pointer
\tcode{pif}
to a function which
takes two pointers to constant characters and returns an integer,
a function
\tcode{fpif}
taking an integer argument and returning a pointer to a function that takes an integer argument and returns an integer.
It is especially useful to compare
\tcode{fpi}
and
\tcode{pif}.
The binding of
\tcode{*fpi(int)}
is
\tcode{*(fpi(int))},
so the declaration suggests,
and the same construction in an expression
requires, the calling of a function
\tcode{fpi},
and then using indirection through the (pointer) result
to yield an integer.
In the declarator
\tcode{(*pif)(const char*, const char*)},
the extra parentheses are necessary to indicate that indirection through
a pointer to a function yields a function, which is then called.
\exitexample
\enternote
typedefs are sometimes convenient when the return type of a function is complex.
For example,
the function
\tcode{fpif}
above could have been declared

\begin{codeblock}
typedef int  IFUNC(int);
IFUNC*  fpif(int);
\end{codeblock}
\exitnoteb

\indextext{declarator!function|)}

\rSec2[dcl.fct.default]{Default arguments}%
\indextext{declaration!default argument|(}

\pnum
If an expression is specified in a parameter declaration this exception
is used as a default argument.
Default arguments will be used in calls where trailing arguments are missing.

\pnum
\indextext{argument!example~of default}%
\enterexample
the declaration

\begin{codeblock}
void point(int = 3, int = 4);
\end{codeblock}

declares a function that can be called with zero, one, or two arguments of type
\tcode{int}.
It can be called in any of these ways:

\begin{codeblock}
point(1,2);  point(1);  point();
\end{codeblock}

The last two calls are equivalent to
\tcode{point(1,4)}
and
\tcode{point(3,4)},
respectively.
\exitexample

\pnum
A default argument expression shall be specified only in the
\grammarterm{parameter-declaration-clause}
of a function declaration or in a
\grammarterm{template-parameter}
(\ref{temp.param}).
If it is specified in a
\grammarterm{parameter-declaration-clause},
it shall not occur within a
\grammarterm{declarator}
or
\grammarterm{abstract-declarator}
of a
\grammarterm{parameter-declaration}.\footnote{This means that default
arguments cannot appear,
for example, in declarations of pointers to functions,
references to functions, or
\tcode{typedef}
declarations.
}

\pnum
For non-template functions, default arguments can be added in later
declarations of a
function in the same scope.
Declarations in different
scopes have completely distinct sets of default arguments.
That
is, declarations in inner scopes do not acquire default
arguments from declarations in outer scopes, and vice versa.
In
a given function declaration, all parameters subsequent to a
parameter with a default argument shall have default arguments
supplied in this or previous declarations.
A default argument
shall not be redefined by a later declaration (not even to the
same value).
\enterexample

\begin{codeblock}
void f(int, int);
void f(int, int = 7);
void h()
{
    f(3);                       // OK, calls \tcode{f(3, 7)}
    void f(int = 1, int);       // error: does not use default
                                // from surrounding scope
}
void m()
{
    void f(int, int);           // has no defaults
    f(4);                       // error: wrong number of arguments
    void f(int, int = 5);       // OK
    f(4);                       // OK, calls \tcode{f(4, 5);}
    void f(int, int = 5);       // error: cannot redefine, even to
                                // same value
}
void n()
{
    f(6);                       // OK, calls \tcode{f(6, 7)}
}
\end{codeblock}
\exitexampleb
For a given inline function defined in different translation units,
the accumulated sets of default arguments at the end of the
translation units shall be the same;
see~\ref{basic.def.odr}.

\pnum
\indextext{argument!type~checking~of default}%
\indextext{argument!binding~of default}%
\indextext{argument!evaluation~of default}%
A default argument expression is implicitly converted (clause~\ref{conv})
to the parameter type.
The default argument expression has the
same semantic constraints as the initializer expression in a
declaration of a variable of the parameter type, using the
copy-initialization semantics (\ref{dcl.init}).
The names in the expression
are bound, and the semantic constraints are checked,
at the point where the default argument expression appears.
Name lookup and checking of semantic constraints for default
arguments in function templates and in member functions of
class templates are performed as described in~\ref{temp.inst}.
\enterexample
in the following code,
\indextext{argument!example~of default}%
\tcode{g}
will be called with the value
\tcode{f(2)}:

\begin{codeblock}
int a = 1;
int f(int);
int g(int x = f(a));            // default argument: \tcode{f(::a)}

void h() {
    a = 2;
    {
	int a = 3;
	g();                    // \tcode{g(f(::a))}
    }
}
\end{codeblock}
\exitexampleb
\enternote
in member function declarations,
names in default arguments expressions are looked up
as described in~\ref{basic.lookup.unqual}.
Access checking applies to names in default arguments expressions as
described in clause~\ref{class.access}.
\exitnote

\pnum
Except for member functions of class templates, the
default arguments in a member function definition that appears
outside of the class definition
are added to the set of default arguments provided by the
member function declaration in the class definition.
Default arguments for a member function of a class template
shall be specified on the initial declaration of the member
function within the class template.
\enterexample

\begin{codeblock}
class C {
	void f(int i = 3);
	void g(int i, int j = 99);
};

void C::f(int i = 3)            // error: default argument already
{ }                             // specified in class scope
void C::g(int i = 88, int j)    // in this translation unit,
{ }                             // \tcode{C::g} can be called with no argument
\end{codeblock}
\exitexampleb

\pnum
Local variables shall not be used in a default argument expression.
\enterexample

\begin{codeblock}
void f()
{
    int i;
    extern void g(int x = i);   // error
    // ...
}
\end{codeblock}
\exitexampleb

\pnum
The keyword
\tcode{this}
shall not be used in a default argument of a member function.
\enterexample

\begin{codeblock}
class A {
    void f(A* p = this) { }     // error
};
\end{codeblock}
\exitexampleb

\pnum
\indextext{argument!evaluation~of default}%
Default arguments are evaluated each time the function is called.
The order of evaluation of function arguments is
unspecified.
\indextext{arguments!implementation-defined order~of~evaluation~of function}%
\indextext{argument!scope~of default}%
Consequently,
parameters of a function shall not be used in a default argument expressions,
even if they are not evaluated.
\indextext{argument~and~name~hiding!default}%
Parameters of a function declared before a default argument expression
are in scope and can hide namespace and class member names.
\enterexample

\begin{codeblock}
int a;
int f(int a, int b = a);		// error: parameter \tcode{a}
					// used as default argument
typedef int I;
int g(float I, int b = I(2));		// error: parameter \tcode{I} found
int h(int a, int b = sizeof(a));	// error, parameter \tcode{a} used
					// in default argument
\end{codeblock}
\exitexampleb
Similarly, a nonstatic member shall not be used in a default argument
expression, even if it is not evaluated, unless it appears as
the \grammarterm{id-expression} of a class member access expression (\ref{expr.ref}) or
unless it is used to form a pointer to member (\ref{expr.unary.op}).
\enterexample
the declaration of
\tcode{X::mem1()}
in the following example is ill-formed because no object is supplied for the
nonstatic member
\tcode{X::a}
used as an initializer.

\begin{codeblock}
int b;
class X {
    int a;
    int mem1(int i = a);        // error: nonstatic member \tcode{a}
                                // used as default argument
    int mem2(int i = b);        // OK;  use \tcode{X::b}
    static int b;
};
\end{codeblock}

The declaration of
\tcode{X::mem2()}
is meaningful, however, since no object is needed to access the static member
\tcode{X::b}.
Classes, objects, and members are described in clause~\ref{class}.
\exitexample
A default argument is not part of the
type of a function.
\enterexample

\begin{codeblock}
int f(int = 0);

void h()
{
    int j = f(1);
    int k = f();                // OK, means \tcode{f(0)}
}

int (*p1)(int) = &f;
int (*p2)() = &f;               // error: type mismatch
\end{codeblock}
\exitexampleb
When a declaration of a function is introduced by way of a
\grammarterm{using-declaration}
(\ref{namespace.udecl}), any default argument information associated
with the declaration is made known as well.
If the function is redeclared
thereafter in the namespace with additional default arguments,
the additional arguments are also known at any point following
the redeclaration where the
\grammarterm{using-declaration}
is in scope.

\pnum
\indextext{argument~and~virtual~function!default}%
A virtual function call (\ref{class.virtual}) uses the default
arguments in the declaration of the virtual function determined
by the static type of the pointer or reference denoting the
object.
An overriding function in a derived class does not
acquire default arguments from the function it overrides.
\enterexample

\begin{codeblock}
struct A {
    virtual void f(int a = 7);
};
struct B : public A {
    void f(int a);
};
void m()
{
    B* pb = new B;
    A* pa = pb;
    pa->f();			// OK, calls \tcode{pa->B::f(7)}
    pb->f();			// error: wrong number of arguments for \tcode{B::f()}
}
\end{codeblock}
\exitexampleb%
\indextext{declaration!default argument|)}%
\indextext{declarator!meaning~of|)}

\rSec1[dcl.fct.def]{Function definitions}%
\indextext{definition!function|(}

\pnum
\indextext{body!function}%
Function definitions have the form

\indextext{\idxgram{function-definition}}%
%
\begin{bnf}
\nontermdef{function-definition}\br
    decl-specifier-seq\opt declarator ctor-initializer\opt function-body\br
    decl-specifier-seq\opt declarator function-try-block
\end{bnf}

\begin{bnf}
function-body:\br
    compound-statement
\end{bnf}

The
\grammarterm{declarator}
in a
\grammarterm{function-definition}
shall have the form

\begin{ncsimplebnf}
\terminal{D1 (} parameter-declaration-clause \terminal{)} cv-qualifier-seq\opt
exception-specification\opt
\end{ncsimplebnf}

as described in~\ref{dcl.fct}.
A function shall be defined only in namespace or class scope.

\pnum
\enterexample
a simple example of a complete function definition is

\indextext{example!function definition}%
\begin{codeblock}
int max(int a, int b, int c)
{
    int m = (a > b) ? a : b;
    return (m > c) ? m : c;
}
\end{codeblock}

Here
\tcode{int}
is the
\grammarterm{decl-specifier-seq};
\tcode{max(int}
\tcode{a,}
\tcode{int}
\tcode{b,}
\tcode{int}
\tcode{c)}
is the
\grammarterm{declarator};
\tcode{\{ /* ... */ \}}
is the
\grammarterm{function-body}.
\exitexample

\pnum
\indextext{initializer!base~class}%
\indextext{initializer!member}%
\indextext{definition!constructor}%
A
\grammarterm{ctor-initializer}
is used only in a constructor; see~\ref{class.ctor} and~\ref{class.init}.

\pnum
A
\grammarterm{cv-qualifier-seq}
can be part of a non-static member function declaration, non-static member function definition,
or pointer to member function only; see~\ref{class.this}.
It is part of the function type.

\pnum
\enternote
unused parameters need not be named.
For example,

\indextext{example!unnamed parameter}%
\begin{codeblock}
void print(int a, int)
{
    printf("a = %d\n",a);
}
\end{codeblock}
\exitnoteb

\rSec1[dcl.init]{Initializers}%
\indextext{initialization|(}

\pnum
A declarator can specify an initial value for the
identifier being declared.
The identifier designates an object or reference being initialized.
The process of initialization described in the
remainder of~\ref{dcl.init}
applies also to initializations
specified by other syntactic contexts, such as the initialization
of function parameters with argument expressions (\ref{expr.call}) or
the initialization of return values (\ref{stmt.return}).

\begin{bnf}
\nontermdef{initializer}\br
    \terminal{=} initializer-clause\br
    \terminal{(} expression-list \terminal{)}
\end{bnf}

\begin{bnf}
\nontermdef{initializer-clause}\br
    assignment-expression\br
    \terminal{\{} initializer-list \terminal{,\opt} \terminal{\}}\br
    \terminal{\{} \terminal{\}}
\end{bnf}

\begin{bnf}
\nontermdef{initializer-list}\br
    initializer-clause\br
    initializer-list \terminal{,} initializer-clause
\end{bnf}

\pnum
\indextext{initialization!automatic object}%
\indextext{initialization!static object@\tcode{static} object}%
Automatic, register, static, and external variables of namespace scope
can be initialized by arbitrary expressions involving literals and
previously declared variables and functions.
\enterexample

\begin{codeblock}
int f(int);
int a = 2;
int b = f(a);
int c(b);
\end{codeblock}
\exitexampleb

\pnum
\enternote
default arguments expressions are more restricted; see~\ref{dcl.fct.default}.

\pnum
The order of initialization of static objects is described in~\ref{basic.start}
and~\ref{stmt.dcl}.
\exitnote

\pnum
\indextext{initialization!static object@\tcode{static} object}%
\indextext{initialization!default}%
\indextext{variable!indeterminate uninitialized}%
\indextext{zero-initialization}%
To
\grammarterm{zero-initialize}
an object of type
\tcode{T}
means:

\begin{itemize}
\item
if
\tcode{T}
is a scalar type (\ref{basic.types}), the
object
is set to the value
\tcode{0}
(zero) converted to
\tcode{T};

\item
if
\tcode{T}
is a non-union class type,
each nonstatic data member and each
base-class subobject is zero-initialized;

\item
if
\tcode{T}
is a union type,
the
object's first named
data member\footnote{This member must not be \tcode{static}, by virtue of
the requirements in~\ref{class.union}.}
is zero-initialized;

\item
if
\tcode{T}
is an array type,
each element is zero-initialized;
\item
if
\tcode{T}
is a reference type, no initialization is performed.
\end{itemize}

\indextext{default-initialization}%
To
\grammarterm{default-initialize}
an object of type
\tcode{T}
means:

\begin{itemize}
\item
if
\tcode{T}
is a non-POD class type (clause~\ref{class}), the default constructor for
\tcode{T}
is called (and the initialization is ill-formed if
\tcode{T}
has no accessible default constructor);

\item
if
\tcode{T}
is an array type, each element is default-initialized;

\item
otherwise, the object is zero-initialized.
\end{itemize}

\indextext{value-initialization}%
To
\grammarterm{value-initialize}
an object of type
\tcode{T}
means:

\begin{itemize}
\item
if
\tcode{T}
is a class type (clause~\ref{class}) with a user-declared
constructor (\ref{class.ctor}), then the default constructor for
\tcode{T}
is called (and the initialization is ill-formed if
\tcode{T}
has no accessible default constructor);

\item
if
\tcode{T}
is a non-union class type without a user-provided constructor,
then every non-static data member and base-class component of \tcode{T}
is value-initialized;

\item
if
\tcode{T}
is an array type, then each element is value-initialized;

\item
otherwise, the object is zero-initialized
\end{itemize}

A program that calls for default-initialization
or value-initialization
of an entity
of reference type is ill-formed.
If \tcode{T} is a cv-qualified type, the cv-unqualified version of
\tcode{T} is used for these definitions of zero-initialization,
default-initialization, and value-initialization.

\pnum
Every
object of static storage duration shall be
zero-initialized at program startup before any other initialization
takes place.
\enternote
in some cases, additional initialization is done later.
\exitnote

\pnum
An object whose initializer is an empty set of parentheses, i.e.,
\tcode{()},
shall be
value-initialized.

\pnum
\indextext{ambiguity!function declaration}%
\enternote
since
\tcode{()}
is not permitted by the syntax for
\grammarterm{initializer},

\begin{codeblock}
X a();
\end{codeblock}

is not the declaration of an object of class
\tcode{X},
but the declaration of a function taking no argument and returning an
\tcode{X}.
The form
\tcode{()}
is permitted in certain other initialization contexts (\ref{expr.new},
\ref{expr.type.conv}, \ref{class.base.init}).
\exitnote

\pnum
If no initializer is specified for an object, and the object is of (possibly
cv-qualified) non-POD class type (or array thereof), the object shall be
default-initialized;
if the object is of const-qualified type, the underlying class type shall
have a user-declared default constructor.
Otherwise,
if no initializer is specified for a non-static object,
the object and its subobjects, if any, have an indeterminate value%
\footnote{This does not apply to aggregate objects with automatic storage
duration initialized with an incomplete brace-enclosed
\grammarterm{initializer-list}; see~\ref{dcl.init.aggr}.};
if the object or any of its subobjects are of const-qualified type, the
program is ill-formed.

\pnum
\indextext{initialization!class~member}%
An initializer for a static member is in the scope of the member's class.
\enterexample

\begin{codeblock}
int a;

struct X {
    static int a;
    static int b;
};

int X::a = 1;
int X::b = a;			// \tcode{X::b = X::a}
\end{codeblock}
\exitexampleb

\pnum
The form of initialization (using parentheses or
\tcode{=})
is generally insignificant, but does matter when the entity
being initialized has a class type; see below.
A parenthesized initializer can be a list of expressions
only when the entity being initialized has a class type.

\pnum
\indextext{initialization!copy}%
\indextext{initialization!direct}%
The initialization that occurs in argument passing, function return,
throwing an exception~(\ref{except.throw}), handling an
exception~(\ref{except.handle}), and brace-enclosed initializer
lists~(\ref{dcl.init.aggr}) is called \defn{copy-initialization}
and is equivalent to the form

\begin{codeblock}
T x = a;
\end{codeblock}

The initialization that occurs in \tcode{new} expressions~(\ref{expr.new}),
\tcode{static_cast} expressions~(\ref{expr.static.cast}), functional
notation type conversions~(\ref{expr.type.conv}), and base and member
initializers~(\ref{class.base.init}) is called \defn{direct-initialization}
and is equivalent to the form

\begin{codeblock}
T x(a);
\end{codeblock}

\pnum
If \tcode{T} is a scalar type, then a declaration of the form

\begin{codeblock}
T x = { a };
\end{codeblock}

is equivalent to

\begin{codeblock}
T x = a;
\end{codeblock}

\pnum
The semantics of initializers are as follows.
The
\indextext{type!destination}%
\term{destination type}
is the type of the object or reference being initialized and the
\term{source type}
is the type of the initializer expression.
The source type is not defined when the initializer is brace-enclosed or
when it is a parenthesized list of expressions.

\begin{itemize}
\item
If the destination type is a reference type, see~\ref{dcl.init.ref}.
\item
If the destination type is an array of characters
or an array of
\tcode{wchar_t},
and the initializer is a string literal, see~\ref{dcl.init.string}.
\item
Otherwise, if the destination type is an array, see~\ref{dcl.init.aggr}.
\item
If the destination type is a (possibly cv-qualified) class type:

\begin{itemize}
\item
If the class is an aggregate~(\ref{dcl.init.aggr}), and the initializer
is a brace-enclosed list, see~\ref{dcl.init.aggr}.
\item
If the initialization is direct-initialization,
or if it is copy-initialization where the cv-unqualified version of the source
type is the same class as, or a derived class of, the class of the destination,
constructors are considered.
The applicable constructors
are enumerated (\ref{over.match.ctor}), and the best one is chosen
through overload resolution (\ref{over.match}).
The constructor so selected
is called to initialize the object, with the initializer
expression(s) as its argument(s).
If no constructor applies, or the overload resolution is
ambiguous, the initialization is ill-formed.
\item
Otherwise (i.e., for the remaining copy-initialization cases),
user-defined conversion sequences that can convert from the
source type to the destination type or (when a conversion function
is used) to a derived class thereof are enumerated as described in~\ref{over.match.copy}, and the best one is chosen through overload
resolution (\ref{over.match}).  If the conversion cannot be done or
is ambiguous, the initialization is ill-formed.  The function
selected is called with the initializer expression as its
argument; if the function is a constructor, the call initializes
a temporary of the
destination type. The result of the call
(which is the temporary for the constructor case) is then used
to direct-initialize, according to the rules above, the object
that is the destination of the copy-initialization.  In certain
cases, an implementation is permitted to eliminate the copying
inherent in this direct-initialization by constructing the
intermediate result directly into the object being initialized;
see~\ref{class.temporary}, \ref{class.copy}.
\end{itemize}

\item
Otherwise, if the source type
is a (possibly cv-qualified) class type, conversion functions are
considered.
The applicable conversion functions are enumerated
(\ref{over.match.conv}), and the best one is chosen through overload
resolution (\ref{over.match}).
The user-defined conversion so selected
is called to convert the initializer expression into the
object being initialized.
If the conversion cannot be done or is
ambiguous, the initialization is ill-formed.
\item
Otherwise, the initial value of the object being initialized is
the (possibly converted) value of the initializer expression.
Standard conversions (clause~\ref{conv}) will be used, if necessary,
to convert the initializer expression to the cv-unqualified version of
the destination type;
no user-defined conversions are considered.
If the conversion cannot
be done, the initialization is ill-formed.
\indextext{initialization!\idxcode{const}}%
\enternote
an expression of type
``\nonterminal{cv1} \tcode{T}''
can initialize an object of type
``\nonterminal{cv2} \tcode{T}''
independently of
the cv-qualifiers
\nonterminal{cv1}
and \nonterminal{cv2}.

\begin{codeblock}
int a;
const int b = a;
int c = b;
\end{codeblock}
\exitnoteb
\end{itemize}

\rSec2[dcl.init.aggr]{Aggregates}%
\indextext{aggregate}%
\indextext{initialization!aggregate}%
\indextext{aggregate~initialization}%
\indextext{initialization!array}%
\indextext{initialization!class~object}%
\indextext{class~object~initialization|see{constructor}}%

\pnum
An
\term{aggregate}
is an array or a class (clause~\ref{class}) with no
user-declared constructors (\ref{class.ctor}),
no private or protected non-static data members (clause~\ref{class.access}),
no base classes (clause~\ref{class.derived}),
and no virtual functions (\ref{class.virtual}).

\pnum
When an aggregate is initialized the \grammarterm{initializer} can contain
an \grammarterm{initializer-clause} consisting of a brace-enclosed,
comma-separated list of \grammarterm{initializer-clause}{s} for the
members of the aggregate, written in increasing subscript or member order.
If the aggregate contains subaggregates, this rule applies recursively
to the members of the subaggregate.
\enterexample
\begin{codeblock}
struct A {
	int x;
	struct B {
		int i;
		int j;
	} b;
} a = { 1, { 2, 3 } };
\end{codeblock}

initializes
\tcode{a.x}
with 1,
\tcode{a.b.i}
with 2,
\tcode{a.b.j}
with 3.
\exitexample

\pnum
An aggregate that is a class can also be initialized with a single
expression not enclosed in braces, as described in~\ref{dcl.init}.

\pnum
An array of unknown size initialized with a
brace-enclosed
\grammarterm{initializer-list}
containing
\tcode{n}
\grammarterm{initializer}{s},
where
\tcode{n}
shall be greater than zero, is defined as having
\tcode{n}
elements (\ref{dcl.array}).
\enterexample

\begin{codeblock}
int x[] = { 1, 3, 5 };
\end{codeblock}

declares and initializes
\tcode{x}
as a one-dimensional array that has three elements
since no size was specified and there are three initializers.
\exitexample
An empty initializer list
\tcode{\{\}}
shall not be used as the initializer
for an array of unknown bound.\footnote{The syntax provides for empty
\grammarterm{initializer-list}{s},
but nonetheless \Cpp does not have zero length arrays.}

\pnum
Static data members are not considered
members of the class for purposes of aggregate initialization.
\enterexample

\begin{codeblock}
struct A {
	int i;
	static int s;
	int j;
} a = { 1, 2 };
\end{codeblock}

Here, the second initializer 2 initializes
\tcode{a.j}
and not the static data member
\tcode{A::s}.
\exitexample

\pnum
An
\grammarterm{initializer-list}
is ill-formed if the number of
\grammarterm{initializer}{s} 
exceeds the number of members or elements to initialize.
\enterexample

\begin{codeblock}
char cv[4] = { 'a', 's', 'd', 'f', 0 };		// error
\end{codeblock}

is ill-formed.
\exitexample

\pnum
If there are fewer
\grammarterm{initializer}{s} 
in the list than there are members in the aggregate,
then each member not explicitly initialized
shall be value-initialized~(\ref{dcl.init}).
\enterexample

\begin{codeblock}
struct S { int a; const char* b; int c; };
S ss = { 1, "asdf" };
\end{codeblock}

initializes
\tcode{ss.a}
with 1,
\tcode{ss.b}
with \tcode{"asdf"},
and
\tcode{ss.c}
with the value of an expression of the form
\tcode{int()},
that is,
\tcode{0}.
\exitexample

\pnum
An \grammarterm{initializer} for an aggregate member that is an empty
class shall have the form of an empty \grammarterm{initializer-list}
\tcode{\{\}}.
\enterexample

\begin{codeblock}
struct S { };
struct A {
	S s;
	int i;
} a = { { } , 3 };
\end{codeblock}
\exitexampleb
An empty initializer-list can be used to initialize any aggregate.
If the aggregate is not an empty class, then each member of the
aggregate shall be initialized with a value of the form
\tcode{T()}~(\ref{expr.type.conv}), where \tcode{T} represents the
type of the uninitialized member.

\pnum
If an incomplete or empty \grammarterm{initializer-list} leaves a member
of reference type uninitialized, the program is ill-formed.

\pnum
When initializing a multi-dimensional array,
the
\grammarterm{initializer}{s}
initialize the elements with the last (rightmost) index of the array
varying the fastest (\ref{dcl.array}).
\enterexample

\begin{codeblock}
int x[2][2] = { 3, 1, 4, 2 };
\end{codeblock}

initializes
\tcode{x[0][0]}
to
\tcode{3},
\tcode{x[0][1]}
to
\tcode{1},
\tcode{x[1][0]}
to
\tcode{4},
and
\tcode{x[1][1]}
to
\tcode{2}.
On the other hand,

\begin{codeblock}
float y[4][3] = {
    { 1 }, { 2 }, { 3 }, { 4 }
};
\end{codeblock}

initializes the first column of
\tcode{y}
(regarded as a two-dimensional array)
and leaves the rest zero.
\exitexample

\pnum
Braces can be elided in an
\grammarterm{initializer-list}
as follows.
If the
\grammarterm{initializer-list}
begins with a left brace,
then the succeeding comma-separated list of
\grammarterm{initializer}{s}
initializes the members of a subaggregate;
it is erroneous for there to be more
\grammarterm{initializer}{s}
than members.
If, however, the
\grammarterm{initializer-list}
for a subaggregate does not begin with a left brace,
then only enough
\grammarterm{initializer}{s}
from the list are taken to initialize the members of the subaggregate;
any remaining
\grammarterm{initializer}{s}
are left to initialize the next member of the aggregate
of which the current subaggregate is a member.
\enterexample

\begin{codeblock}
float y[4][3] = {
    { 1, 3, 5 },
    { 2, 4, 6 },
    { 3, 5, 7 },
};
\end{codeblock}

is a completely-braced initialization:
1, 3, and 5 initialize the first row of the array
\tcode{y[0]},
namely
\tcode{y[0][0]},
\tcode{y[0][1]},
and
\tcode{y[0][2]}.
Likewise the next two lines initialize
\tcode{y[1]}
and
\tcode{y[2]}.
The initializer ends early and therefore
\tcode{y[3]}'s
elements are initialized as if explicitly initialized with an
expression of the form
\tcode{float()},
that is, are initialized with
\tcode{0.0}.
In the following example, braces in the
\grammarterm{initializer-list}
are elided;
however the
\grammarterm{initializer-list}
has the same effect as the completely-braced
\grammarterm{initializer-list}
of the above example,

\begin{codeblock}
float y[4][3] = {
    1, 3, 5, 2, 4, 6, 3, 5, 7
};
\end{codeblock}

The initializer for
\tcode{y}
begins with a left brace, but the one for
\tcode{y[0]}
does not,
therefore three elements from the list are used.
Likewise the next three are taken successively for
\tcode{y[1]}
and
\tcode{y[2]}.
\exitexampleb

\pnum
All implicit type conversions (clause~\ref{conv}) are considered when
initializing the aggregate member with an initializer from an
\grammarterm{initializer-list}.
If the
\grammarterm{initializer}
can initialize a member, the member is initialized.
Otherwise, if the member is itself a non-empty subaggregate,
brace elision is assumed and the
\grammarterm{initializer}
is considered for the initialization of the first member of the subaggregate.\\
\enterexample

\begin{codeblock}
struct A {
    int i;
    operator int();
};
struct B {
    A a1, a2;
    int z;
};
A a;
B b = { 4, a, a };
\end{codeblock}

Braces are elided around the
\grammarterm{initializer}
for
\tcode{b.a1.i}.
\tcode{b.a1.i}
is initialized with 4,
\tcode{b.a2}
is initialized with
\tcode{a},
\tcode{b.z}
is initialized with whatever
\tcode{a.operator int()}
returns.
\exitexample

\pnum
\indextext{initialization!array~of class~objects}%
\enternote
An aggregate array or an aggregate class may contain members of a
class type with a user-declared constructor (\ref{class.ctor}).
Initialization of these aggregate objects is described in~\ref{class.expl.init}.
\exitnote

\pnum
When an aggregate with static storage duration is initialized with a
brace-enclosed \grammarterm{initializer-list}, if all the member
initializer expressions are constant expressions, and the aggregate is a
POD type, the initialization shall be done during the static phase of
initialization~(\ref{basic.start.init}); otherwise, it is unspecified
whether the initialization of members with constant expressions take
place during the static phase or during the dynamic phase of initialization.

\pnum
\indextext{initialization!\idxcode{union}}%
When a union is initialized with a brace-enclosed initializer,
the braces shall only contain an
initializer
for the first member of the union.
\enterexample

\begin{codeblock}
union u { int a; const char* b; };

u a = { 1 };
u b = a;
u c = 1;                        // error
u d = { 0, "asdf" };            // error
u e = { "asdf" };               // error
\end{codeblock}
\exitexampleb
\enternote
as described above,
the braces around the initializer
for a union member can be omitted if the
union is a member of another aggregate.
\exitnote

\rSec2[dcl.init.string]{Character arrays}%
\indextext{initialization!character array}

\pnum
A
\tcode{char}
array (whether plain
\tcode{char},
\tcode{signed}
\tcode{char},
or
\tcode{unsigned}
\tcode{char})
can be initialized by a
\grammarterm{string-literal} (optionally enclosed in braces);
a
\tcode{wchar_t}
array can be initialized by a wide
\grammarterm{string-literal} (optionally enclosed in braces);
\indextext{initialization!character~array}%
successive
characters of the
\grammarterm{string-literal}
initialize the elements of the array.
\enterexample

\begin{codeblock}
char msg[] = "Syntax error on line %s\n";
\end{codeblock}

shows a character array whose members are initialized
with a
\grammarterm{string-literal}.
Note that because
\tcode{'\textbackslash n'}
is a single character and
because a trailing
\tcode{'\textbackslash 0'}
is appended,
\tcode{sizeof(msg)}
is
\tcode{25}.
\exitexample

\pnum
There shall not be more initializers than there are array elements.
\enterexample

\begin{codeblock}
char cv[4] = "asdf";            // error
\end{codeblock}

is ill-formed since there is no space for the implied trailing
\tcode{'\textbackslash 0'}.
\exitexample

\rSec2[dcl.init.ref]{References}%
\indextext{initialization!reference}

\pnum
A variable declared to be a
\tcode{T\&},
that is ``reference to type
\tcode{T}''
(\ref{dcl.ref}),
shall be initialized by an object, or function, of type
\tcode{T}
or by an object that can be converted into a
\tcode{T}.
\enterexample

\begin{codeblock}
int g(int);
void f()
{
    int i;
    int& r = i;                 // \tcode{r} refers to \tcode{i}
    r = 1;                      // the value of \tcode{i} becomes \tcode{1}
    int* p = &r;                // \tcode{p} points to \tcode{i}
    int& rr = r;                // \tcode{rr} refers to what \tcode{r} refers to, that is, to \tcode{i}
    int (&rg)(int) = g;         // \tcode{rg} refers to the function \tcode{g}
    rg(i);                      // calls function \tcode{g}
    int a[3];
    int (&ra)[3] = a;           // \tcode{ra} refers to the array \tcode{a}
    ra[1] = i;                  // modifies \tcode{a[1]}
}
\end{codeblock}
\exitexampleb

\pnum
A reference cannot be changed to refer to another object after initialization.
\indextext{assignment!reference}%
Note that initialization of a reference is treated very differently from assignment
to it.
\indextext{argument~passing!reference~and}%
Argument passing (\ref{expr.call})
\indextext{\idxcode{return}!reference~and}%
and function value return (\ref{stmt.return}) are initializations.

\pnum
The initializer can be omitted for a reference only in a parameter declaration
(\ref{dcl.fct}), in the declaration of a function return type, in the declaration of
a class member within its class definition (\ref{class.mem}), and where the
\tcode{extern}
specifier is explicitly used.
\indextext{declaration!extern@\tcode{extern} reference}%
\enterexample

\begin{codeblock}
int& r1;                        // error: initializer missing
extern int& r2;                 // OK
\end{codeblock}
\exitexampleb

\pnum
Given types ``\nonterminal{cv1} \tcode{T1}'' and ``\nonterminal{cv2} \tcode{T2},''
``\nonterminal{cv1} \tcode{T1}'' is \nonterminal{reference-related} to
\indextext{reference-related}%
``\nonterminal{cv2} \tcode{T2}'' if
\tcode{T1}
is the same type as
\tcode{T2},
or
\tcode{T1}
is a base class of
\tcode{T2}.
``\nonterminal{cv1} \tcode{T1}'' is \nonterminal{reference-compatible}
\indextext{reference-compatible}%
with ``\nonterminal{cv2} \tcode{T2}'' if
\tcode{T1}
is reference-related to
\tcode{T2}
and
\textit{cv1}
is the same cv-qualification as, or greater cv-qualification than,
\textit{cv2}.
For purposes of overload resolution, cases for which
\textit{cv1}
is greater cv-qualification than
\textit{cv2}
are identified as
\grammarterm{reference-compatible with added qualification}
(see~\ref{over.ics.rank}).
In all cases where the reference-related or reference-compatible relationship
of two types is used to establish the validity of a reference binding, and
\tcode{T1}
is a base class of
\tcode{T2},
a program that necessitates such a binding is ill-formed if
\tcode{T1}
is an inaccessible (clause~\ref{class.access}) or ambiguous (\ref{class.member.lookup})
base class of
\tcode{T2}.

\pnum
A reference to type ``\cvqual{cv1} \tcode{T1}'' is initialized by
an expression of type ``\cvqual{cv2} \tcode{T2}'' as follows:%
\indextext{binding!reference}

\begin{itemize}
\item
If the initializer expression

\begin{itemize}
\item
is an lvalue (but is not a
bit-field), and
``\nonterminal{cv1} \tcode{T1}'' is reference-compatible with
``\nonterminal{cv2} \tcode{T2},'' or
\item
has a class type (i.e.,
\tcode{T2}
is a class type) and can be implicitly converted
to an lvalue of type ``\nonterminal{cv3} \tcode{T3},'' where
``\nonterminal{cv1} \tcode{T1}'' is reference-compatible with
``\nonterminal{cv3} \tcode{T3}''\footnote{This requires a conversion
function~(\ref{class.conv.fct}) returning a reference type.}
(this conversion is selected by enumerating the applicable conversion
functions (\ref{over.match.ref}) and choosing the best one through overload
resolution (\ref{over.match})),
\end{itemize}
then the reference is bound directly to the initializer expression lvalue in the
first case, and the reference is bound to the lvalue result of the conversion
in the second case. In these cases the reference is said to
\term{bind directly} to the initializer expression
\enternote
the usual lvalue-to-rvalue (\ref{conv.lval}), array-to-pointer
(\ref{conv.array}), and function-to-pointer (\ref{conv.func}) standard
conversions are not needed, and therefore are suppressed, when such
direct bindings to lvalues are done.
\exitnote\\
\enterexample

\begin{codeblock}
double d = 2.0;
double& rd = d;                 // \tcode{rd} refers to \tcode{d}
const double& rcd = d;          // \tcode{rcd} refers to \tcode{d}

struct A { };
struct B : public A { } b;
A& ra = b;                      // \tcode{ra} refers to \tcode{A} subobject in \tcode{b}
const A& rca = b;               // \tcode{rca} refers to \tcode{A} subobject in \tcode{b}
\end{codeblock}
\exitexampleb

\item
Otherwise, the reference shall be to a non-volatile
const type (i.e.,
\textit{cv1}
shall be
\tcode{const}).
\enterexample

\begin{codeblock}
double& rd2 = 2.0;              // error: not an lvalue and reference not \tcode{const}
int  i = 2;
double& rd3 = i;                // error: type mismatch and reference not \tcode{const}
\end{codeblock}
\exitexampleb

\begin{itemize}
\item If the initializer expression
is an rvalue, with \tcode{T2} a class type, and
``\cvqual{cv1} \tcode{T1}'' is
reference-compatible with ``\cvqual{cv2} \tcode{T2}''
the reference is bound in one of the following ways (the choice is
implementation-defined):

\begin{itemize}
\item
The reference is bound to the object represented by the rvalue
(see~\ref{basic.lval}) or to a sub-object within that object.
\item
A temporary of type ``\cvqual{cv1} \tcode{T2}'' [sic] is created,
and a constructor is called to copy the entire rvalue object into
the temporary. The reference is bound to the temporary or to a
sub-object within the temporary.\footnote{Clearly, if the reference
initialization being processed is one for the first argument of a
copy constructor call, an implementation must eventually choose the
first alternative (binding without copying) to avoid infinite recursiion.}
\end{itemize}

The constructor that would be used to make the copy shall be callable
whether or not the copy is actually done
\enterexample

\begin{codeblock}
struct A { };
struct B : public A { } b;
extern B f();
const A& rca2 = f();            // Either bound to the \tcode{A} sub-object of the \tcode{B} rvalue,
				// or the entire \tcode{B} object is copied and the reference
				// is bound to the \tcode{A} sub-object of the copy
\end{codeblock}
\exitexampleb

\item
Otherwise, a temporary of type ``\cvqual{cv1} \tcode{T1}'' is created and
initialized from the initializer expression using the rules
for a non-reference copy-initialization (\ref{dcl.init}).
The reference is then bound to the temporary.
If
\tcode{T1}
is reference-related to
\tcode{T2},
\textit{cv1}
must be the same cv-qualification as, or greater cv-qualification than,
\textit{cv2};
otherwise, the program is ill-formed.
\enterexample
\begin{codeblock}
const double& rcd2 = 2;		// \tcode{rcd2} refers to temporary with value \tcode{2.0}
const volatile int cvi = 1;
const int& r = cvi;		// error: type qualifiers dropped
\end{codeblock}
\exitexampleb
\end{itemize}

\pnum
\enternote
\ref{class.temporary} describes the lifetime of temporaries bound to references.
\exitnote
\end{itemize}
\indextext{initialization|)}%
\indextext{declarator|)}
