\rSec0[special]{Special member functions}

%gram: \rSec1[gram.special]{Special member functions}
%gram:

\indextext{special~member~function|see{constructor, destructor, inline function,
user-defined conversion, virtual function}}%
\indextext{\idxcode{X(X\&)}|see{copy~constructor}}%
\indextext{\~@\tcode{\tilde}|see{destructor}}%
\indextext{assignment!copy|see{assignment operator, copy}}%
\indextext{implicitly-declared~default~constructor|see{constructor, default}}

\pnum
\indextext{constructor!default}%
\indextext{constructor!copy}%
\indextext{assignment operator!copy}%
The default constructor~(\ref{class.ctor}),
copy constructor and copy assignment operator~(\ref{class.copy}),
and destructor~(\ref{class.dtor}) are
\term{special member functions}.
The implementation will implicitly declare these member functions for a class
type when the program does not explicitly declare them, except as noted
in~\ref{class.ctor}.
The implementation will implicitly define them if they are used, as specified
in~\ref{class.ctor}, \ref{class.dtor} and~\ref{class.copy}.
Programs shall not define implicitly-declared special member functions.
Programs may explicitly refer to implicitly declared special member functions.
\enterexample
a program may explicitly call, take the address of or form a pointer to member
to an implicitly declared special member function.

\begin{codeblock}
struct A { };                   // implicitly declared \tcode{A::operator=}
struct B : A {
	B& operator=(const B &);
};
B& B::operator=(const B& s) {
	this->A::operator=(s);  // well formed
	return *this;
}
\end{codeblock}
\exitexampleb
\enternote
the special member functions affect the way objects of class type are created,
copied, and destroyed, and how values can be converted to values of other types.
Often such special member functions are called implicitly.
\exitnote

\pnum
\indextext{access~control!member~function~and}%
Special member functions obey the usual access rules (clause~\ref{class.access}).
\enterexample
declaring a constructor
\tcode{protected}
ensures that only derived classes and friends can create objects using it.
\exitexample

\rSec1[class.ctor]{Constructors}%
\indextext{constructor}

\pnum
Constructors do not have names.
A special declarator syntax using an optional sequence of
\grammarterm{function-specifier}{s}~(\ref{dcl.fct.spec}) followed by the
constructor's class name followed by a parameter list
is used to declare or define the constructor.
In such a declaration, optional parentheses around the constructor class name
are ignored.
\enterexample

\begin{codeblock}
class C {
public:
	C();			// declares the constructor
};

C::C() { }			// defines the constructor
\end{codeblock}
\exitexampleb

\pnum
A constructor is used to initialize objects of its class type.
Because constructors do not have names, they are never found during
name lookup; however an explicit type conversion using the functional
notation~(\ref{expr.type.conv}) will cause a constructor to be called to
initialize an object.
\enternote
for initialization of objects of class type see~\ref{class.init}.
\exitnote

\pnum
A
\grammarterm{typedef-name}
that names a class is a
\grammarterm{class-name}~(\ref{dcl.typedef}); however, a
\grammarterm{typedef-name} that names a class shall not be used as the
\grammarterm{identifier}
in the declarator for a constructor declaration.

\pnum
A constructor shall not be
\tcode{virtual}~(\ref{class.virtual}) or
\tcode{static}~(\ref{class.static}).
\indextext{\idxcode{const}!constructor~and}%
\indextext{\idxcode{volatile}!constructor~and}%
A constructor can be invoked for a
\tcode{const},
\tcode{volatile}
or
\tcode{const}
\tcode{volatile}
object.
\indextext{restriction!constructor}%
A constructor shall not be declared
\tcode{const},
\tcode{volatile},
or
\tcode{const}
\tcode{volatile}~(\ref{class.this}).
\tcode{const}
and
\tcode{volatile}
semantics~(\ref{dcl.type.cv}) are not applied on an object under construction.
Such semantics only come into effect once the constructor for the
most derived object~(\ref{intro.object}) ends.

\pnum
\indextext{constructor!inheritance~of}%
\indextext{constructor!default}%
\indextext{constructor!non-trivial}%
A
\term{default}
constructor for a class
\tcode{X}
is a constructor of class
\tcode{X}
that can be called without an argument.
\indextext{implicitly-declared~default~constructor}%
If there is no \term{user-declared} constructor for class
\tcode{X},
a default constructor is implicitly declared.
An \term{implicitly-declared} default constructor is an
\tcode{inline}
\tcode{public}
member of its class.
A constructor is \term{trivial} if it is an implicitly-declare default
constructor and if:

\begin{itemize}
\item
its class has no virtual functions~(\ref{class.virtual}) and no virtual base
classes~(\ref{class.mi}), and

\item
all the direct base classes of its class have trivial constructors, and

\item
for all the nonstatic data members of its class that are of class
type (or array thereof), each such class has a trivial constructor.
\end{itemize}

\pnum
Otherwise, the constructor is
\grammarterm{non-trivial}.

\pnum
\indextext{constructor!implicitly defined}%
An implicitly-declared default constructor for a class is
\term{implicitly defined}
when it is used
to create an object of its class type~(\ref{intro.object}).
The implicitly-defined default constructor performs the set of
initializations of the class that would be performed by a user-written default
constructor for that class with an empty
\grammarterm{mem-initializer-list}~(\ref{class.base.init}) and an empty
function body.
If that user-written default constructor would be ill-formed,
the program is ill-formed.
Before the implicitly-declared default constructor for a class is
implicitly defined,
all the implicitly-declared default constructors for its base classes and
its nonstatic data members shall have been implicitly defined.
\enternote
an implicitly-declared default constructor has an
exception-specification~(\ref{except.spec}).
\exitnote

\pnum
\indextext{constructor!implicitly called}%
Default constructors are called implicitly to create class objects of static
or automatic storage duration~(\ref{basic.stc.static}, \ref{basic.stc.auto}) defined
without an initializer~(\ref{dcl.init}),
are called to create class objects of dynamic storage duration~(\ref{basic.stc.dynamic}) created by a
\grammarterm{new-expression}
in which the
\grammarterm{new-initializer}
is omitted~(\ref{expr.new}), or
are called when the explicit type conversion syntax~(\ref{expr.type.conv}) is
used.
A program is ill-formed if the default constructor for an object
is implicitly used and the constructor is not accessible (clause~\ref{class.access}).

\pnum
\enternote
\indextext{order~of~execution!base~class constructor}%
\indextext{order~of~execution!member constructor}%
\ref{class.base.init} describes the order in which constructors for base
classes and non-static data members are called and
describes how arguments can be specified for the calls to these constructors.
\exitnote

\pnum
\indextext{constructor!copy}%
A \term{copy constructor} for a class \tcode{X} is a
constructor with a first parameter of type \tcode{X\&} or of type
\tcode{const} \tcode{X\&}.
\enternote
see~\ref{class.copy} for more information on copy constructors.
\exitnote

\pnum
A union member shall not be of a class type (or array thereof) that has
a non-trivial constructor.

\pnum
\indextext{restriction!constructor}%
\indextext{constructor!type~of}%
No return type (not even
\tcode{void})
shall be specified for a constructor.
A
\tcode{return}
statement in the body of a constructor shall not specify a return value.
\indextext{constructor!address~of}%
The address of a constructor shall not be taken.

\pnum
\indextext{object!unnamed}%
\indextext{constructor!explicit call}%
A functional notation type conversion~(\ref{expr.type.conv}) can be used
to create new objects of its type.
\enternote
The syntax looks like an explicit call of the constructor.
\exitnote
\enterexample
\indextext{example!constructor}%

\begin{codeblock}
complex zz = complex(1,2.3);
cprint( complex(7.8,1.2) );
\end{codeblock}
\exitexampleb
An object created in this way is unnamed.
\enternote
\ref{class.temporary} describes the lifetime of temporary objects.
\exitnote
\enternote
explicit constructor calls do not yield lvalues, see~\ref{basic.lval}.
\exitnote

\pnum
\enternote
\indextext{member function!constructor~and}%
some language constructs have special semantics when used during construction;
see~\ref{class.base.init} and~\ref{class.cdtor}.
\exitnote

\pnum
During the construction of a
\tcode{const}
object, if the value of the object or any of its subobjects is
accessed through an lvalue that is not obtained, directly or indirectly, from
the constructor's
\tcode{this}
pointer, the value of the object or subobject thus obtained is unspecified.
\enterexample

\begin{codeblock}
struct C;
void no_opt(C*);

struct C {
	int c;
	C() : c(0) { no_opt(this); }
};

const C cobj;

void no_opt(C* cptr) {
	int i = cobj.c * 100;   // value of \tcode{cobj.c} is unspecified
	cptr->c = 1;
	cout << cobj.c * 100    // value of \tcode{cobj.c} is unspecified
	     << '\n';
}
\end{codeblock}
\exitexampleb

\rSec1[class.temporary]{Temporary objects}

\pnum
\indextext{object~temporary|see{temporary}}%
\indextext{temporary}%
\indextext{optimization~of~temporary|see{elimination~of~temporary}}%
\indextext{temporary!elimination~of}%
\indextext{temporary!implementation-defined~generation~of}%
Temporaries of class type are created in various contexts:
binding an rvalue to a reference~(\ref{dcl.init.ref}),
returning an rvalue~(\ref{stmt.return}),
a conversion that creates an rvalue~(\ref{conv.lval}, \ref{expr.static.cast},
\ref{expr.const.cast}, \ref{expr.cast}),
throwing an exception~(\ref{except.throw}),
entering a
\term{handler}~(\ref{except.handle}), and in some initializations~(\ref{dcl.init}).
\enternote
the lifetime of exception objects is described in~\ref{except.throw}.
\exitnote
Even when the creation of the temporary object is
avoided~(\ref{class.copy}),
all the semantic restrictions must be respected as if the temporary object
was created.
\enterexample
even if the copy constructor is not called,
all the semantic restrictions,
such as accessibility (clause~\ref{class.access}),
shall be satisfied.
\exitexample

\pnum
\enterexample
\begin{codeblock}
class X {
    // ...
public:
    // ...
    X(int);
    X(const X&);
    ~X();
};

X f(X);

void g()
{
    X a(1);
    X b = f(X(2));
    a = f(a);
}
\end{codeblock}

\indextext{class~object~copy|see{copy~constructor}}%
\indextext{constructor!copy}%
Here, an implementation might use a temporary in which to construct
\tcode{X(2)}
before passing it to
\tcode{f()}
using
\tcode{X}'s
copy-constructor; alternatively,
\tcode{X(2)}
might be constructed in the space used to hold the argument.
Also, a temporary might be used to hold the result of
\tcode{f(X(2))}
before copying it to
\tcode{b}
using
\tcode{X}'s
copy-constructor; alternatively,
\tcode{f()}'s
result might be constructed in
\tcode{b}.
On the other hand, the expression
\tcode{a=f(a)}
requires a temporary for either the argument \tcode{a} or
the result of \tcode{f(a)} to avoid undesired aliasing of \tcode{a}.
\exitexample

\pnum
\indextext{temporary!constructor~for}%
\indextext{temporary!destructor~for}%
\indextext{temporary!destruction~of}%
When an implementation introduces a temporary object of a class that has a
non-trivial constructor~(\ref{class.ctor}), it shall ensure that
a constructor is called for the temporary object.
Similarly, the destructor shall be called for a temporary with a non-trivial
destructor~(\ref{class.dtor}).
Temporary objects are destroyed as the last step
in evaluating
the full-expression~(\ref{intro.execution})
that (lexically) contains the point where
they were created.
This is true even if that evaluation ends in throwing an exception.

\pnum
\indextext{initializer!temporary~and declarator}%
\indextext{temporary!order~of destruction~of}%
There are two contexts in which temporaries are destroyed at a different
point than the end of the full-expression.
The first context is when an expression appears as an initializer for a
declarator defining an object. In that context, the temporary that holds
the result of the expression shall persist until the object's initialization
is complete. The object is initialized from a copy of the temporary; during
this copying, an implementation can call the copy constructor many times;
the temporary is destroyed after it has been copied, before or when the
initialization completes. If many temporaries are created by the evaluation
of the initializer, the temporaries are destroyed in reverse order of the
completion of their construction.

\pnum
The second context is when a reference is bound to a temporary.
The temporary to which the reference is bound or the temporary
that is the complete object to a subobject of which the temporary is bound
persists for the lifetime of the reference except as specified below.
A temporary bound to a reference member in a constructor's
ctor-initializer~(\ref{class.base.init}) persists until the constructor exits.
A temporary bound to a reference parameter in a function call~(\ref{expr.call})
persists until the completion of the full expression containing the call.
A temporary bound to the returned value in a function return
statement~(\ref{stmt.return}) persist until the function exits.
In all these cases, the temporaries created during the evaluation of the
expression initializing the reference, except the temporary to which the
reference is bound, are destroyed at the end of the full-expression in which
they are created and in the reverse order of the completion of their
construction.
If the lifetime of two or more temporaries to which references are bound ends
at the same point,
these temporaries are destroyed at that point in the reverse order of the
completion of their construction.
In addition, the destruction of temporaries bound to references shall
take into account the ordering of destruction of objects with static or
automatic storage duration~(\ref{basic.stc.static}, \ref{basic.stc.auto});
that is, if \tcode{obj1} is an object with static or automatic storage
duration created before the temporary is created,
the temporary shall be destroyed before
\tcode{obj1}
is destroyed;
if
\tcode{obj2}
is an object with static or automatic storage duration created after the
temporary is created, the temporary shall be destroyed after
\tcode{obj2}
is destroyed.
\enterexample

\begin{codeblock}
struct C {
	// ...
public:
	C();
	C(int);
	friend C operator+(const C&, const C&);
	~C();
};
C obj1;
const C& cr = C(16)+C(23);
C obj2;
\end{codeblock}

the expression
\tcode{C(16) + C(23)}
creates three temporaries. A first temporary
\tcode{T1}
to hold the result of the expression
\tcode{C(16)},
a second temporary
\tcode{T2}
to hold the result of the expression
\tcode{C(23)},
and a third temporary
\tcode{T3}
to hold the result of the addition of these two expressions.
The temporary
\tcode{T3}
is then bound to the reference
\tcode{cr}.
It is unspecified whether
\tcode{T1}
or
\tcode{T2}
is created first.
On an implementation where
\tcode{T1}
is created before
\tcode{T2},
it is guaranteed that
\tcode{T2}
is destroyed before
\tcode{T1}.
The temporaries
\tcode{T1}
and
\tcode{T2}
are bound to the reference parameters of
\tcode{operator+};
these temporaries are destroyed at the end of the full expression
containing the call to
\tcode{operator+}.
The temporary
\tcode{T3}
bound to the reference
\tcode{cr}
is destroyed at the end of
\tcode{cr}'s
lifetime, that is, at the end of the program.
In addition, the order in which
\tcode{T3}
is destroyed takes into account the destruction order of other objects with
static storage duration.
That is, because
\tcode{obj1}
is constructed before
\tcode{T3},
and
\tcode{T3}
is constructed before
\tcode{obj2},
it is guaranteed that
\tcode{obj2}
is destroyed before
\tcode{T3},
and that
\tcode{T3}
is destroyed before
\tcode{obj1}.
\exitexample

\rSec1[class.conv]{Conversions}

\pnum
\indextext{conversion!class}%
\indextext{conversion!user-defined}%
\indextext{constructor, conversion by|see{conversion, user-defined}}%
\indextext{conversion~function|see{conversion, user-defined}}%
\indextext{conversion!implicit}%
Type conversions of class objects can be specified by constructors and
by conversion functions.
These conversions are called
\term{user-defined conversions}
and are used for implicit type conversions (clause~\ref{conv}),
for initialization~(\ref{dcl.init}),
and for explicit type conversions~(\ref{expr.cast}, \ref{expr.static.cast}).

\pnum
User-defined conversions are applied only where they are unambiguous~(\ref{class.member.lookup}, \ref{class.conv.fct}).
Conversions obey the access control rules (clause~\ref{class.access}).
Access control is applied after ambiguity resolution~(\ref{basic.lookup}).

\pnum
\enternote
See~\ref{over.match} for a discussion of the use of conversions in function calls
as well as examples below.
\exitnote

\pnum
\indextext{conversion!implicit user-defined}%
At most one user-defined conversion (constructor or conversion function)
is implicitly applied to a single value.
\enterexample

\begin{codeblock}
class X {
    // ...
public:
    operator int();
};

class Y {
    // ...
public:
    operator X();
};

Y a;
int b = a;			// error
				// \tcode{a.operator X().operator int()} not tried
int c = X(a);			// OK: \tcode{a.operator X().operator int()}
\end{codeblock}
\exitexampleb

\pnum
User-defined conversions are used implicitly only if they are unambiguous.
\indextext{name~hiding!user-defined conversion~and}%
A conversion function in a derived class does not hide a conversion function
in a base class unless the two functions convert to the same type.
Function overload resolution~(\ref{over.match.best}) selects the best
conversion function to perform the conversion.
\enterexample

\begin{codeblock}
class X {
public:
    // ...
    operator int();
};

class Y : public X {
public:
    // ...
    operator char();
};

void f(Y& a)
{
    if (a) {			// ill-formed:
				// \tcode{X::operator int()} or \tcode{Y::operator char()}
				// ...
    }
}
\end{codeblock}
\exitexampleb

\rSec2[class.conv.ctor]{Conversion by constructor}%
\indextext{conversion!user-defined}

\pnum
A constructor declared without the
\grammarterm{function-specifier}
\tcode{explicit}
that can be called with a single parameter
specifies a conversion from
the type of its first parameter
to the type of its class.
Such a constructor is called a
\indexdefn{constructor!converting}%
converting constructor.
\enterexample

\indextext{Jessie}%
\begin{codeblock}
class X {
    // ...
public:
    X(int);
    X(const char*, int =0);
};

void f(X arg)
{
    X a = 1;			// \tcode{a = X(1)}
    X b = "Jessie";		// \tcode{b = X("Jessie",0)}
    a = 2;			// \tcode{a = X(2)}
    f(3);			// \tcode{f(X(3))}
}
\end{codeblock}
\exitexampleb

\pnum
An explicit constructor constructs objects just like non-explicit
constructors, but does so only where the direct-initialization syntax~(\ref{dcl.init}) or where casts~(\ref{expr.static.cast}, \ref{expr.cast}) are explicitly
used.
A default constructor may be an explicit constructor; such a constructor
will be used to perform default-initialization
or value-initialization~(\ref{dcl.init}).
\enterexample

\begin{codeblock}
class Z {
public:
	explicit Z();
	explicit Z(int);
	// ...
};

Z a;                            // OK: default-initialization performed
Z a1 = 1;                       // error: no implicit conversion
Z a3 = Z(1);                    // OK: direct initialization syntax used
Z a2(1);                        // OK: direct initialization syntax used
Z* p = new Z(1);                // OK: direct initialization syntax used
Z a4 = (Z)1;                    // OK: explicit cast used
Z a5 = static_cast<Z>(1);       // OK: explicit cast used
\end{codeblock}
\exitexampleb

\pnum
A
non-explicit
copy-constructor~(\ref{class.copy}) is a converting constructor.
An implicitly-declared copy constructor is not an explicit constructor;
it may be called for implicit type conversions.

\rSec2[class.conv.fct]{Conversion functions}%
\indextext{function!conversion}%
\indextext{fundamental~type~conversion|see{conversion, user-defined}}%
\indextext{conversion!user-defined}%
\indextext{conversion operator|see{conversion, user defined}}

\pnum
A member function of a class \tcode{X} with a name of the form

\begin{bnf}
\nontermdef{conversion-function-id}\br
    \terminal{operator} conversion-type-id
\end{bnf}

\begin{bnf}
\nontermdef{conversion-type-id}\br
    type-specifier-seq conversion-declarator\opt
\end{bnf}

\begin{bnf}
\nontermdef{conversion-declarator}\br
    ptr-operator conversion-declarator\opt
\end{bnf}

specifies a conversion from
\tcode{X}
to the type specified by the
\grammarterm{conversion-type-id}.
Such member functions are called conversion functions.
Classes, enumerations, and \grammarterm{typedef-name}{s} shall not be
declared in the \grammarterm{type-specifier-seq}.
Neither parameter types nor return type can be specified.
\indextext{conversion!type~of}%
The type of a conversion function~(\ref{dcl.fct}) is
``function taking no parameter returning
\grammarterm{conversion-type-id}.''
A conversion function is never used to convert a (possibly cv-qualified) object
to the (possibly cv-qualified) same object type (or a reference to it),
to a (possibly cv-qualified) base class of that type (or a reference to it),
or to (possibly cv-qualified) void.\footnote{Even though never directly called
to perform a conversion, such conversion functions can be declared and can
potentially be reached through a call to a virtual conversion function in a
base class}

\pnum
\enterexample

\begin{codeblock}
class X {
    // ...
public:
    operator int();
};

void f(X a)
{
    int i = int(a);
    i = (int)a;
    i = a;
}
\end{codeblock}

In all three cases the value assigned will be converted by
\tcode{X::operator int()}.
\exitexampleb

\pnum
User-defined conversions are not restricted to use in assignments and initializations.
\enterexample

\begin{codeblock}
void g(X a, X b)
{
    int i = (a) ? 1+a : 0;
    int j = (a&&b) ? a+b : i;
    if (a) {			// ...
    }
}
\end{codeblock}
\exitexampleb

\pnum
The
\grammarterm{conversion-type-id}
shall not represent a function type nor an array type.
The
\grammarterm{conversion-type-id}
in a
\grammarterm{conversion-function-id}
is the longest possible sequence of
\grammarterm{conversion-declarator}{s}.
\enternote
this prevents ambiguities between the declarator operator * and its expression
counterparts.
\enterexample

\begin{codeblock}
&ac.operator int*i;		// syntax error:
				// parsed as: \tcode{\&(ac.operator int *)i}
				// not as: \tcode{\&(ac.operator int)*i}
\end{codeblock}

The \tcode{*} is the pointer declarator and not the multiplication operator.
\exitexample
\exitnote

\pnum
\indextext{conversion!inheritance~of user-defined}%
Conversion functions are inherited.

\pnum
\indextext{conversion!virtual user-defined}%
Conversion functions can be virtual.

\rSec1[class.dtor]{Destructors}%
\indextext{destructor}

\pnum
A special declarator syntax using an optional
\grammarterm{function-specifier}~(\ref{dcl.fct.spec}) followed by
\tcode{\~{}}
followed by the destructor's class name
followed by an empty parameter list
is used to declare the destructor in a class definition.
In such a declaration, the
\tcode{\~{}}
followed by the destructor's class name can be enclosed in optional parentheses;
such parentheses are ignored.
A
\grammarterm{typedef-name}
that names a class is a
\grammarterm{class-name}~(\ref{dcl.typedef});
however, a
\grammarterm{typedef-name}
that names a class shall not be used as the
\grammarterm{identifier}
in the declarator for a destructor declaration.

\pnum
A destructor is used to destroy objects of its class type.
\indextext{restriction!destructor}%
A destructor takes no parameters, and no return type can be
specified for it (not even
\tcode{void}).
The address of a destructor shall not be taken.
A destructor shall not be
\tcode{static}.
\indextext{\idxcode{const}!destructor~and}%
\indextext{\idxcode{volatile}!destructor~and}%
A destructor can be invoked for a
\tcode{const},
\tcode{volatile}
or
\tcode{const}
\tcode{volatile}
object.
A destructor shall not be declared
\tcode{const},
\tcode{volatile}
or
\tcode{const}
\tcode{volatile}~(\ref{class.this}).
\tcode{const}
and
\tcode{volatile}
semantics~(\ref{dcl.type.cv}) are not applied on an object under destruction.
Such semantics stop being into effect once the destructor for the
most derived object~(\ref{intro.object}) starts.

\pnum
\indextext{generated~destructor|see{destructor, default}}%
\indextext{destructor!default}%
\indextext{destructor!non-trivial}%
If a class has no \term{user-declared}
destructor, a destructor is declared implicitly.
An \term{implicitly-declared} destructor is an
\tcode{inline}
\tcode{public}
member of its class.
A destructor is \term{trivial} if it is an implicitly-declared destructor
and if:

\begin{itemize}
\item all of the direct base classes of its class have trivial destructors and

\item for all of the non-static data members of its class that are of class
type (or array thereof), each such class has a trivial destructor.
\end{itemize}

\pnum
Otherwise, the destructor is
\grammarterm{non-trivial}.

\pnum
\indextext{destructor!implicitly defined}%
An implicitly-declared destructor is \term{implicitly defined} when it is
used to destroy an object of its class type~(\ref{basic.stc}). A program is
ill-formed if the class for which a destructor is implicitly defined has:

\begin{itemize}
\item a non-static data member of class type (or array thereof) with an
inaccessible destructor, or
\item a base class with an inaccessible destructor.
\end{itemize}

Before the implicitly-declared
destructor for a class is implicitly defined, all the implicitly-declared
destructors for its base classes and its nonstatic data members shall have been
implicitly defined.
\enternote
an implicitly-declared destructor has an
exception-specification~(\ref{except.spec}).
\exitnote

\pnum
\indextext{order~of~execution!destructor}%
\indextext{order~of~execution!base~class destructor}%
\indextext{order~of~execution!member destructor}%
After executing the body of the destructor and destroying
any automatic objects allocated within the body, a
destructor for class
\tcode{X}
calls the destructors for
\tcode{X}'s
direct members, the destructors for
\tcode{X}'s
direct base classes and, if
\tcode{X}
is the type of the most derived class~(\ref{class.base.init}),
its destructor calls the destructors for
\tcode{X}'s
virtual base classes.
All destructors are called as if they were referenced with a qualified name,
that is, ignoring any possible virtual overriding destructors in more
derived classes.
Bases and members are destroyed in the reverse order of the completion of
their constructor (see~\ref{class.base.init}).
A
\tcode{return}
statement~(\ref{stmt.return}) in a destructor might not directly return to the
caller; before transferring control to the caller, the destructors for the
members and bases are called.
\indextext{order~of~execution!destructor~and array}%
Destructors for elements of an array are called in reverse order of their
construction (see~\ref{class.init}).

\pnum
\indextext{destructor!virtual}%
\indextext{destructor!pure virtual}%
A destructor can be declared
\tcode{virtual}~(\ref{class.virtual})
or pure
\tcode{virtual}~(\ref{class.abstract});
if any objects of that class or any derived class are created in the program,
the destructor shall be defined.
If a class has a base class with a virtual destructor, its  destructor
(whether user- or implicitly-declared) is virtual.

\pnum
\enternote
\indextext{member function!destructor~and}%
some language constructs have special semantics when used during destruction;
see~\ref{class.cdtor}.
\exitnote

\pnum
A union member shall not be of a class type (or array thereof) that has a
non-trivial destructor.

\pnum
\indextext{destructor!implicit call}%
\indextext{destructor!program termination~and}%
Destructors are invoked implicitly
(1) for a constructed object with static storage duration~(\ref{basic.stc.static}) at program termination~(\ref{basic.start.term}),
(2) for a constructed object with automatic storage duration~(\ref{basic.stc.auto}) when the block in which an object is created exits~(\ref{stmt.dcl}),
(3) for a constructed temporary object when the lifetime
of the temporary object ends~(\ref{class.temporary}),
\indextext{\idxcode{delete}!destructor~and}%
(4) for a constructed objects allocated by a
\grammarterm{new-expression}~(\ref{expr.new}), through use of a
\grammarterm{delete-expression}~(\ref{expr.delete}),
(5) in several situations due to the handling of exceptions~(\ref{except.handle}).
A program is ill-formed if an object of class type or array thereof is
declared and the destructor for the class is not accessible at the point
of the declaration.
\indextext{destructor!explicit call}%
Destructors can also be invoked explicitly.

\pnum
At the point of definition of a virtual destructor (including an implicit
definition~(\ref{class.copy})), non-placement operator delete shall be
looked up in the scope of the destructor's class~(\ref{basic.lookup.unqual}),
and if found shall be accessible and unambiguous.
\enternote
this assures that an operator delete corresponding to the dynamic type of an
object is available for the
\grammarterm{delete-expression}~(\ref{class.free}).
\exitnote

\pnum
\indextext{destructor!explicit call}%
In an explicit destructor call, the destructor name appears as a
\tcode{\~{}}
followed by a
\grammarterm{type-name}
that names the destructor's class type.
The invocation of a destructor is subject to the usual rules for member
functions~(\ref{class.mfct}),
that is, if the object is not of the destructor's class type and
not of a class derived from the destructor's class type, the program has
undefined behavior
(except that invoking
\tcode{delete}
on a null pointer has no effect).
\enterexample

\begin{codeblock}
struct B {
	virtual ~B() { }
};
struct D : B {
	~D() { }
};

D D_object;
typedef B B_alias;
B* B_ptr = &D_object;

void f() {
	D_object.B::~B();		// calls \tcode{B}'s destructor
	B_ptr->~B();			// calls \tcode{D}'s destructor
	B_ptr->~B_alias();		// calls \tcode{D}'s destructor
	B_ptr->B_alias::~B();		// calls \tcode{B}'s destructor
	B_ptr->B_alias::~B_alias();	// error, no \tcode{B_alias} in class \tcode{B}
}
\end{codeblock}
\exitexampleb
\enternote
an explicit destructor call must always be written using
a member access operator~(\ref{expr.ref});
in particular, the
\grammarterm{unary-expression}
\tcode{\~{}X()}
in a member function is not an explicit destructor call~(\ref{expr.unary.op}).
\exitnote

\pnum
\enternote
\indextext{object!destructor~and placement~of}%
explicit calls of destructors are rarely needed.
One use of such calls is for objects placed at specific
addresses using a
\grammarterm{new-expression}
with the placement option.
Such use of explicit placement and destruction of objects can be necessary
to cope with dedicated hardware resources and for writing memory management
facilities.
For example,
\indextext{example!explicit destructor~call}%

\begin{codeblock}
void* operator new(size_t, void* p) { return p; }
struct X {
    // ...
    X(int);
    ~X();
};
void f(X* p);

void g()			// rare, specialized use:
{
    char* buf = new char[sizeof(X)];
    X* p = new(buf) X(222);     // use \tcode{buf[]} and initialize
    f(p);
    p->X::~X();                 // cleanup
}
\end{codeblock}
\exitnoteb

\pnum
Once a destructor is invoked for an object, the object no longer exists;
the behavior is undefined if the destructor is invoked
for an object whose lifetime has ended~(\ref{basic.life}).
\enterexample
if the destructor for an automatic object is explicitly invoked,
and the block is subsequently left in a manner that would ordinarily
invoke implicit destruction of the object, the behavior is undefined.
\exitexample

\pnum
\enternote
\indextext{fundamental~type!destructor~and}%
the notation for explicit call of a destructor can be used for any scalar type
name~(\ref{expr.pseudo}).
Allowing this makes it possible to write code without having to know if a
destructor exists for a given type.
For example,

\begin{codeblock}
typedef int I;
I* p;
// ...
p->I::~I();
\end{codeblock}
\exitnoteb

\rSec1[class.free]{Free store}%
\indextext{free store}%

\pnum
\indextext{\idxcode{new}!type~of}
Any allocation function for a class
\tcode{T}
is a static member (even if not explicitly declared
\tcode{static}).

\pnum
\enterexample

\begin{codeblock}
class Arena;
struct B {
    void* operator new(size_t, Arena*);
};
struct D1 : B {
};

Arena*  ap;
void foo(int i)
{
    new (ap) D1;		// calls \tcode{B::operator new(size_t, Arena*)}
    new D1[i];			// calls \tcode{::operator new[](size_t)}
    new D1;			// ill-formed: \tcode{::operator new(size_t)} hidden
}
\end{codeblock}
\exitexampleb

\pnum
\indextext{\idxcode{delete}}%
When an object is deleted with a
\grammarterm{delete-expression}~(\ref{expr.delete}),
a \term{deallocation function}
\indextext{function!deallocation}%
(\tcode{operator delete()}
\indextext{\idxcode{operator delete}}%
for non-array objects or
\tcode{operator delete[]()}
\indextext{\idxcode{operator delete}}%
for arrays) is (implicitly) called to reclaim the storage occupied by
the object~(\ref{basic.stc.dynamic.deallocation}).

\pnum
If a
\grammarterm{delete-expression}
begins with a unary
\tcode{::}
operator,
the deallocation function's name is looked up in global scope.
Otherwise, if the
\grammarterm{delete-expression}
is used to deallocate a class object whose static type has a virtual
destructor, the deallocation function is the one found by the lookup in
the definition of the dynamic type's virtual
destructor~(\ref{class.dtor}).\footnote{A similar lookup is not needed for
the array version of \tcode{operator} \tcode{delete} because~\ref{expr.delete}
requires that in this situation, the static type of the
\grammarterm{delete-expression}'s operand be the same as its dynamic type.
}
Otherwise, if the
\grammarterm{delete-expression}
is used to deallocate an object of class
\tcode{T}
or array thereof, the static and dynamic types of the object shall be
identical and the deallocation function's name is looked up in the scope of
\tcode{T}.
If this lookup fails to find the name, the name is looked up in the global
scope.
If the result of the lookup is ambiguous or inaccessible, or if the lookup
selects a placement deallocation function, the program is ill-formed.

\pnum
When a
\grammarterm{delete-expression}
is executed, the selected deallocation function shall be called with
the address of the block of storage to be reclaimed as its first argument and
(if the two-parameter style is used) the size of the block as its second
argument.\footnote{If the static type in the \grammarterm{delete-expression}
is different from
the dynamic type and the destructor is not virtual the size might be
incorrect, but that case is already undefined; see~\ref{expr.delete}.
}

\pnum
\indextext{\idxcode{delete}!type~of}%
Any deallocation function for a class
\tcode{X}
is a static member (even if not explicitly declared
\tcode{static}).
\indextext{example!\idxcode{delete}}%
\enterexample

\begin{codeblock}
class X {
    // ...
    void operator delete(void*);
    void operator delete[](void*, size_t);
};

class Y {
    // ...
    void operator delete(void*, size_t);
    void operator delete[](void*);
};
\end{codeblock}
\exitexampleb

\pnum
Since member allocation and deallocation functions are
\tcode{static}
they cannot be virtual.
\enternote
\indextext{example!destructor~and \tcode{delete}}%
\indextext{example!scope~of \tcode{delete}}%
however, when the
\grammarterm{cast-expression}
of a
\grammarterm{delete-expression}
refers to an object of class type,
because the deallocation function actually called is looked up in the scope of
the class that is the dynamic type of the object,
if the destructor is virtual, the effect is the same.
For example,

\begin{codeblock}
struct B {
    virtual ~B();
    void operator delete(void*, size_t);
};

struct D : B {
    void operator delete(void*);
};

void f()
{
    B* bp = new D;
    delete bp;			//1: uses \tcode{D::operator delete(void*)}
}
\end{codeblock}

Here, storage for the non-array object of class
\tcode{D}
is deallocated by
\tcode{D::operator delete()},
due to the virtual destructor.
\exitnote
\enternote
virtual destructors have no effect on the deallocation function actually
called when the
\grammarterm{cast-expression}
of a
\grammarterm{delete-expression}
refers to an array of objects of class type.
For example,

\begin{codeblock}
struct B {
    virtual ~B();
    void operator delete[](void*, size_t);
};

struct D : B {
    void operator delete[](void*, size_t);
};

void f(int i)
{
    D* dp = new D[i];
    delete [] dp;		// uses \tcode{D::operator delete[](void*, size_t)}
    B* bp = new D[i];
    delete[] bp;		// undefined behavior
}
\end{codeblock}
\exitnoteb

\pnum
Access to the deallocation function is checked statically.
Hence, even though a different one might actually be executed,
the statically visible deallocation function is required to be accessible.
\enterexample
for the call on line //1 above,
if
\tcode{B::operator delete()}
had been
\tcode{private},
the delete expression would have been ill-formed.
\exitexample

\rSec1[class.init]{Initialization}%
\indextext{initialization!class~object|(}%
\indextext{initialization!default constructor and}%
\indextext{initialization!constructor~and}

\pnum
When no initializer is specified for an object of (possibly
cv-qualified) class type (or array thereof), or the initializer has
the form
\tcode{()},
the object is initialized as specified in~\ref{dcl.init}.
The object is default-initialized if there is no initializer, or
value-initialized if the initializer is \tcode{()}.

\pnum
An object of class type (or array thereof) can be explicitly initialized;
see~\ref{class.expl.init} and~\ref{class.base.init}.

\pnum
\indextext{order~of~execution!constructor~and array}%
When an array of class objects is initialized
(either explicitly or implicitly),
the constructor shall be called for each element of the array,
following the subscript order; see~\ref{dcl.array}.
\enternote
destructors for the array elements are called in reverse order of their
construction.
\exitnote

\rSec2[class.expl.init]{Explicit initialization}%
\indextext{initialization!explicit}%
\indextext{initialization!constructor~and}%

\pnum
An object of class type can be initialized with a parenthesized
\grammarterm{expression-list},
where the
\grammarterm{expression-list}
is construed as an argument list for a constructor
that is called to initialize the object.
Alternatively, a single
\grammarterm{assignment-expression}
can be specified as an
\grammarterm{initializer}
using the
\tcode{=}
form of initialization.
Either direct-initialization semantics or copy-initialization semantics apply;
see~\ref{dcl.init}.
\indextext{example!constructor~and initialization}%
\enterexample

\begin{codeblock}
class complex {
    // ...
public:
    complex();
    complex(double);
    complex(double,double);
    // ...
};

complex sqrt(complex,complex);

	complex a(1);			// initialize by a call of
					// \tcode{complex(double)}
	complex b = a;			// initialize by a copy of \tcode{a}
	complex c = complex(1,2);       // construct \tcode{complex(1,2)}
					// using \tcode{complex(double,double)}
					// copy it into \tcode{c}
	complex d = sqrt(b,c);		// call \tcode{sqrt(complex,complex)}
					// and copy the result into \tcode{d}
	complex e;			// initialize by a call of
					// \tcode{complex()}
	complex f = 3;			// construct \tcode{complex(3)} using
					// \tcode{complex(double)}
					// copy it into \tcode{f}
	complex g = { 1, 2 };		// error; constructor is required
\end{codeblock}
\exitexampleb
\enternote
\indextext{initialization!overloaded assignment~and}%
overloading of the assignment operator~(\ref{over.ass})
has no effect on initialization.
\exitnote

\pnum
\indextext{initialization!array~of class~objects}%
\indextext{constructor!array~of class~objects~and}%
When an aggregate (whether class or array) contains members of class type
and is initialized by a brace-enclosed
\grammarterm{initializer-list}~(\ref{dcl.init.aggr}), each such member is
copy-initialized (see~\ref{dcl.init}) by the corresponding
\grammarterm{assignment-expression}. If there are fewer
\grammarterm{initializer}{s} in the \grammarterm{initializer-list} than
members of the aggregate, each member not explicitly initialized shall be
value-initialized~(\ref{dcl.init}).
\enternote
\ref{dcl.init.aggr} describes how \grammarterm{assignment-expression}{s}
in an \grammarterm{initializer-list} are paired with the aggregate members
they initialize.
\exitnote
\enterexample

\begin{codeblock}
complex v[6] = { 1,complex(1,2),complex(),2 };
\end{codeblock}

Here,
\tcode{complex::complex(double)}
is called for the initialization of
\tcode{v[0]}
and
\tcode{v[3]},
\tcode{complex::complex(\brk{}double,double)}
is called for the initialization of
\tcode{v[1]},
\tcode{complex::complex()}
is called for the initialization
\tcode{v[2]},
\tcode{v[4]},
and
\tcode{v[5]}.
For another example,

\begin{codeblock}
class X {
public:
	int i;
	float f;
	complex c;
} x = { 99, 88.8, 77.7 };
\end{codeblock}

Here,
\tcode{x.i}
is initialized with 99,
\tcode{x.f}
is initialized with 88.8, and
\tcode{complex::complex(double)}
is called for the initialization of
\tcode{x.c}.
\exitexample
\enternote
braces can be elided in the
\grammarterm{initializer-list}
for any aggregate, even if the aggregate has members of a class type with
user-defined type conversions; see~\ref{dcl.init.aggr}.
\exitnote

\pnum
\enternote
if
\tcode{T}
is a class type with no default constructor,
any declaration of an object of type
\tcode{T}
(or array thereof) is ill-formed if no
\grammarterm{initializer}
is explicitly specified (see~\ref{class.init} and~\ref{dcl.init}).
\exitnote

\pnum
\enternote
\indextext{order~of~execution!constructor~and \tcode{static}~objects}%
the order in which objects with static storage duration
are initialized is described in~\ref{basic.start.init} and~\ref{stmt.dcl}.
\exitnote

\rSec2[class.base.init]{Initializing bases and members}%
\indextext{initialization!base~class}%
\indextext{initialization!member}

\pnum
In the definition of a constructor for a class,
initializers for direct and virtual base subobjects and
nonstatic data members can be specified by a
\grammarterm{ctor-initializer},
which has the form

\begin{bnf}
\nontermdef{ctor-initializer}\br
    \terminal{:} mem-initializer-list
\end{bnf}

\begin{bnf}
\nontermdef{mem-initializer-list}\br
    mem-initializer\br
    mem-initializer \terminal{,} mem-initializer-list
\end{bnf}

\begin{bnf}
\nontermdef{mem-initializer}\br
    mem-initializer-id \terminal{(} expression-list\opt \terminal{)}
\end{bnf}

\begin{bnf}
\nontermdef{mem-initializer-id}\br
    \terminal{::}\opt nested-name-specifier\opt class-name\br
    identifier
\end{bnf}

\pnum
Names in a \grammarterm{mem-initializer-id} are
looked up in the scope of the constructor's class
and, if not found in that scope, are looked up in the scope containing the
constructor's definition.
\enternote
if the constructor's class contains a member with the same name as a direct
or virtual base class of the class, a
\grammarterm{mem-initializer-id}
naming the member or base class and composed of a single identifier
refers to the class member.
A
\grammarterm{mem-initializer-id}
for the hidden base class may be specified using a qualified name.
\exitnote
Unless the
\grammarterm{mem-initializer-id}
names a nonstatic data member of the constructor's class or
a direct or virtual base of that class,
the
\grammarterm{mem-initializer}
is ill-formed.
A
\grammarterm{mem-initializer-list}
can initialize a base class using any name that denotes that base class type.
\enterexample

\begin{codeblock}
struct A { A(); };
typedef A global_A;
struct B { };
struct C: public A, public B { C(); };
C::C(): global_A() { }		// mem-initializer for base \tcode{A}
\end{codeblock}
\exitexampleb
If a
\grammarterm{mem-initializer-id}
is ambiguous because it designates both a direct non-virtual base class and
an inherited virtual base class, the
\grammarterm{mem-initializer}
is ill-formed.
\enterexample

\begin{codeblock}
struct A { A(); };
struct B: public virtual A { };
struct C: public A, public B { C(); };
C::C(): A() { }                 // ill-formed: which \tcode{A}?
\end{codeblock}
\exitexampleb
A
\grammarterm{ctor-initializer}
may initialize the member of an anonymous union that is a member of the
constructor's class.
If a
\grammarterm{ctor-initializer}
specifies more than one
\grammarterm{mem-initializer}
for the same member, for the same base class or for multiple members of the
same union (including members of anonymous union),
the
\grammarterm{ctor-initializer}
is ill-formed.

\pnum
\indextext{initialization!base~class}%
\indextext{initialization!member~object}%
The
\grammarterm{expression-list}
in a
\grammarterm{mem-initializer}
is used to initialize the base class or nonstatic data member
subobject denoted by the \grammarterm{mem-initializer-id}. The semantics
of a \grammarterm{mem-initializer} are as follows:

\begin{itemize}
\item if the \grammarterm{expression-list} of the \grammarterm{mem-initializer}
is omitted, the base class or member subobject is value-initialized
(see~\ref{dcl.init});
\item otherwise, the subobject indicated by \grammarterm{mem-initializer-id}
is direct-initialized using \grammarterm{expression-list} as the
\grammarterm{initializer} (see~\ref{dcl.init}).
\end{itemize}

\enterexample

\begin{codeblock}
struct B1 { B1(int); /* ... */ };
struct B2 { B2(int); /* ... */ };
struct D : B1, B2 {
    D(int);
    B1 b;
    const int c;
};

D::D(int a) : B2(a+1), B1(a+2), c(a+3), b(a+4)
{ /* ... */ }
D d(10);
\end{codeblock}
\exitexampleb
There is a sequence point~(\ref{intro.execution}) after the initialization
of each base and member. The \grammarterm{expression-list} of a
\grammarterm{mem-initializer} is evaluated as part of the initialization
of the corresponding base or member.

\pnum
If a given nonstatic data member or base class is not named by a
\grammarterm{mem-initializer-id}
(including the case where there is no
\grammarterm{mem-initializer-list}
because the constructor has no
\grammarterm{ctor-initializer}), then

\begin{itemize}
\item If the entity is a nonstatic data member of (possibly cv-qualified)
class type (or array thereof) or a base class, and the entity class is a
non-POD class, the entity is default-initialized~(\ref{dcl.init}). If the
entity is a non-static data member of a const-qualified type, the entity
class shall have a user-declared default constructor.
\item Otherwise, the entity is not initialized. If the entity is of
const-qualified type or reference type, or of a (possibly cv-qualified) POD
class type (or array thereof) containing (directly or indirectly) a member
of a const-qualified type, the program is ill-formed.
\end{itemize}

After the call to a constructor for class \tcode{X} has completed, if a
member of \tcode{X} is neither specified in the constructor's
\grammarterm{mem-initializer}{s}, nor default-initialized, nor
value-initialized, nor given a value during execution of the body of the
constructor, the member has indeterminate value.

\pnum
Initialization shall proceed in the following order:

\begin{itemize}
\item
\indextext{initialization!order~of virtual~base~class}%
First, and only for the constructor of the most derived class as described
below,
virtual base classes shall be initialized in the order they appear on a
depth-first left-to-right traversal of the directed acyclic graph of
base classes,
where ``left-to-right'' is the order of appearance of the base classes
names in the derived class
\grammarterm{base-specifier-list}.
\item
\indextext{initialization!order~of base~class}%
Then, direct base classes shall be initialized in declaration order
as they appear in the
\grammarterm{base-specifier-list}
(regardless of the order of the
\grammarterm{mem-initializers}).
\item
\indextext{initialization!order~of member}%
Then, nonstatic data members shall be initialized in the order
they were declared in the class definition
(again regardless of the order of the
\grammarterm{mem-initializers}).
\item
Finally, the body of the constructor is executed.
\end{itemize}

\enternote
the declaration order is mandated to ensure that base and member
subobjects are destroyed in the reverse order of initialization.
\exitnote

\pnum
All sub-objects representing virtual base classes are initialized by the
constructor of the most derived class~(\ref{intro.object}). If the
constructor of the most derived class does not specify a
\grammarterm{mem-initializer} for a virtual base class \tcode{V}, then
\tcode{V}'s default constructor is called to initialize the virtual base
class subobject. If \tcode{V} does not have an accessible default
constructor, the initialization is ill-formed. A \grammarterm{mem-initializer}
naming a virtual base class shall be ignored during execution of the
constructor of any class that is not the most derived class.
\enterexample
\begin{codeblock}
class V {
public:
    V();
    V(int);
    // ...
};

class A : public virtual V {
public:
    A();
    A(int);
    // ...
};

class B : public virtual V {
public:
    B();
    B(int);
    // ...
};

class C : public A, public B, private virtual V {
public:
    C();
    C(int);
    // ...
};

A::A(int i) : V(i) { /* ... */ }
B::B(int i) { /* ... */ }
C::C(int i) { /* ... */ }

V v(1);				// use \tcode{V(int)}
A a(2);				// use \tcode{V(int)}
B b(3);				// use \tcode{V()}
C c(4);				// use \tcode{V()}
\end{codeblock}
\exitexampleb

\pnum
\indextext{initializer!scope~of member}%
Names in the
\grammarterm{expression-list}
of a
\grammarterm{mem-initializer}
are evaluated in the scope of the constructor for which the
\grammarterm{mem-initializer}
is specified.
\enterexample

\begin{codeblock}
class X {
    int a;
    int b;
    int i;
    int j;
public:
    const int& r;
    X(int i): r(a), b(i), i(i), j(this->i) {}
};
\end{codeblock}

initializes
\tcode{X::r}
to refer to
\tcode{X::a},
initializes
\tcode{X::b}
with the value of the constructor parameter
\tcode{i},
initializes
\tcode{X::i}
with the value of the constructor parameter
\tcode{i},
and initializes
\tcode{X::j}
with the value of
\tcode{X::i};
this takes place each time an object of class
\tcode{X}
is created.
\exitexample
\enternote
because the
\grammarterm{mem-initializer}
are evaluated in the scope of the constructor, the
\tcode{this}
pointer can be used in the
\grammarterm{expression-list}
of a
\grammarterm{mem-initializer}
to refer to the object being initialized.
\exitnote

\pnum
\indextext{initialization!member function call during}%
Member functions (including virtual member functions, \ref{class.virtual}) can be
called for an object under construction.
Similarly, an object under construction can be the operand of the
\tcode{typeid}
operator~(\ref{expr.typeid}) or of a
\tcode{dynamic_cast}~(\ref{expr.dynamic.cast}).
However, if these operations are performed in a
\grammarterm{ctor-initializer}
(or in a function called directly or indirectly from a
\grammarterm{ctor-initializer})
before all the
\grammarterm{mem-initializer}{s}
for base classes have completed, the result of the operation is undefined.
\enterexample

\begin{codeblock}
class A {
public:
	A(int);
};

class B : public A {
	int j;
public:
	int f();
	B() : A(f()),		// undefined: calls member function
				// but base \tcode{A} not yet initialized
	j(f()) { }		// well-defined: bases are all initialized
};

class C {
public:
	C(int);
};

class D : public B, C {
	int i;
public:
	D() : C(f()),		// undefined: calls member function
				// but base \tcode{C} not yet initialized
	i(f()) { }		// well-defined: bases are all initialized
};
\end{codeblock}
\exitexampleb

\pnum
\enternote
\ref{class.cdtor} describes the result of virtual function calls,
\tcode{typeid}
and
\tcode{dynamic_cast}s
during construction for the well-defined cases;
that is, describes the
\term{polymorphic behavior}
of an object under construction.
\exitnote%
\indextext{initialization!class~object|)}

\rSec1[class.cdtor]{Construction and destruction}%
\indextext{construction|(}%
\indextext{destruction|(}

\pnum
\indextext{construction!member access}%
\indextext{destruction!member access}%
For an object of non-POD class type (clause~\ref{class}),
before the constructor begins execution and after the destructor finishes
execution, referring to
any nonstatic member or base class of the object results in undefined behavior.
\enterexample

\begin{codeblock}
struct X { int i; };
struct Y : X { };
struct A { int a; };
struct B : public A { int j; Y y; };

extern B bobj;
B* pb = &bobj;                  // OK
int* p1 = &bobj.a;              // undefined, refers to base class member
int* p2 = &bobj.y.i;            // undefined, refers to member's member

A* pa = &bobj;                  // undefined, upcast to a base class type
B bobj;                         // definition of \tcode{bobj}

extern X xobj;
int* p3 = &xobj.i;              // OK, \tcode{X} is a POD class
X xobj;
\end{codeblock}

For another example,

\begin{codeblock}
struct W { int j; };
struct X : public virtual W { };
struct Y {
	int *p;
	X x;
	Y() : p(&x.j)		// undefined, \tcode{x} is not yet constructed
	{ }
};
\end{codeblock}
\exitexampleb

\pnum
\indextext{construction!pointer to member or base}%
\indextext{destruction!pointer to member or base}%
To explicitly or implicitly convert a pointer (an lvalue) referring to
an object of class
\tcode{X}
to a pointer (reference) to a direct or indirect base class
\tcode{B}
of
\tcode{X},
the construction of
\tcode{X}
and the construction of all of its direct or indirect bases that directly or
indirectly derive from
\tcode{B}
shall have started and the destruction of these classes shall not have
completed, otherwise the conversion results in undefined behavior.
To form a pointer to (or access the value of) a direct nonstatic member of
an object
\tcode{obj},
the construction of
\tcode{obj}
shall have started and its destruction shall not have completed,
otherwise the computation of the pointer value (or accessing the member
value) results in undefined behavior.
\enterexample

\begin{codeblock}
struct A { };
struct B : virtual A { };
struct C : B { };
struct D : virtual A { D(A*); };
struct X { X(A*); };

struct E : C, D, X {
	E() : D(this),		// undefined: upcast from \tcode{E*} to \tcode{A*}
				// might use path \tcode{E*} $\rightarrow$ \tcode{D*} $\rightarrow$ \tcode{A*}
				// but \tcode{D} is not constructed
				// \tcode{D((C*)this)}, // defined:
				// \tcode{E*} $\rightarrow$ \tcode{C*} defined because \tcode{E()} has started
				// and \tcode{C*} $\rightarrow$ \tcode{A*} defined because
				// \tcode{C} fully constructed
	X(this) {		// defined: upon construction of \tcode{X},
				// \tcode{C/B/D/A} sublattice is fully constructed
	{ }
};
\end{codeblock}
\exitexampleb

\pnum
\indextext{virtual~function~call!constructor~and}%
\indextext{virtual~function~call!destructor~and}%
\indextext{construction!virtual function call}%
\indextext{destruction!virtual function call}%
Member functions, including virtual functions~(\ref{class.virtual}), can be called
during construction or destruction~(\ref{class.base.init}).
When a virtual function is called directly or indirectly from a constructor
(including from the \grammarterm{mem-initializer} for a data member)
or from a destructor,
and the object to which the call applies is the object under construction or
destruction,
the function called is the one defined
in the constructor or destructor's own class or in one of its bases, but not
a function
overriding it in a class derived from the constructor or destructor's class,
or overriding it in one of the other base classes of the most derived
object~(\ref{intro.object}).
If the virtual function call uses an explicit class member access~(\ref{expr.ref})
and the object-expression refers to the
object under construction or destruction but its type is neither the
constructor or destructor's own class or one of its bases, the result of the
call is undefined.
\enterexample

\begin{codeblock}
class V {
public:
	virtual void f();
	virtual void g();
};

class A : public virtual V {
public:
	virtual void f();
};

class B : public virtual V {
public:
	virtual void g();
	B(V*, A*);
};

class D : public A, B {
public:
	virtual void f();
	virtual void g();
	D() : B((A*)this, this) { }
};

B::B(V* v, A* a) {
	f();              // calls \tcode{V::f}, not \tcode{A::f}
	g();              // calls \tcode{B::g}, not \tcode{D::g}
	v->g();           // \tcode{v} is base of \tcode{B}, the call is well-defined, calls \tcode{B::g}
	a->f();           // undefined behavior, \tcode{a}'s type not a base of \tcode{B}
}
\end{codeblock}
\exitexampleb

\pnum
\indextext{construction!\idxcode{typeid} operator}%
\indextext{destruction!\idxcode{typeid} operator}%
\indextext{\idxcode{typeid}!construction and}%
\indextext{\idxcode{typeid}!destruction and}%
The
\tcode{typeid}
operator~(\ref{expr.typeid}) can be used during construction or destruction~(\ref{class.base.init}).
When
\tcode{typeid}
is used in a constructor (including from the
\grammarterm{mem-initializer}
for a data member)
or in a destructor, or used in a function called (directly or indirectly) from
a constructor or destructor, if the operand of
\tcode{typeid}
refers to the object under construction or destruction,
\tcode{typeid}
yields the
\tcode{type_info}
representing the constructor or destructor's class.
If the operand of
\tcode{typeid}
refers to the object under construction or destruction and the static type of
the operand is neither the constructor or destructor's class nor one of its
bases, the result of
\tcode{typeid}
is undefined.

\pnum
\indextext{construction!dynamic cast and}%
\indextext{destruction!dynamic cast and}%
\indextext{cast!dynamic!construction and}%
\indextext{cast!dynamic!destruction and}%
\tcode{dynamic_cast}s~(\ref{expr.dynamic.cast}) can be used during construction
or destruction~(\ref{class.base.init}). When a
\tcode{dynamic_cast}
is used in a constructor (including from the
\grammarterm{mem-initializer}
for a data member)
or in a destructor, or used in a function called (directly or indirectly) from
a constructor or destructor, if the operand of the
\tcode{dynamic_cast}
refers to the object under construction or destruction, this object is
considered to be a most derived object that has the type of the constructor or
destructor's class.
If the operand of the
\tcode{dynamic_cast}
refers to the object under construction or destruction and the static type of
the operand is not a pointer to or object of the constructor or destructor's
own class or one of its bases, the
\tcode{dynamic_cast}
results in undefined behavior.

\pnum
\enterexample

\begin{codeblock}
class V {
public:
	virtual void f();
};

class A : public virtual V { };

class B : public virtual V {
public:
	B(V*, A*);
};

class D : public A, B {
public:
	D() : B((A*)this, this) { }
};

B::B(V* v, A* a) {
	typeid(*this);          // \tcode{type_info} for \tcode{B}
	typeid(*v);             // well-defined: \tcode{*v} has type \tcode{V}, a base of \tcode{B}
                                // yields \tcode{type_info} for \tcode{B}
	typeid(*a);             // undefined behavior: type \tcode{A} not a base of \tcode{B}
	dynamic_cast<B*>(v);    // well-defined: \tcode{v} of type \tcode{V*}, \tcode{V} base of \tcode{B}
                                // results in \tcode{B*}
	dynamic_cast<B*>(a);    // undefined behavior,
                                // \tcode{a} has type \tcode{A*}, \tcode{A} not a base of \tcode{B}
}
\end{codeblock}
\exitexampleb%
\indextext{destruction|)}%
\indextext{construction|)}

\rSec1[class.copy]{Copying class objects}%
\indextext{copy!class~object|see{constructor, copy; assignment, copy}}%
\indextext{constructor!copy}%
\indextext{operator!copy assignment|see{assignment, copy}}%

\pnum
A class object can be copied in two ways,
by initialization~(\ref{class.ctor}, \ref{dcl.init}), including for function
argument passing~(\ref{expr.call}) and for function value return~(\ref{stmt.return});
and by assignment~(\ref{expr.ass}).
Conceptually, these two operations are implemented by a
copy constructor~(\ref{class.ctor})
and copy assignment operator~(\ref{over.ass}).

\pnum
\indextext{constructor!copy|(}%
A non-template constructor for class
\tcode{X}
is
a
\term{copy}
constructor if its first parameter is of type
\tcode{X\&},
\tcode{const X\&},
\tcode{volatile X\&}
or
\tcode{const volatile X\&},
and either there are no other parameters
or else all other parameters have default arguments~(\ref{dcl.fct.default}).%
\footnote{Because a template constructor is never a copy constructor, the
presence of such a template does not suppress the implicit declaration of a
copy constructor. Template constructors participate in overload resolution
with other constructors, including copy constructors, and a template
constructor may be used to copy an object if it provides a better match
than other constructors.}
\enterexample
\tcode{X::X(const X\&)}
and
\tcode{X::X(X\&, int=1)}
are copy constructors.

\begin{codeblock}
class X {
    // ...
public:
    X(int);
    X(const X&, int = 1);
};
X a(1);				// calls \tcode{X(int);}
X b(a, 0);			// calls \tcode{X(const X\&, int);}
X c = b;			// calls \tcode{X(const X\&, int);}
\end{codeblock}
\exitexampleb
\enternote
all forms of copy constructor may be declared for a class.
\enterexample

\begin{codeblock}
class X {
	// ...
public:
	X(const X&);
	X(X&);			// OK
};
\end{codeblock}
\exitexampleb
\exitnoteb
\enternote
if a class
\tcode{X}
only has a copy constructor with a parameter of type
\tcode{X\&},
an initializer of type
\tcode{const}
\tcode{X}
or
\tcode{volatile}
\tcode{X}
cannot initialize an object of type (possibly cv-qualified)
\tcode{X}.
\enterexample

\begin{codeblock}
struct X {
	X();			// default constructor
	X(X&);			// copy constructor with a nonconst parameter
};
const X cx;
X x = cx;			// error -- \tcode{X::X(X\&)} cannot copy \tcode{cx} into \tcode{x}
\end{codeblock}
\exitexampleb
\exitnoteb

\pnum
A declaration of a constructor for a class
\tcode{X}
is ill-formed if its first parameter is of type (optionally cv-qualified)
\tcode{X}
and either there are no other parameters or else all other parameters have
default arguments.
A member function template is never instantiated to perform the copy of a
class object to an object of its class type.
\enterexample
\begin{codeblock}
struct S {
	template<typename T> S(T);
};

S f();

void g() {
	S a( f() ); // does not instantiate member template
}
\end{codeblock}
\exitexampleb

\pnum
\indextext{constructor!copy!implicitly declared}%
If the class definition does not explicitly declare a copy constructor,
one is declared \term{implicitly}.
Thus, for the class definition

\begin{codeblock}
struct X {
	X(const X&, int);
};
\end{codeblock}

a copy constructor is implicitly-declared.
If the user-declared constructor is later defined as

\begin{codeblock}
X::X(const X& x, int i =0) { /* ... */ }
\end{codeblock}

then any use of
\tcode{X}'s
copy constructor is ill-formed because of the ambiguity;
no diagnostic is required.

\pnum
The implicitly-declared copy constructor for a class
\tcode{X}
will have the form

\begin{codeblock}
X::X(const X&)
\end{codeblock}

if

\begin{itemize}
\item
each direct or virtual base class
\tcode{B}
of
\tcode{X}
has a copy constructor whose first parameter is of type
\tcode{const}
\tcode{B\&}
or
\tcode{const}
\tcode{volatile}
\tcode{B\&},
and
\item
for all the nonstatic data members of
\tcode{X}
that are of a class type
\tcode{M}
(or array thereof),
each such class type has a copy constructor whose first parameter is of type
\tcode{const}
\tcode{M\&}
or
\tcode{const}
\tcode{volatile}
\tcode{M\&}.\footnote{This implies that the reference parameter of the
implicitly-declared copy constructor
cannot bind to a
\tcode{volatile}
lvalue; see~\ref{diff.special}.}
\end{itemize}

Otherwise, the implicitly declared copy constructor will have the form

\begin{codeblock}
X::X(X&)
\end{codeblock}

An implicitly-declared copy constructor is an \tcode{inline}
\tcode{public} member of its class.

\pnum
\indextext{constructor!copy!trivial}%
A copy constructor for class
\tcode{X}
is
\term{trivial}
if it is implicitly declared and if

\begin{itemize}
\item
class
\tcode{X}
has no virtual functions~(\ref{class.virtual})
and no virtual base classes~(\ref{class.mi}), and

\item
each direct base class of \tcode{X} has a trivial copy constructor, and

\item
for all the nonstatic data members of
\tcode{X}
that are of class type (or array thereof), each such class type has a
trivial copy constructor;
\end{itemize}

otherwise the copy constructor is
\grammarterm{non-trivial}.

\pnum
\indextext{constructor!copy!implicitly defined}%
An implicitly-declared copy constructor is
\term{implicitly defined}
if it is used to initialize an object of its class type from a copy of an
object of its class type or of a class type derived from its class
type\footnote{See~\ref{dcl.init} for more details on direct and copy
initialization.}.
\enternote
the copy constructor is implicitly defined even if the implementation elided
its use (\ref{class.temporary}).
\exitnote
A program is ill-formed if the class for which a copy constructor is
implicitly defined has:

\begin{itemize}
\item a nonstatic data member of class type (or array thereof) with an
inaccessible or ambiguous copy constructor, or
\item a base class with an inaccessible or ambiguous copy constructor.
\end{itemize}

Before the implicitly-declared copy constructor for a class is
implicitly defined,
all implicitly-declared copy constructors for its direct and
virtual base classes and its nonstatic data members
shall have been implicitly defined.
\enternote
an implicitly-declared copy constructor has an
exception-specification~(\ref{except.spec}).
\exitnote

\pnum
The implicitly-defined copy constructor for class
\tcode{X}
performs a memberwise copy of its subobjects.
The order of copying is the same as the order of initialization of bases
and members in a user-defined constructor (see~\ref{class.base.init}).
Each subobject is copied in the manner appropriate to its type:

\begin{itemize}
\item
if the subobject is of class type, the copy constructor for the class is used;

\item
if the subobject is an array, each element is
copied, in the manner appropriate to the element type;

\item
if the subobject is of scalar type, the built-in assignment operator is used.
\end{itemize}

\indextext{initialization!virtual~base~class}%
Virtual base class subobjects shall be copied only once by
the implicitly-defined copy constructor (see~\ref{class.base.init}).

\pnum
\indextext{assignment operator!copy|(}%
A user-declared \term{copy} assignment operator \tcode{X::operator=} is a
non-static non-template member function of class \tcode{X} with exactly one
parameter of type \tcode{X}, \tcode{X\&}, \tcode{const} \tcode{X\&},
\tcode{volatile} \tcode{X\&} or \tcode{const} \tcode{volatile}
\tcode{X\&}.\footnote{Because a template assignment operator
is never a copy assignment
operator, the presence of such a template does not suppress the
implicit declaration of a copy assignment operator.
Template assignment operators
participate in overload resolution with other assignment operators, including
copy assignment operators, and a template assignment operator may
be used to assign an object if it provides a better match than object
assignment operators.}
\enternote
an overloaded assignment operator must be declared to have only one parameter;
see~\ref{over.ass}.
\exitnote
\enternote
more than one form of copy assignment operator may be declared for a class.
\exitnote
\enternote
if a class
\tcode{X}
only has a copy assignment operator with a parameter of type
\tcode{X\&},
an expression of type const
\tcode{X}
cannot be assigned to an object of type
\tcode{X}.
\enterexample

\begin{codeblock}
struct X {
	X();
	X& operator=(X&);
};
const X cx;
X x;
void f() {
	x = cx;			// error:
				// \tcode{X::operator=(X\&)} cannot assign \tcode{cx} into \tcode{x}
}
\end{codeblock}
\exitexampleb
\exitnoteb

\pnum
\indextext{assignment operator!copy!implicitly declared}%
If the class definition does not explicitly declare a copy assignment operator,
one is declared \term{implicitly}.
The implicitly-declared copy assignment operator for a class
\tcode{X}
will have the form

\begin{codeblock}
X& X::operator=(const X&)
\end{codeblock}

if

\begin{itemize}
\item
each direct base class
\tcode{B}
of
\tcode{X}
has a copy assignment operator whose parameter is of type
\tcode{const}
\tcode{B\&},
\tcode{const}
\tcode{volatile}
\tcode{B\&}
or
\tcode{B},
and
\item
for all the nonstatic data members of
\tcode{X}
that are of a class type
\tcode{M}
(or array thereof),
each such class type has a copy assignment operator whose parameter is of type
\tcode{const}
\tcode{M\&},
\tcode{const}
\tcode{volatile}
\tcode{M\&}
or
\tcode{M}.\footnote{This implies that the reference parameter of the
implicitly-declared copy assignment operator cannot bind to a
\tcode{volatile}
lvalue; see~\ref{diff.special}.}
\end{itemize}

Otherwise, the implicitly declared copy
assignment operator
will have the form

\begin{codeblock}
X& X::operator=(X&)
\end{codeblock}

The implicitly-declared copy assignment operator for class
\tcode{X}
has the return type
\tcode{X\&};
it returns the object for which the assignment operator is invoked, that is,
the object assigned to.
An implicitly-declared copy assignment operator is an
\tcode{inline}
\tcode{public}
member of its class.
\indextext{assignment operator!copy!hidden}%
Because a copy assignment operator is implicitly declared for a class
if not declared by the user,
a base class copy assignment operator is always hidden
by the copy assignment operator of a derived class~(\ref{over.ass}).
A
\grammarterm{using-declaration}~(\ref{namespace.udecl}) that brings in from a base class an assignment operator
with a parameter type that could be that of a
copy-assignment operator for the
derived class is not considered an explicit declaration of a copy-assignment
operator and does not suppress the implicit declaration of the derived class
copy-assignment operator;
the operator introduced by the
\grammarterm{using-declaration}
is hidden by the implicitly-declared copy-assignment operator in the derived
class.

\pnum
\indextext{assignment operator!copy!trivial}%
A copy assignment operator for class
\tcode{X}
is
\term{trivial}
if it is implicitly declared and if

\begin{itemize}
\item
class
\tcode{X}
has no virtual functions~(\ref{class.virtual})
and no virtual base classes~(\ref{class.mi}), and

\item
each direct base class of \tcode{X} has a trivial copy assignment operator; and

\item
for all the nonstatic data members of
\tcode{X}
that are of class type (or array thereof),
each such class type has a trivial copy assignment operator;
\end{itemize}

otherwise the copy assignment operator is
\grammarterm{non-trivial}.

\pnum
\indextext{assignment operator!copy!implicitly defined}%
An implicitly-declared copy assignment operator
is
\term{implicitly defined}
when an object of its class type is
assigned a value of its class type or a value of a class type derived
from its class type. A program is ill-formed
if the class for which a copy assignment operator is implicitly defined has:

\begin{itemize}
\item a nonstatic data member of \tcode{const} type, or
\item a nonstatic data member of reference type, or
\item a nonstatic data member of class type (or array thereof) with an
inaccessible copy assignment operator, or
\item a base class with an inaccessible copy assignment operator.
\end{itemize}

Before the implicitly-declared copy assignment operator for a class is
implicitly defined,
all implicitly-declared copy assignment operators for
its direct base classes and
its nonstatic data members shall have been implicitly defined.
\enternote
an implicitly-declared copy assignment operator has an
\grammarterm{exception-specification}~(\ref{except.spec}).
\exitnote

\pnum
The implicitly-defined copy assignment operator for a
class \tcode{X} performs memberwise assignment of its subobjects. The direct
base classes of \tcode{X} are assigned first, in the order of their declaration in the
\grammarterm{base-specifier-list}, and then the immediate nonstatic data members of
\tcode{X} are assigned, in the order in which they were declared in the class
definition.
Each subobject is assigned in the manner appropriate to its type:

\begin{itemize}
\item
if the subobject is of class type, the copy assignment operator for the
class is used (as if by explicit qualification; that is,
ignoring any possible virtual overriding functions in more derived classes);
\item
if the subobject is an array, each element is assigned,
in the manner appropriate to the element type;
\item
if the subobject is of scalar type,
the built-in assignment operator is used.
\end{itemize}

\indextext{assignment operator!copy!virtual bases and}%
It is unspecified whether subobjects representing virtual base classes
are assigned more than once by the implicitly-defined copy assignment
operator.
\enterexample

\begin{codeblock}
struct V { };
struct A : virtual V { };
struct B : virtual V { };
struct C : B, A { };
\end{codeblock}

it is unspecified whether the virtual base class subobject
\tcode{V}
is assigned twice by the implicitly-defined copy assignment operator for
\tcode{C}.
\exitexampleb

\pnum
\indextext{constructor!copy!inaccessible}%
\indextext{assignment operator!copy!inaccessible}%
A program is ill-formed if the copy constructor or the copy assignment
operator for an object is implicitly used and the special member function
is not accessible (clause~\ref{class.access}).
\enternote
Copying one object into another using the copy constructor or
the copy assignment operator does not change the layout or size of either
object.
\exitnote

\pnum
\indextext{temporary!elimination~of}%
\indextext{elision!copy constructor|see{constructor, copy, elision}}%
\indextext{constructor!copy!elision}%
When certain criteria are met, an implementation is
allowed to omit the copy construction of a class object,
even if the copy constructor and/or destructor for the
object have
\indextext{side effects}%
side effects.  In such cases, the
implementation treats the source and target of the
omitted copy operation as simply two different ways of
referring to the same object, and the destruction of
that object occurs at the later of the times when the
two objects would have been destroyed without the
optimization.\footnote{Because only one object is destroyed instead of two,
and one copy constructor
is not executed, there is still one object destroyed for each one constructed.}
This elision of copy operations
is permitted in the
following circumstances (which may be combined to
eliminate multiple copies):

\begin{itemize}
\item in a \tcode{return} statement in a function with a class return type,
when the expression is the name of a non-volatile
automatic object
with the same cv-unqualified type as
the function return type, the copy operation can be
omitted by constructing the automatic object directly
into the function's return value

\item when a temporary class object that has not been bound to a
reference~(\ref{class.temporary}) would be copied to a class object with
the same cv-unqualified type, the copy operation can be omitted by constructing
the temporary object directly into the target of the omitted copy
\end{itemize}

\enterexample

\begin{codeblock}
class Thing {
public:
    Thing();
    ~Thing();
    Thing(const Thing&);
};

Thing f() {
    Thing t;
    return t;
}

Thing t2 = f();
\end{codeblock}

Here the criteria for elision can be combined to
eliminate two calls to the copy constructor of class
\tcode{Thing}:
the copying of the local automatic object
\tcode{t}
into the temporary object for the return value of
function
\tcode{f()}
and the copying of that temporary object into object
\tcode{t2}.
Effectively, the construction of the local object
\tcode{t}
can be viewed as directly initializing the global
object
\tcode{t2},
and that object's destruction will occur at program
exit.
\exitexampleb
