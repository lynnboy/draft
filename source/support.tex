\rSec0[lib.language.support]{Language support library}

\pnum
This clause describes the function signatures that are called
implicitly, and the types of objects generated implicitly, during the execution
of some \Cpp programs.
It also describes the headers that declare these function
signatures and define any related types.

\pnum
The following subclauses describe
common type definitions used throughout the library,
characteristics of the predefined types,
functions supporting start and termination of a \Cpp program,
support for dynamic memory management,
support for dynamic type identification,
support for exception processing,
and other runtime support,
as summarized in Table~\ref{tab:lang.sup.lib.summary}.

\begin{libsumtab}{Language support library summary}{tab:lang.sup.lib.summary}
\ref{lib.support.types}       & Types                     &   \tcode{<cstddef>}   \\ \rowsep
                          &                           &   \tcode{<limits>}    \\
\ref{lib.support.limits}      & Implementation properties &   \tcode{<climits>}   \\
                          &                           &   \tcode{<cfloat>}    \\ \rowsep
\ref{lib.support.start.term}  & Start and termination     &   \tcode{<cstdlib>}   \\ \rowsep
\ref{lib.support.dynamic}     & Dynamic memory management &   \tcode{<new>}       \\ \rowsep
\ref{lib.support.rtti}        & Type identification       &   \tcode{<typeinfo>}  \\ \rowsep
\ref{lib.support.exception}   & Exception handling        &   \tcode{<exception>} \\ \rowsep
                          &                           &   \tcode{<cstdarg>}   \\
                          &                           &   \tcode{<csetjmp>}   \\
\ref{lib.support.runtime}     & Other runtime support     &   \tcode{<ctime>}     \\
                          &                           &   \tcode{<csignal>}   \\
                          &                           &   \tcode{<cstdlib>}   \\
\end{libsumtab}

\rSec1[lib.support.types]{Types}

\pnum
Common definitions.

\pnum
Header \tcode{<cstddef>} (Table~\ref{tab:support.hdr.cstddef}):

\indexlibrary{\idxcode{NULL}}%
\indexlibrary{\idxcode{offsetof}}%
\indexlibrary{\idxcode{ptrdiff_t}}%
\indexlibrary{\idxcode{size_t}}%
\begin{libsyntab3}{cstddef}{tab:support.hdr.cstddef}
\macros &   \tcode{NULL}        &   \tcode{offsetof}        \\ \rowsep
\types  &   \tcode{ptrdiff_t}   &   \tcode{size_t}          \\
\end{libsyntab3}

\pnum
The contents are the same as the Standard C library header
\tcode{<stddef.h>},
with the following changes:

\pnum
The macro
\indexlibrary{\idxcode{NULL}}%
\tcode{NULL}
is an implementation-defined \Cpp null pointer constant in
\indextext{implementation-defined}%
this International Standard (\ref{conv.ptr}).\footnote{Possible definitions include
\tcode{0}
and
\tcode{0L},
but not
\tcode{(void*)0}.}

\pnum
The macro
\indexlibrary{\idxcode{offsetof}}%
\tcode{offsetof} accepts a restricted set of \textit{type}
arguments in this International Standard. \textit{type} shall be a POD structure
or a POD union (clause~\ref{class}).
The results of applying the offsetof macro to a field that is a static data
member or a function member is undefined.

\xref subclause~\ref{expr.sizeof}, Sizeof, subclause~\ref{expr.add}, Additive operators,
subclause~\ref{class.free}, Free store, and ISO C subclause~7.1.6.

\rSec1[lib.support.limits]{Implementation properties}

\pnum
The headers
\tcode{<limits>},
\tcode{<climits>}, and
\tcode{<cfloat>}
supply characteristics of implementation-dependent
fundamental types~(\ref{basic.fundamental}).

\rSec2[lib.limits]{Numeric limits}

\pnum
The
\indexlibrary{\idxcode{numeric_limits}}%
\tcode{numeric_limits}
component provides a \Cpp program with information about various properties of
the implementation's representation of the
fundamental types.

\pnum
Specializations shall be provided for each
fundamental type,
both floating point and integer, including
\tcode{bool}.
The member
\tcode{is_specialized}
shall be
\tcode{true}
for all such specializations of
\tcode{numeric_limits}.

\pnum
For all members declared
\tcode{static} \tcode{const}
in the
\tcode{numeric_limits}
template, specializations shall define these values in such a way
that they are usable as integral constant expressions.

\pnum
Non-fundamental standard types, such as
\tcode{complex<T>}~(\ref{lib.complex}), shall not have specializations.

\indextext{\idxhdr{limits}}%
\indexlibrary{\idxhdr{limits}}%
\indextext{\idxcode{numeric\_limits}}%
\indexlibrary{\idxcode{numeric_limits}}%
\indexlibrary{\idxcode{float_round_style}}%
\indexlibrary{\idxcode{float_denorm_style}}%
\synopsis{Header \tcode{<limits>} synopsis}

\begin{codeblock}
namespace std {
  template<class T> class numeric_limits;
  enum float_round_style;
  enum float_denorm_style;

  template<> class numeric_limits<bool>;

  template<> class numeric_limits<char>;
  template<> class numeric_limits<signed char>;
  template<> class numeric_limits<unsigned char>;
  template<> class numeric_limits<wchar_t>;

  template<> class numeric_limits<short>;
  template<> class numeric_limits<int>;
  template<> class numeric_limits<long>;
  template<> class numeric_limits<unsigned short>;
  template<> class numeric_limits<unsigned int>;
  template<> class numeric_limits<unsigned long>;

  template<> class numeric_limits<float>;
  template<> class numeric_limits<double>;
  template<> class numeric_limits<long double>;
}
\end{codeblock}

\rSec3[lib.numeric.limits]{Class template \tcode{numeric_limits}}

\indexlibrary{\idxcode{numeric\_limits}}%
\begin{codeblock}
namespace std {
  template<class T> class numeric_limits {
  public:
    static const bool is_specialized = false;
    static T min() throw();
    static T max() throw();

    static const int  digits = 0;
    static const int  digits10 = 0;
    static const bool is_signed = false;
    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int  radix = 0;
    static T epsilon() throw();
    static T round_error() throw();

    static const int  min_exponent = 0;
    static const int  min_exponent10 = 0;
    static const int  max_exponent = 0;
    static const int  max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    static T infinity() throw();
    static T quiet_NaN() throw();
    static T signaling_NaN() throw();
    static T denorm_min() throw();

    static const bool is_iec559 = false;
    static const bool is_bounded = false;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
  };
}
\end{codeblock}

\pnum
The member \tcode{is_specialized} makes it possible to distinguish
between fundamental types, which have specializations, and non-scalar
types, which do not.

\pnum
The default
\tcode{numeric_limits<T>}
template shall have all members, but with 0 or
\tcode{false}
values.

\rSec3[lib.numeric.limits.members]{\tcode{numeric_limits} members}

\indexlibrary{\idxcode{min}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{min}}
\begin{itemdecl}
static T min() throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
Minimum finite value.\footnote{Equivalent to \tcode{CHAR_MIN}, \tcode{SHRT_MIN},
\tcode{FLT_MIN}, \tcode{DBL_MIN}, etc.}

\pnum
For floating types with denormalization, returns the minimum positive
normalized value.

\pnum
Meaningful for all specializations in which
\tcode{is_bounded != false},
or
\tcode{is_bounded == false \&\& is_signed == false}.
\end{itemdescr}

\indexlibrary{\idxcode{max}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{max}}
\begin{itemdecl}
static T max() throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
Maximum finite value.\footnote{Equivalent to \tcode{CHAR_MAX}, \tcode{SHRT_MAX},
\tcode{FLT_MAX}, \tcode{DBL_MAX}, etc.}

\pnum
Meaningful for all specializations in which
\tcode{is_bounded != false}.
\end{itemdescr}

\indexlibrary{\idxcode{digits}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{digits}}
\begin{itemdecl}
static const int  digits;
\end{itemdecl}

\begin{itemdescr}
\pnum
Number of
\tcode{radix}
digits that can be represented without change.

\pnum
For built-in integer types, the number of non-sign bits in the representation.

\pnum For floating point types, the number of \tcode{radix} digits in the
mantissa.\footnote{Equivalent to \tcode{FLT_MANT_DIG}, \tcode{DBL_MANT_DIG},
\tcode{LDBL_MANT_DIG}.} \end{itemdescr}

\indexlibrary{\idxcode{digits10}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{digits10}}
\begin{itemdecl}
static const int  digits10;
\end{itemdecl}

\begin{itemdescr}
\pnum
Number of base 10 digits that can be represented without
change.\footnote{Equivalent to \tcode{FLT_DIG}, \tcode{DBL_DIG},
\tcode{LDBL_DIG}.}

\pnum
Meaningful for all specializations in which
\tcode{is_bounded != false}.
\end{itemdescr}

\indexlibrary{\idxcode{is_signed}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{is_signed}}
\begin{itemdecl}
static const bool is_signed;
\end{itemdecl}

\begin{itemdescr}
\pnum
True if the type is signed.

\pnum
Meaningful for all specializations.
\end{itemdescr}

\indexlibrary{\idxcode{is_integer}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{is_integer}}
\begin{itemdecl}
static const bool is_integer;
\end{itemdecl}

\begin{itemdescr}
\pnum
True if the type is integer.

\pnum
Meaningful for all specializations.
\end{itemdescr}

\indexlibrary{\idxcode{is_exact}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{is_exact}}
\begin{itemdecl}
static const bool is_exact;
\end{itemdecl}

\begin{itemdescr}
\pnum
True if the type uses an exact representation.
All integer types are exact, but not all exact types are integer.
For example, rational and fixed-exponent representations are exact but not integer.

\pnum
Meaningful for all specializations.
\end{itemdescr}

\indexlibrary{\idxcode{radix}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{radix}}
\begin{itemdecl}
static const int  radix;
\end{itemdecl}

\begin{itemdescr}
\pnum
For floating types, specifies the base or radix of the exponent representation
(often 2).\footnote{Equivalent to \tcode{FLT_RADIX}.}

\pnum
For integer types, specifies the base of the
representation.\footnote{Distinguishes types with bases other than 2 (e.g.
BCD).}

\pnum
Meaningful for all specializations.
\end{itemdescr}

\indexlibrary{\idxcode{epsilon}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{epsilon}}
\begin{itemdecl}
static T epsilon() throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
Machine epsilon:  the difference between 1 and the least value greater than 1
that is representable.\footnote{Equivalent to \tcode{FLT_EPSILON}, \tcode{DBL_EPSILON}, \tcode{LDBL_EPSILON}.}

\pnum
Meaningful for all floating point types.
\end{itemdescr}

\indexlibrary{\idxcode{round_error}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{round_error}}
\begin{itemdecl}
static T round_error() throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
Measure of the maximum rounding error.\footnote{Rounding error is described in
ISO/IEC 10967-1 Language independent arithmetic -- Part 1
Section 5.2.8 and
Annex A Rationale Section A.5.2.8 -- Rounding constants.}
\end{itemdescr}

\indexlibrary{\idxcode{min_exponent}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{min_exponent}}
\begin{itemdecl}
static const int  min_exponent;
\end{itemdecl}

\begin{itemdescr}
\pnum
Minimum negative integer such that
\tcode{radix}
raised to the power of one less than that integer is a normalized floating
point number.\footnote{Equivalent to \tcode{FLT_MIN_EXP}, \tcode{DBL_MIN_EXP},
\tcode{LDBL_MIN_EXP}.}

\pnum
Meaningful for all floating point types.
\end{itemdescr}

\indexlibrary{\idxcode{min_exponent10}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{min_exponent10}}
\begin{itemdecl}
static const int  min_exponent10;
\end{itemdecl}

\begin{itemdescr}
\pnum
Minimum negative integer such that 10 raised to that power is in the range
of normalized floating point numbers.\footnote{Equivalent to
\tcode{FLT_MIN_10_EXP}, \tcode{DBL_MIN_10_EXP}, \tcode{LDBL_MIN_10_EXP}.}

\pnum
Meaningful for all floating point types.
\end{itemdescr}

\indexlibrary{\idxcode{max_exponent}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{max_exponent}}
\begin{itemdecl}
static const int  max_exponent;
\end{itemdecl}

\begin{itemdescr}
\pnum
Maximum positive integer such that
\tcode{radix}
raised to the power one less than that integer is a representable finite
floating point number.\footnote{Equivalent to \tcode{FLT_MAX_EXP},
\tcode{DBL_MAX_EXP}, \tcode{LDBL_MAX_EXP}.}

\pnum
Meaningful for all floating point types.
\end{itemdescr}

\indexlibrary{\idxcode{max_exponent10}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{max_exponent10}}
\begin{itemdecl}
static const int  max_exponent10;
\end{itemdecl}

\begin{itemdescr}
\pnum
Maximum positive integer such that 10 raised to that power is in the
range of representable finite floating point numbers.\footnote{Equivalent to
\tcode{FLT_MAX_10_EXP}, \tcode{DBL_MAX_10_EXP}, \tcode{LDBL_MAX_10_EXP}.}

\pnum
Meaningful for all floating point types.
\end{itemdescr}

\indexlibrary{\idxcode{has_infinity}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{has_infinity}}
\begin{itemdecl}
static const bool has_infinity;
\end{itemdecl}

\begin{itemdescr}
\pnum
True if the type has a representation for positive infinity.

\pnum
Meaningful for all floating point types.

\pnum
Shall be
\tcode{true}
for all specializations in which
\tcode{is_iec559 != false}.
\end{itemdescr}

\indexlibrary{\idxcode{has_quiet_NaN}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{has_quiet_NaN}}
\begin{itemdecl}
static const bool has_quiet_NaN;
\end{itemdecl}

\begin{itemdescr}
\pnum
True if the type has a representation for a quiet (non-signaling) ``Not a
Number.''\footnote{Required by LIA-1.}

\pnum
Meaningful for all floating point types.

\pnum
Shall be
\tcode{true}
for all specializations in which
\tcode{is_iec559 != false}.
\end{itemdescr}

\indexlibrary{\idxcode{has_signaling_NaN}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{has_signaling_NaN}}
\begin{itemdecl}
static const bool has_signaling_NaN;
\end{itemdecl}

\begin{itemdescr}
\pnum
True if the type has a representation for a signaling ``Not a Number.''\footnote{Required by LIA-1.}

\pnum
Meaningful for all floating point types.

\pnum
Shall be
\tcode{true}
for all specializations in which
\tcode{is_iec559 != false}.
\end{itemdescr}

\indexlibrary{\idxcode{float_denorm_style}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{float_denorm_style}}
\begin{itemdecl}
static const float_denorm_style has_denorm;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{denorm_present}
if the type allows denormalized values
(variable number of exponent bits)\footnote{Required by LIA-1.},
\tcode{denorm_absent}
if the type does not allow denormalized values,
and
\tcode{denorm_indeterminate}
if it is indeterminate at compile time whether the type allows
denormalized values.

\pnum
Meaningful for all floating point types.
\end{itemdescr}

\indexlibrary{\idxcode{has_denorm_loss}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{has_denorm_loss}}
\begin{itemdecl}
static const bool has_denorm_loss;
\end{itemdecl}

\begin{itemdescr}
\pnum
True if loss of accuracy is detected as a
denormalization loss, rather than as an inexact result.\footnote{See IEC 559.}
\end{itemdescr}

\indexlibrary{\idxcode{infinity}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{infinity}}
\begin{itemdecl}
static T infinity() throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
Representation of positive infinity, if available.\footnote{Required by LIA-1.}

\pnum
Meaningful for all specializations for which
\tcode{has_infinity != false}.
Required in specializations for which
\tcode{is_iec559 != false}.
\end{itemdescr}

\indexlibrary{\idxcode{quiet_NaN}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{quiet_NaN}}
\begin{itemdecl}
static T quiet_NaN() throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
Representation of a quiet ``Not a Number,'' if available.\footnote{Required by LIA-1.}

\pnum
Meaningful for all specializations for which
\tcode{has_quiet_NaN != false}.
Required in specializations for which
\tcode{is_iec559 != false}.
\end{itemdescr}

\indexlibrary{\idxcode{signaling_NaN}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{signaling_NaN}}
\begin{itemdecl}
static T signaling_NaN() throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
Representation of a signaling ``Not a Number,'' if available.\footnote{Required by LIA-1.}

\pnum
Meaningful for all specializations for which
\tcode{has_signaling_NaN != false}.
Required in specializations for which
\tcode{is_iec559 != false}.
\end{itemdescr}

\indexlibrary{\idxcode{denorm_min}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{denorm_min}}
\begin{itemdecl}
static T denorm_min() throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
Minimum positive denormalized value.\footnote{Required by LIA-1.}

\pnum
Meaningful for all floating point types.

\pnum
In specializations for which
\tcode{has_denorm == false},
returns the minimum positive normalized value.
\end{itemdescr}

\indexlibrary{\idxcode{is_iec559}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{is_iec559}}
\begin{itemdecl}
static const bool is_iec559;
\end{itemdecl}

\begin{itemdescr}
\pnum
True if and only if the type adheres to IEC 559 standard.\footnote{International
Electrotechnical Commission standard 559 is the same as
IEEE 754.}

\pnum
Meaningful for all floating point types.
\end{itemdescr}

\indexlibrary{\idxcode{is_bounded}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{is_bounded}}
\begin{itemdecl}
static const bool is_bounded;
\end{itemdecl}

\begin{itemdescr}
\pnum
True if the set of values representable by the type is finite.\footnote{Required by LIA-1.}
All built-in types are bounded, this member would be false for arbitrary
precision types.

\pnum
Meaningful for all specializations.
\end{itemdescr}

\indexlibrary{\idxcode{is_modulo}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{is_modulo}}
\begin{itemdecl}
static const bool is_modulo;
\end{itemdecl}

\begin{itemdescr}
\pnum
True if the type is modulo.\footnote{Required by LIA-1.}
A type is modulo if it is possible to add two positive numbers and have a
result that wraps around to a third number that is less.

\pnum
Generally, this is
\tcode{false}
for floating types,
\tcode{true}
for unsigned integers, and
\tcode{true}
for signed integers on most machines.

\pnum
Meaningful for all specializations.
\end{itemdescr}

\indexlibrary{\idxcode{traps}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{traps}}
\begin{itemdecl}
static const bool traps;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{true}
if trapping is implemented for the type.\footnote{Required by LIA-1.}

\pnum
Meaningful for all specializations.
\end{itemdescr}

\indexlibrary{\idxcode{tinyness_before}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{tinyness_before}}
\begin{itemdecl}
static const bool tinyness_before;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{true}
if tinyness is detected before rounding.\footnote{Refer to IEC 559.
Required by LIA-1.}

\pnum
Meaningful for all floating point types.
\end{itemdescr}

\indexlibrary{\idxcode{round_style}!\idxcode{numeric_limits}}
\indexlibrary{\idxcode{numeric_limits}!\idxcode{round_style}}
\begin{itemdecl}
static const float_round_style round_style;
\end{itemdecl}

\begin{itemdescr}
\pnum
The rounding style for the type.\footnote{Equivalent to \tcode{FLT_ROUNDS}.
Required by LIA-1.}

\pnum
Meaningful for all floating point types.
Specializations for integer types shall return
\tcode{round_toward_zero}.
\end{itemdescr}

\rSec3[lib.round.style]{Type \tcode{float_round_style}}

\indexlibrary{\idxcode{float_round_style}}%
\begin{codeblock}
namespace std {
  enum float_round_style {
    round_indeterminate       = -1,
    round_toward_zero         =  0,
    round_to_nearest          =  1,
    round_toward_infinity     =  2,
    round_toward_neg_infinity =  3
  };
}
\end{codeblock}

\pnum
The rounding mode for floating point arithmetic is characterized by the
values:

\begin{itemize}
\item
\indexlibrary{\idxcode{round_indeterminate}}%
\tcode{round_indeterminate}
if the rounding style is indeterminable
\item
\indexlibrary{\idxcode{round_toward_zero}}%
\tcode{round_toward_zero}
if the rounding style is toward zero
\item
\indexlibrary{\idxcode{round_to_nearest}}%
\tcode{round_to_nearest}
if the rounding style is to the nearest representable value
\item
\indexlibrary{\idxcode{round_toward_infinity}}%
\tcode{round_toward_infinity}
if the rounding style is toward infinity
\item
\indexlibrary{\idxcode{round_toward_neg_infinity}}%
\tcode{round_toward_neg_infinity}
if the rounding style is toward negative infinity
\end{itemize}

\rSec3[lib.denorm.style]{Type \tcode{float_denorm_style}}

\indexlibrary{\idxcode{float_denorm_style}}%
\begin{codeblock}
namespace std {
  enum float_denorm_style {
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
  };
}
\end{codeblock}

\pnum
The presence or absence of denormalization (variable number of exponent bits)
is characterized by the values:

\begin{itemize}
\item
\indexlibrary{\idxcode{denorm_indeterminate}}%
\tcode{denorm_indeterminate}
if it cannot be determined whether or not the type allows denormalized values
\item
\indexlibrary{\idxcode{denorm_absent}}%
\tcode{denorm_absent}
if the type does not allow denormalized values
\item
\indexlibrary{\idxcode{denorm_present}}%
\tcode{denorm_present}
if the type does allow denormalized values
\end{itemize}

\rSec3[lib.numeric.special]{\tcode{numeric_limits} specializations}

\pnum
All members shall be provided for all specializations.
However, many values are only required to be meaningful under certain
conditions
(for example,
\tcode{epsilon()}
is only meaningful if
\tcode{is_integer}
is
\tcode{false}).
Any value that is not ``meaningful'' shall be set to 0 or
\tcode{false}.

\pnum
\enterexample
\begin{codeblock}
namespace std {
  template<> class numeric_limits<float> {
  public:
    static const bool is_specialized = true;

    inline static float min() throw() { return 1.17549435E-38F; }
    inline static float max() throw() { return 3.40282347E+38F; }

    static const int digits   = 24;
    static const int digits10 =  6;

    static const bool is_signed  = true;
    static const bool is_integer = false;
    static const bool is_exact   = false;

    static const int radix = 2;
    inline static float epsilon() throw()     { return 1.19209290E-07F; }
    inline static float round_error() throw() { return 0.5F; }

    static const int min_exponent   = -125;
    static const int min_exponent10 = - 37;
    static const int max_exponent   = +128;
    static const int max_exponent10 = + 38;

    static const bool has_infinity             = true;
    static const bool has_quiet_NaN            = true;
    static const bool has_signaling_NaN        = true;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss          = false;

    inline static float infinity()      throw() { return ...; }
    inline static float quiet_NaN()     throw() { return ...; }
    inline static float signaling_NaN() throw() { return ...; }
    inline static float denorm_min()    throw() { return min(); }

    static const bool is_iec559  = true;
    static const bool is_bounded = true;
    static const bool is_modulo  = false;
    static const bool traps      = true;
    static const bool tinyness_before = true;

    static const float_round_style round_style = round_to_nearest;
  };
}
\end{codeblock}
\exitexampleb

\rSec2[lib.c.limits]{C Library}

\pnum
Header \tcode{<climits>} Table~\ref{tab:support.hdr.climits}:

\indexlibrary{\idxcode{CHAR_BIT}}%
\indexlibrary{\idxcode{INT_MAX}}%
\indexlibrary{\idxcode{LONG_MIN}}%
\indexlibrary{\idxcode{SCHAR_MIN}}%
\indexlibrary{\idxcode{SHRT_MIN}}%
\indexlibrary{\idxcode{CHAR_MAX}}%
\indexlibrary{\idxcode{LONG_MAX}}%
\indexlibrary{\idxcode{SCHAR_MAX}}%
\indexlibrary{\idxcode{UCHAR_MAX}}%
\indexlibrary{\idxcode{CHAR_MAX}}%
\indexlibrary{\idxcode{MB_LEN_MAX}}%
\indexlibrary{\idxcode{SHRT_MAX}}%
\indexlibrary{\idxcode{UINT_MAX}}%
\indexlibrary{\idxcode{USHRT_MAX}}%
\indexlibrary{\idxcode{INT_MIN}}%
\indexlibrary{\idxcode{ULONG_MAX}}%
\begin{libsyntab6}{climits}{tab:support.hdr.climits}
\cspan{\values}     \\

\tcode{CHAR_BIT}    &
\tcode{INT_MAX}     &
\tcode{LONG_MIN}    &
\tcode{SCHAR_MIN}   &
\tcode{UCHAR_MAX}   &
\tcode{USHRT_MAX}   \\

\tcode{CHAR_MAX}    &
\tcode{INT_MIN}     &
\tcode{MB_LEN_MAX}  &
\tcode{SHRT_MAX}    &
\tcode{UINT_MAX}    & \\

\tcode{CHAR_MIN}    &
\tcode{LONG_MAX}    &
\tcode{SCHAR_MAX}   &
\tcode{SHRT_MIN}    &
\tcode{UINT_MAX}    & \\

\end{libsyntab6}

\pnum
The contents are the same as the Standard C library header
\tcode{<limits.h>}.

\pnum
Header \tcode{<cfloat>} (Table~\ref{tab:support.hdr.cfloat}):

\indexlibrary{\idxcode{DBL_DIG}}%
\indexlibrary{\idxcode{DBL_MIN_EXP}}%
\indexlibrary{\idxcode{FLT_MAX_EXP}}%
\indexlibrary{\idxcode{LDBL_MANT_DIG}}%
\indexlibrary{\idxcode{DBL_EPSILON}}%
\indexlibrary{\idxcode{FLT_MIN}}%
\indexlibrary{\idxcode{LDBL_MAX_10_EXP}}%
\indexlibrary{\idxcode{DBL_MANT_DIG}}%
\indexlibrary{\idxcode{FLT_DIG}}%
\indexlibrary{\idxcode{FLT_MIN_10_EXP}}%
\indexlibrary{\idxcode{LDBL_MAX_EXP}}%
\indexlibrary{\idxcode{DBL_MAX}}%
\indexlibrary{\idxcode{FLT_EPSILON}}%
\indexlibrary{\idxcode{FLT_MIN_EXP}}%
\indexlibrary{\idxcode{LDBL_MAX}}%
\indexlibrary{\idxcode{DBL_MAX_10_EXP}}%
\indexlibrary{\idxcode{FLT_RADIX}}%
\indexlibrary{\idxcode{LDBL_MIN}}%
\indexlibrary{\idxcode{DBL_MAX_EXP}}%
\indexlibrary{\idxcode{FLT_MANT_DIG}}%
\indexlibrary{\idxcode{FLT_ROUNDS}}%
\indexlibrary{\idxcode{LDBL_MIN_10_EXP}}%
\indexlibrary{\idxcode{DBL_MIN}}%
\indexlibrary{\idxcode{FLT_MAX}}%
\indexlibrary{\idxcode{LDBL_DIG}}%
\indexlibrary{\idxcode{LDBL_MIN_EXP}}%
\indexlibrary{\idxcode{DBL_MIN_10_EXP}}%
\indexlibrary{\idxcode{FLT_MAX_10_EXP}}%
\indexlibrary{\idxcode{LDBL_EPSILON}}%
\begin{libsyntab4}{cfloat}{tab:support.hdr.cfloat}
\cspan{\values}         \\

\tcode{DBL_DIG}         &
\tcode{DBL_MIN_EXP}     &
\tcode{FLT_MIN_10_EXP}  &
\tcode{LDBL_MAX_10_EXP}\\

\tcode{DBL_EPSILON}     &
\tcode{FLT_DIG}         &
\tcode{FLT_MIN_EXP}     &
\tcode{LDBL_MAX_EXP}    \\

\tcode{DBL_MANT_DIG}    &
\tcode{FLT_EPSILON}     &
\tcode{FLT_RADIX}       &
\tcode{LDBL_MIN}        \\

\tcode{DBL_MAX} &
\tcode{FLT_MANT_DIG}    &
\tcode{FLT_ROUNDS}      &
\tcode{LDBL_MIN_10_EXP} \\

\tcode{DBL_MAX_10_EXP}  &
\tcode{FLT_MAX}         &
\tcode{LDBL_DIG}        &
\tcode{LDBL_MIN_EXP}    \\

\tcode{DBL_MAX_EXP}     &
\tcode{FLT_MAX_10_EXP}  &
\tcode{LDBL_EPSILON}    &   \\

\tcode{DBL_MIN}         &
\tcode{FLT_MAX_EXP}     &
\tcode{LDBL_MANT_DIG}   &   \\

\tcode{DBL_MIN_10_EXP}  &
\tcode{FLT_MIN}         &
\tcode{LDBL_MAX}        &   \\

\end{libsyntab4}

\pnum
The contents are the same as the Standard C library header
\tcode{<float.h>}.

\xref ISO C~7.1.5, 5.2.4.2.2, 5.2.4.2.1.

\rSec1[lib.support.start.term]{Start and termination}

\pnum
Header \tcode{<cstdlib>} (partial),
Table~\ref{tab:support.hdr.cstdlib}:

\indexlibrary{\idxcode{EXIT_FAILURE}}%
\indexlibrary{\idxcode{EXIT_SUCCESS}}%
\indexlibrary{\idxcode{abort}}%
\indexlibrary{\idxcode{atexit}}%
\indexlibrary{\idxcode{exit}}%
\begin{libsyntab4}{cstdlib}{tab:support.hdr.cstdlib}
\macros     &   \tcode{EXIT_FAILURE}    & &   \tcode{EXIT_SUCCESS}    \\ \rowsep
\functions
&   \tcode{abort}
&   \tcode{atexit}
&   \tcode{exit}    \\
\end{libsyntab4}

\pnum
The contents are the same as the Standard C library header
\tcode{<stdlib.h>},
with the following changes:

\indexlibrary{\idxcode{abort}}%
\begin{itemdecl}
abort(void)
\end{itemdecl}

\begin{itemdescr}
\pnum
The function
\tcode{abort()}
has additional behavior in this International Standard:

\begin{itemize}
\item
The program is terminated without executing destructors for objects of
automatic or static storage
duration and without calling functions passed to
\tcode{atexit()}~(\ref{basic.start.term}).
%
\indexlibrary{\idxcode{atexit}}%
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{atexit}}
\begin{itemdecl}
extern "C" int atexit(void (*f)(void))
extern "C++" int atexit(void (*f)(void))
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The
\tcode{atexit()}
functions register the function pointed to by \tcode{f},
to be called without arguments at normal program termination.

\pnum
For the execution of a function registered with \tcode{atexit()}, if control
leaves the function because it provides no handler for a thrown exception,
\tcode{terminate()} is called~(\ref{lib.terminate}).

\pnum
\implimits
The implementation shall support the registration of at least 32 functions.

\pnum
\returns
The
\tcode{atexit()}
function returns zero if the registration succeeds,
nozero if it fails.
\end{itemdescr}

\indexlibrary{\idxcode{exit}}%
\begin{itemdecl}
exit(int status)
\end{itemdecl}

\begin{itemdescr}
\pnum
The function
\tcode{exit()}
has additional behavior in this International Standard:

\begin{itemize}
\item
First, objects with static storage duration are destroyed
and functions registered by calling
\tcode{atexit}
are called.
Non-local objects with static storage duration are destroyed in the
reverse order of the completion of their constructor.
(Automatic objects are not destroyed as a result of calling
\tcode{exit()}.)\footnote{Objects with automatic storage duration are all destroyed in a program whose
function
\tcode{main()}
contains no automatic objects and executes the call to
\tcode{exit()}.
Control can be transferred directly to such a
\tcode{main()}
by throwing an exception that is caught in
\tcode{main()}.}
Functions registered with \tcode{atexit} are called in the reverse order of
their registration, except that a function is called after any previously
registered functions that had already been called at the time it was
registered.\footnote{A function is called for every time it is registered.}
A function registered with \tcode{atexit} before a non-local object \tcode{obj1}
of static storage duration is initialized will not be called until
\tcode{obj1}'s destruction has completed. A function registered with
\tcode{atexit} after a non-local object \tcode{obj2} of static storage
duration is initialized will be called before \tcode{obj2}'s destruction
starts. A local static object \tcode{obj3} is destroyed at the same time it
would be if a function calling the \tcode{obj3} destructor were registered
with \tcode{atexit} at the completion of the \tcode{obj3} constructor.

\item
Next, all open C streams (as mediated by the function
signatures declared in
\tcode{<cstdio>})
with unwritten buffered data are flushed, all open C
streams are closed, and all files created by calling
\tcode{tmpfile()}
are removed.\footnote{Any C streams associated with \tcode{cin}, \tcode{cout},
etc~(\ref{lib.iostream.objects}) are flushed and closed when static objects are destroyed in the
previous phase. The function \tcode{tmpfile()} is declared in
\tcode{<cstdio>}.}

\item
Finally, control is returned to the host environment.
If \tcode{status} is zero or
\tcode{EXIT_SUCCESS},
an \\\impldef{exit status}
form of the status
\term{successful termination}
is returned.
\indextext{implementation-defined}%
If \tcode{status} is
\tcode{EXIT_FAILURE},
an \impldef{exit status} form of the status
\term{unsuccessful termination}
is returned.
\indextext{implementation-defined}%
Otherwise the status returned is \impldef{exit status}.%
\indextext{implementation-defined}\footnote{The macros
\tcode{EXIT_FAILURE}
and
\tcode{EXIT_SUCCESS}
are defined in
\tcode{<cstdlib>}.}
\end{itemize}

\end{itemdescr}

\pnum
The function \tcode{exit()} never returns to its caller.

\xref subclauses~\ref{basic.start}, \ref{basic.start.term},
ISO C subclause~7.10.4.

\rSec1[lib.support.dynamic]{Dynamic memory management}

\pnum
The header
\tcode{<new>}
defines several
functions that manage the allocation of dynamic storage in a program.
It also defines components for reporting storage management errors.

\synopsis{Header \tcode{<new>} synopsis}
\indextext{\idxhdr{new}}%
\indexlibrary{\idxhdr{new}}%

\begin{codeblock}
namespace std {
  class bad_alloc;
  struct nothrow_t {};
  extern const nothrow_t nothrow;
  typedef void (*new_handler)();
  new_handler set_new_handler(new_handler new_p) throw();
}

  void* operator new(std::size_t size) throw(std::bad_alloc);
  void* operator new(std::size_t size, const std::nothrow_t&) throw();
  void  operator delete(void* ptr) throw();
  void  operator delete(void* ptr, const std::nothrow_t&) throw();
  void* operator new[](std::size_t size) throw(std::bad_alloc);
  void* operator new[](std::size_t size, const std::nothrow_t&) throw();
  void  operator delete[](void* ptr) throw();
  void  operator delete[](void* ptr, const std::nothrow_t&) throw();

  void* operator new  (std::size_t size, void* ptr) throw();
  void* operator new[](std::size_t size, void* ptr) throw();
  void  operator delete  (void* ptr, void*) throw();
  void  operator delete[](void* ptr, void*) throw();
\end{codeblock}

\xref~\ref{intro.memory}, \ref{basic.stc.dynamic},
\ref{expr.new}, \ref{expr.delete}, \ref{class.free},
\ref{lib.memory}.

\rSec2[lib.new.delete]{Storage allocation and deallocation}

\pnum
Except where otherwise specified, the provisions of~(\ref{basic.stc.dynamic})
apply to the library versions of \tcode{operator new} and \tcode{operator
delete}.

\rSec3[lib.new.delete.single]{Single-object forms}

\indexlibrary{\idxcode{new}!\tcode{operator}}%
\begin{itemdecl}
void* operator new(std::size_t size) throw(std::bad_alloc);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The
\term{allocation function}~(\ref{basic.stc.dynamic.allocation})
called by a
\grammarterm{new-expression}~(\ref{expr.new})
to allocate
\tcode{size} bytes of storage suitably aligned to represent any object
of that size.

\pnum
\replaceable
a \Cpp program may define a function with this function signature
that displaces the default version defined by the
\Cpp Standard library.

\pnum
\required 
Return a non-null pointer to suitably aligned storage~(\ref{basic.stc.dynamic}),
or else throw a
\tcode{bad_alloc}
\indexlibrary{\idxcode{bad_alloc}}%
exception.
This requirement is binding on a replacement version of this function.

\pnum
\default

\begin{itemize}
\item
Executes a loop:
Within the loop, the function first attempts to allocate the requested storage.
Whether the attempt involves a call to the Standard C library function
\tcode{malloc}
is unspecified.
\indextext{unspecified}%
\item
Returns a pointer to the allocated storage if the attempt is successful.
Otherwise, if the last argument to
\tcode{set_new_handler()}
was a null pointer, throw
\tcode{bad_alloc}.
\item
Otherwise, the function calls the current
\term{new_handler}~(\ref{lib.new.handler}).
If the called function returns, the loop repeats.
\item
The loop terminates when an attempt to allocate the requested storage is
successful or when a called
\term{new_handler}
function does not return.
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{new}!\idxcode{operator}}%
\begin{itemdecl}
void* operator new(std::size_t size, const std::nothrow_t&) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Same as above, except that it is called by a placement version of a
\grammarterm{new-expression}
when a \Cpp program prefers a null pointer result as an error indication,
instead of a
\tcode{bad_alloc}
exception.

\pnum
\replaceable
a \Cpp program may define a function with this function signature
that displaces the default version defined by the
\Cpp Standard library.

\pnum
\required
Return a non-null pointer to suitably aligned storage~(\ref{basic.stc.dynamic}),
or else return a null pointer.
This nothrow version of
\tcode{operator new}
returns a pointer obtained as if acquired from the ordinary version.
This requirement is binding on a replacement version of this function.

\pnum
\default

\begin{itemize}
\item
Executes a loop:
Within the loop, the function first attempts to allocate the requested storage.
Whether the attempt involves a call to the Standard C library function
\tcode{malloc}
is unspecified.
\indextext{unspecified}%
\item
Returns a pointer to the allocated storage if the attempt is successful.
Otherwise, if the last argument to
\tcode{set_new_handler()}
was a null pointer, return a null pointer.
\item
Otherwise, the function calls the current
\term{new_handler}~(\ref{lib.new.handler}).
If the called function returns, the loop repeats.
\item
The loop terminates when an attempt to allocate the requested storage is
successful or when a called
\term{new_handler}
function does not return.
If the called \term{new_handler} function terminates by throwing a
\tcode{bad_alloc}
exception, the function returns a null pointer.
\end{itemize}

\pnum
\enterexample
\begin{codeblock}
T* p1 = new T;                  // throws \tcode{bad_alloc} if it fails
T* p2 = new(nothrow) T;         // returns \tcode{0} if it fails
\end{codeblock}
\exitexampleb
\end{itemdescr}

\indexlibrary{\idxcode{delete}!\idxcode{operator}}%
\begin{itemdecl}
void operator delete(void* ptr) throw();
void operator delete(void* ptr, const std::nothrow_t&) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The
\term{deallocation function}~(\ref{basic.stc.dynamic.deallocation})
called by a \grammarterm{delete-expression}
to render the value of \tcode{ptr} invalid.

\pnum
\replaceable
a \Cpp program may define a function with this
function signature that displaces the default version defined by the
\Cpp Standard library.

\pnum
\required
accept a value of \tcode{ptr} that is null or that was returned by an earlier
call to the default
\tcode{operator new(std::size_t)}
or
\tcode{operator new(std::size_t,const std::nothrow_t\&)}.

\pnum
\default

\begin{itemize}
\item For a null value of \tcode{ptr}, do nothing.
\item Any other value of \tcode{ptr} shall be a value returned earlier by a
call to the default \tcode{operator new}, which was not invalidated by an
intervening call to \tcode{operator delete(void*)}~(\ref{lib.res.on.arguments}).
For such a non-null value of \tcode{ptr}, reclaims storage allocated by the
earlier call to the default \tcode{operator new}.
\end{itemize}

\pnum
\notes
It is unspecified under what conditions part or all of such
\indextext{unspecified}%
reclaimed storage is allocated by a subsequent
call to
\tcode{operator new}
or any of
\tcode{calloc},
\tcode{malloc},
or
\tcode{realloc},
declared in
\tcode{<cstdlib>}.
\end{itemdescr}

\rSec3[lib.new.delete.array]{Array forms}

\indexlibrary{\idxcode{new}!\idxcode{operator}}%
\begin{itemdecl}
void* operator new[](std::size_t size) throw(std::bad_alloc);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The
\term{allocation function}~(\ref{basic.stc.dynamic.allocation})
called by the array form of a
\grammarterm{new-expression}~(\ref{expr.new})
to allocate \tcode{size} bytes of storage suitably aligned to represent any array
object of that size or smaller.\footnote{It is not the direct responsibility of
\tcode{operator new[](std::size_t)}
or
\tcode{operator delete[](void*)}
to note the repetition count or element size of the array.
Those operations are performed elsewhere in the array
\tcode{new}
and
\tcode{delete}
expressions.
The array
\tcode{new}
expression, may, however, increase the \tcode{size} argument to
\tcode{operator new[](std::size_t)}
to obtain space to store supplemental information.}

\pnum
\replaceable
a \Cpp program can define a
function with this function signature that displaces the default version
defined by the \Cpp Standard library.

\pnum
\required
Same as for
\tcode{operator new(std::size_t)}.
This requirement is binding on a replacement version of this function.

\pnum
\default
Returns
\tcode{operator new(size)}.
\end{itemdescr}

\indexlibrary{\idxcode{new}!\idxcode{operator}}%
\begin{itemdecl}
void* operator new[](std::size_t size, const std::nothrow_t&) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Same as above, except that it is called by a placement version of a
\grammarterm{new-expression}
when a \Cpp program prefers a null pointer result as an error indication,
instead of a
\tcode{bad_alloc}
exception.

\pnum
\replaceable
a \Cpp program can define a
function with this function signature that displaces the default version
defined by the \Cpp Standard library.

\pnum
\required
Same as for \tcode{operator new(std::size_t,const std::nothrow_t\&)}.
This nothrow version of \tcode{operator new[]} returns a pointer obtained
as if acquired from the ordinary version.

\pnum
\default
Returns \tcode{operator new(size,nothrow)}.
\end{itemdescr}

\indexlibrary{\idxcode{delete}!\idxcode{operator}}%
\begin{itemdecl}
void operator delete[](void* ptr) throw();
void operator delete[](void* ptr, const std::nothrow_t&) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The
\term{deallocation function}~(\ref{basic.stc.dynamic.deallocation})
called by the array form of a
\grammarterm{delete-expression}
to render the value of \tcode{ptr} invalid.

\pnum
\replaceable
a \Cpp program can define a function with this
function signature that displaces the default version defined by the
\Cpp Standard library.

\pnum
\required
accept a value of \tcode{ptr} that is null or that was returned by an earlier
call to
\tcode{operator new[](std::size_t)}
or
\tcode{operator new[](std::size_t,const std::nothrow_t\&)}.

\pnum
\default
\begin{itemize}
\item For a null value of \tcode{ptr}, does nothing.
\item Any other value of \tcode{ptr} shall be a value returned earlier by a
call to the default \tcode{operator new[](\brk{}std::size_t)}.\footnote{The value
must not have been invalidated by an intervening call to
\tcode{operator delete[](void*)}~(\ref{lib.res.on.arguments}).}
For such a non-null value of \tcode{ptr}, reclaims storage allocated by the
earlier call to the default \tcode{operator new[]}.
\end{itemize}

\pnum
It is unspecified under what conditions part or all of such reclaimed
storage is allocated by a subsequent call to
\tcode{operator new}
or any of
\tcode{calloc},
\tcode{malloc}, or
\tcode{realloc},
declared in
\tcode{<cstdlib>}.
\end{itemdescr}

\rSec3[lib.new.delete.placement]{Placement forms}

\pnum
These functions are reserved, a \Cpp program may not define functions that displace
the versions in the Standard \Cpp library~(\ref{lib.constraints}).
The provisions of~(\ref{basic.stc.dynamic}) do not apply to these reserved
placement forms of \tcode{operator new} and \tcode{operator delete}.

\indexlibrary{\idxcode{new}!\idxcode{operator}}%
\begin{itemdecl}
void* operator new(std::size_t size, void* ptr) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{ptr}.

\pnum
\notes
Intentionally performs no other action.

\pnum
\enterexample
This can be useful for constructing an object at a known address:

\begin{codeblock}
void* place = operator new(sizeof(Something));
Something* p = new (place) Something();
\end{codeblock}
\exitexampleb
\end{itemdescr}

\indexlibrary{\idxcode{new}!\idxcode{operator}}%
\begin{itemdecl}
void* operator new[](std::size_t size, void* ptr) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{ptr}.

\pnum
\notes
Intentionally performs no other action.
\end{itemdescr}

\indexlibrary{\idxcode{new}!\tcode{operator}}%
\begin{itemdecl}
void operator delete(void* ptr, void*) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Intentionally performs no action.

\pnum
\notes
Default function called when any part of the initialization in a
placement new expression that invokes the library's
non-array placement operator new
terminates by throwing an exception~(\ref{expr.new}).
\end{itemdescr}

\indexlibrary{\idxcode{new}!\idxcode{operator}}%
\begin{itemdecl}
void operator delete[](void* ptr, void*) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Intentionally performs no action.

\pnum
\notes
Default function called when any part of the initialization in a
placement new expression that invokes the library's
array placement operator new
terminates by throwing an exception~(\ref{expr.new}).
\end{itemdescr}

\rSec2[lib.alloc.errors]{Storage allocation errors}

\indexlibrary{\idxcode{bad_alloc}}%
\rSec3[lib.bad.alloc]{Class \tcode{bad_alloc}}

\begin{codeblock}
namespace std {
  class bad_alloc : public exception {
  public:
    bad_alloc() throw();
    bad_alloc(const bad_alloc&) throw();
    bad_alloc& operator=(const bad_alloc&) throw();
    virtual ~bad_alloc() throw();
    virtual const char* what() const throw();
  };
}
\end{codeblock}

\pnum
The class
\tcode{bad_alloc}
defines the type of objects thrown as
exceptions by the implementation to report a failure to allocate storage.

\indexlibrary{\idxcode{bad_alloc}!\idxcode{bad_alloc}}%
\begin{itemdecl}
bad_alloc() throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{bad_alloc}.

\pnum
\notes
The result of calling
\tcode{what()}
on the newly constructed object is implementation-defined.
\end{itemdescr}

\indextext{implementation-defined}%
\indexlibrary{\idxcode{bad_alloc}!\idxcode{bad_alloc}}%
\indexlibrary{\idxcode{operator=}!\tcode{bad_alloc}}%
\begin{itemdecl}
    bad_alloc(const bad_alloc&) throw();
    bad_alloc& operator=(const bad_alloc&) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Copies an object of class
\tcode{bad_alloc}.
\end{itemdescr}

\indexlibrary{\idxcode{what}!\tcode{bad_alloc}}%
\begin{itemdecl}
virtual const char* what() const throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\indexlibrary{\idxcode{bad_alloc}!\idxcode{bad_alloc::what}!implementation-defined}%
An \impldef{return value of \tcode{bad_alloc::what}} \ntbs.
\end{itemdescr}

\rSec3[lib.new.handler]{Type \tcode{new_handler}}

\indexlibrary{\idxcode{new_handler}}%
\begin{itemdecl}
typedef void (*new_handler)();
\end{itemdecl}

\begin{itemdescr}
\pnum
The type of a
\term{handler function}
to be called by
\tcode{operator new()}
or
\tcode{operator new[]()}~(\ref{lib.new.delete}) when they cannot satisfy a request for additional storage.

\pnum
\required
A \tcode{new_handler} shall perform one of the following:

\begin{itemize}
\item
make more storage available for allocation and then return;
\item
throw an exception of type
\tcode{bad_alloc}
or a class derived from
\indexlibrary{\idxcode{bad_alloc}}%
\tcode{bad_alloc};
\item
call either
\indexlibrary{\idxcode{abort}}%
\tcode{abort()} or
\indexlibrary{\idxcode{exit}}%
\tcode{exit()};
\end{itemize}
\end{itemdescr}

\rSec3[lib.set.new.handler]{\tcode{set_new_handler}}

\indexlibrary{\idxcode{set_new_handler}}%
\begin{itemdecl}
new_handler set_new_handler(new_handler new_p) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Establishes the function designated by \tcode{new_p} as the current
\tcode{new_handler}.

\pnum
\returns
0 on the first call, the previous \tcode{new_handler} on subsequent calls.
\end{itemdescr}

\rSec1[lib.support.rtti]{Type identification}

\pnum
The header
\tcode{<typeinfo>}
defines a
type associated with type information generated by the implementation.
It also defines two types for reporting dynamic type identification errors.

\indextext{\idxhdr{typeinfo}}%
\indexlibrary{\idxhdr{typeinfo}}%
\synopsis{Header \tcode{<typeinfo>} synopsis}

\indexlibrary{\idxcode{type_info}}%
\indexlibrary{\idxcode{bad_cast}}%
\indexlibrary{\idxcode{bad_typeid}}%
\begin{codeblock}
namespace std {
  class type_info;
  class bad_cast;
  class bad_typeid;
}
\end{codeblock}

\xref~\ref{expr.dynamic.cast}, \ref{expr.typeid}.

\rSec2[lib.type.info]{Class \tcode{type_info}}

\indexlibrary{\idxcode{type_info}}%
\begin{codeblock}
namespace std {
  class type_info {
  public:
    virtual ~type_info();
    bool operator==(const type_info& rhs) const;
    bool operator!=(const type_info& rhs) const;
    bool before(const type_info& rhs) const;
    const char* name() const;
  private:
    type_info(const type_info& rhs);
    type_info& operator=(const type_info& rhs);
  };
}
\end{codeblock}

\pnum
The class
\tcode{type_info}
describes type information generated by the implementation.
Objects of this class effectively store a pointer to a name for the type, and
an encoded value suitable for comparing two types for equality or collating order.
The names, encoding rule, and collating sequence for types are all unspecified
\indextext{unspecified}%
and may differ between programs.

\indexlibrary{\idxcode{operator==}!\tcode{type_info}}%
\begin{itemdecl}
bool operator==(const type_info& rhs) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Compares the current object with \tcode{rhs}.

\pnum
\returns
\tcode{true}
if the two values describe the same type.
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\tcode{type_info}}%
\begin{itemdecl}
bool operator!=(const type_info& rhs) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{!(*this == rhs)}.
\end{itemdescr}

\indexlibrary{\idxcode{before}!\tcode{type_info}}%
\begin{itemdecl}
bool before(const type_info& rhs) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Compares the current object with \tcode{rhs}.

\pnum
\returns
\tcode{true}
if
\tcode{*this}
precedes \tcode{rhs} in the implementation's collation order.
\end{itemdescr}

\indexlibrary{\idxcode{name}!\tcode{type_info}}%
\begin{itemdecl}
const char* name() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An \impldef{return value of \tcode{type_info::name()}} \ntbs.
\indexlibrary{\idxcode{type_info::name}!implementation-defined}

\pnum
\notes
The message may be a null-terminated multibyte string~(\ref{lib.multibyte.strings}),
suitable for conversion and display as a
\tcode{wstring}~(\ref{lib.string.classes}, \ref{lib.locale.codecvt})
\end{itemdescr}

\begin{itemdecl}
type_info(const type_info& rhs);
type_info& operator=(const type_info& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Copies a \tcode{type_info} object.

\pnum
\notes
Since the copy constructor and assignment operator for
\tcode{type_info} are private to the class, objects of this
type cannot be copied.
\end{itemdescr}

\rSec2[lib.bad.cast]{Class \tcode{bad_cast}}

\indexlibrary{\idxcode{bad_cast}}%
\begin{codeblock}
namespace std {
  class bad_cast : public exception {
  public:
    bad_cast() throw();
    bad_cast(const bad_cast&) throw();
    bad_cast& operator=(const bad_cast&) throw();
    virtual ~bad_cast() throw();
    virtual const char* what() const throw();
  };
}
\end{codeblock}

\pnum
The class
\tcode{bad_cast}
defines the type of objects thrown
as exceptions by the implementation to report the execution of an invalid
\grammarterm{dynamic-cast}
expression~(\ref{expr.dynamic.cast}).

\indextext{cast!dynamic}%
\indexlibrary{\idxcode{bad_cast}!\tcode{bad_cast}}%
\begin{itemdecl}
bad_cast() throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{bad_cast}.

\pnum
\notes
The result of calling
\tcode{what()}
on the newly constructed object is implementation-defined.%
\indextext{implementation-defined}
\end{itemdescr}

\indexlibrary{\idxcode{bad_cast}!\tcode{bad_cast}}%
\indexlibrary{\idxcode{operator=}!\tcode{bad_cast}}%
\begin{itemdecl}
    bad_cast(const bad_cast&) throw();
    bad_cast& operator=(const bad_cast&) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Copies an object of class
\tcode{bad_cast}.
\end{itemdescr}

\indexlibrary{\idxcode{what}!\tcode{bad_cast}}%
\begin{itemdecl}
virtual const char* what() const throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An \impldef{return value of \tcode{bad_cast::what}} \ntbs.%
\indexlibrary{\idxcode{bad_cast::what}!implementation-defined}

\pnum
\notes
The message may be a null-terminated multibyte string~(\ref{lib.multibyte.strings}),
suitable for conversion and display as a
\tcode{wstring}~(\ref{lib.string.classes}, \ref{lib.locale.codecvt})
\end{itemdescr}

\rSec2[lib.bad.typeid]{Class \tcode{bad_typeid}}

\indexlibrary{\idxcode{bad_typeid}}%
\begin{codeblock}
namespace std {
  class bad_typeid : public exception {
  public:
    bad_typeid() throw();
    bad_typeid(const bad_typeid&) throw();
    bad_typeid& operator=(const bad_typeid&) throw();
    virtual ~bad_typeid() throw();
    virtual const char* what() const throw();
  };
}
\end{codeblock}

\pnum
The class
\tcode{bad_typeid}
defines the type of objects
thrown as exceptions by the implementation to report a null pointer
in a
\grammarterm{typeid}
expression~(\ref{expr.typeid}).

\indexlibrary{\idxcode{bad_typeid}!\tcode{bad_typeid}}%
\begin{itemdecl}
bad_typeid() throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{bad_typeid}.

\pnum
\notes
The result of calling
\tcode{what()}
on the newly constructed object is implementation-defined.%
\indextext{implementation-defined}
\end{itemdescr}

\indexlibrary{\idxcode{bad_typeid}!\tcode{bad_typeid}}%
\indexlibrary{\idxcode{operator=}!\tcode{bad_typeid}}%
\begin{itemdecl}
    bad_typeid(const bad_typeid&) throw();
    bad_typeid& operator=(const bad_typeid&) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Copies an object of class
\tcode{bad_typeid}.
\end{itemdescr}

\indexlibrary{\idxcode{what}!\tcode{bad_typeid}}%
\begin{itemdecl}
virtual const char* what() const throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An \impldef{return value of \tcode{bad_typeid::what}} \ntbs.%
\indextext{\idxcode{bad_typeid::what}!implementation-defined}

\pnum
\notes
The message may be a null-terminated multibyte string~(\ref{lib.multibyte.strings}),
suitable for conversion and display as a
\tcode{wstring}~(\ref{lib.string.classes}, \ref{lib.locale.codecvt})
\end{itemdescr}

\rSec1[lib.support.exception]{Exception handling}

\pnum
The header
\tcode{<exception>}
defines several types and functions related to the handling of exceptions in a \Cpp program.

\synopsis{Header \tcode{<exception>} synopsis}

\indextext{\idxhdr{exception}}%
\indexlibrary{\idxhdr{exception}}%
\begin{codeblock}
namespace std {
  class exception;
  class bad_exception;

  typedef void (*unexpected_handler)();
  unexpected_handler set_unexpected(unexpected_handler f) throw();
  void unexpected();

  typedef void (*terminate_handler)();
  terminate_handler set_terminate(terminate_handler f) throw();
  void terminate();

  bool uncaught_exception() throw();
}
\end{codeblock}

\xref~\ref{except.special}.

\rSec2[lib.exception]{Class \tcode{exception}}

\indexlibrary{\idxcode{exception}}%
\begin{codeblock}
namespace std {
  class exception {
  public:
    exception() throw();
    exception(const exception&) throw();
    exception& operator=(const exception&) throw();
    virtual ~exception() throw();
    virtual const char* what() const throw();
  };
}
\end{codeblock}

\pnum
The class
\tcode{exception}
defines the base
class for the types of objects thrown as exceptions by
\Cpp Standard library components, and certain
expressions, to report errors detected during program execution.

\indexlibrary{\idxcode{exception}!constructor}%
\begin{itemdecl}
exception() throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{exception}.

\pnum
\notes
Does not throw any exceptions.
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{exception}}%
\begin{itemdecl}
exception(const exception&) throw();
exception& operator=(const exception&) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Copies an
\tcode{exception}
object.

\pnum
\notes
The effects of calling \tcode{what()} after assignment are
implementation-defined.
\end{itemdescr}

\indextext{implementation-defined}%
\indexlibrary{\idxcode{exception}!destructor}%
\begin{itemdecl}
virtual ~exception() throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Destroys an object of class
\tcode{exception}.

\pnum
\notes
Does not throw any exceptions.
\end{itemdescr}

\indexlibrary{\idxcode{what}!\tcode{exception}}%
\begin{itemdecl}
virtual const char* what() const throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\indextext{exception::what~message@\tcode{exception::what}~message!implementation-defined}%
An \impldef{result of \tcode{exception::what}} \ntbs.

\pnum
\notes
The message may be a null-terminated multibyte string~(\ref{lib.multibyte.strings}),
suitable for conversion and display as a
\tcode{wstring}~(\ref{lib.string.classes}, \ref{lib.locale.codecvt}).
The return value remains valid until the exception object from which
it is obtained is destroyed or a non-\tcode{const}
member function of the exception object is called.
\end{itemdescr}

\rSec2[lib.exception.unexpected]{Violating \grammarterm{exception-specification}{s}}

\rSec3[lib.bad.exception]{Class \tcode{bad_exception}}

\indexlibrary{\idxcode{bad_exception}}%
\begin{codeblock}
namespace std {
  class bad_exception : public exception {
  public:
    bad_exception() throw();
    bad_exception(const bad_exception&) throw();
    bad_exception& operator=(const bad_exception&) throw();
    virtual ~bad_exception() throw();
    virtual const char* what() const throw();
  };
}
\end{codeblock}

\pnum
The class
\tcode{bad_exception}
defines the type of objects thrown as
described in~(\ref{except.unexpected}).

\indexlibrary{\idxcode{bad_exception}!\tcode{bad_exception}}%
\begin{itemdecl}
bad_exception() throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{bad_exception}.

\pnum
\notes
The result of calling
\tcode{what()}
on the newly constructed object is implementation-defined.%
\indextext{implementation-defined}
\end{itemdescr}

\indexlibrary{\idxcode{bad_exception}!\tcode{bad_exception}}%
\indexlibrary{\idxcode{operator=}!\tcode{bad_exception}}%
\begin{itemdecl}
    bad_exception(const bad_exception&) throw();
    bad_exception& operator=(const bad_exception&) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Copies an object of class
\tcode{bad_exception}.
\end{itemdescr}

\indexlibrary{\idxcode{what}!\tcode{bad_exception}}%
\begin{itemdecl}
virtual const char* what() const throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An \impldef{return value of \tcode{bad_exception::what}} \ntbs.%
\indexlibrary{\idxcode{bad_exception::what}!implementation-defined}

\pnum
\notes
The message may be a null-terminated multibyte string~(\ref{lib.multibyte.strings}),
suitable for conversion and display as a
\tcode{wstring}~(\ref{lib.string.classes}, \ref{lib.locale.codecvt}).
\end{itemdescr}

\rSec3[lib.unexpected.handler]{Type \tcode{unexpected_handler}}

\indexlibrary{\idxcode{unexpected_handler}}%
\begin{itemdecl}
typedef void (*unexpected_handler)();
\end{itemdecl}

\begin{itemdescr}
\pnum
The type of a
\term{handler function}
to be called by
\tcode{unexpected()}
when a function attempts to throw an exception not listed in its
\grammarterm{exception-specification}.

\pnum
\required
An
\tcode{unexpected_handler}
shall not return.
See also~\ref{except.unexpected}.

\pnum
\default
The implementation's default \tcode{unexpected_handler} calls
\tcode{terminate()}.
\indexlibrary{\idxcode{terminate}}
\end{itemdescr}

\rSec3[lib.set.unexpected]{\tcode{set_unexpected}}

\indexlibrary{\idxcode{set_unexpected}}%
\begin{itemdecl}
unexpected_handler set_unexpected(unexpected_handler f) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Establishes the function designated by \tcode{f} as the current
\tcode{unexpected_handler}.

\pnum
\requires \tcode{f} shall not be a null pointer.

\pnum
\returns
The previous \tcode{unexpected_handler}.
\end{itemdescr}

\rSec3[lib.unexpected]{\tcode{unexpected}}

\indexlibrary{\idxcode{unexpected}}%
\begin{itemdecl}
void unexpected();
\end{itemdecl}

\begin{itemdescr}
\pnum
Called by the implementation when a function exits via an exception not allowed by its
\grammarterm{exception-specification}
(\ref{except.unexpected}).
May also be called directly by the program.

\pnum
\effects
Calls the \tcode{unexpected_handler} function in effect immediately after
evaluating the \grammarterm{throw-expression}
(\ref{lib.unexpected.handler}),
if called by the implementation, or calls the current
\tcode{unexpected_handler}, if called by the program.
\end{itemdescr}

\rSec2[lib.exception.terminate]{Abnormal termination}

\rSec3[lib.terminate.handler]{Type \tcode{terminate_handler}}

\indexlibrary{\idxcode{terminate_handler}}%
\begin{itemdecl}
typedef void (*terminate_handler)();
\end{itemdecl}

\begin{itemdescr}
\pnum
The type of a
\term{handler function}
to be called by
\tcode{terminate()}
\indexlibrary{\idxcode{terminate}}%
when terminating exception processing.

\pnum
\required
A \tcode{terminate_handler} shall
terminate execution of the program without returning to the caller.

\pnum
\default
The implementation's default \tcode{terminate_handler} calls
\tcode{abort()}.%
\indexlibrary{\idxcode{abort}}
\end{itemdescr}

\rSec3[lib.set.terminate]{\tcode{set_terminate}}

\indexlibrary{\idxcode{set_terminate}}%
\begin{itemdecl}
terminate_handler set_terminate(terminate_handler f) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Establishes the function designated by \tcode{f} as the current
handler function for terminating exception processing.

\pnum
\requires \tcode{f} shall not be a null pointer.

\pnum
\returns
The previous \tcode{terminate_handler}.
\end{itemdescr}

\rSec3[lib.terminate]{\tcode{terminate}}

\indexlibrary{\idxcode{terminate}}%
\begin{itemdecl}
void terminate();
\end{itemdecl}

\begin{itemdescr}
\pnum
Called by the implementation when exception
handling must be abandoned for any of several reasons~(\ref{except.terminate}).
May also be called directly by the program.

\pnum
\effects
Calls the \tcode{terminate_handler} function in effect immediately after
evaluating the \grammarterm{throw-exception}
(\ref{lib.terminate.handler}),
if called by the implementation, or calls the current
\tcode{terminate_handler} function, if called by the program.
\end{itemdescr}

\rSec2[lib.uncaught]{\tcode{uncaught_exception}}

\indexlibrary{\idxcode{uncaught_exception}}%
\begin{itemdecl}
bool uncaught_exception() throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true}
after completing evaluation of a
\grammarterm{throw-expression}
until either completing initialization of the
\grammarterm{exception-declaration}
in the matching handler or entering
\tcode{unexpected()}
due to the throw; or after entering
\tcode{terminate()}
for any reason other than an explicit call to
\tcode{terminate()}.
\enternote
This includes stack unwinding~(\ref{except.ctor}).
\exitnoteb

\pnum
\notes
When
\tcode{uncaught_exception()}
is
\tcode{true},
throwing an exception can result in a call of
\tcode{terminate()}
(\ref{except.terminate}).
\end{itemdescr}

\rSec1[lib.support.runtime]{Other runtime support}

\pnum
\indexlibrary{\idxhdr{cstdarg}}%
\indexlibrary{\idxhdr{csetjmp}}%
\indexlibrary{\idxhdr{ctime}}%
\indexlibrary{\idxhdr{csignal}}%
\indexlibrary{\idxhdr{cstdlib}}%
\indexlibrary{\idxcode{clock}}%
\indexlibrary{\idxcode{time}}%
\indexlibrary{\idxcode{getenv}}%
\indexlibrary{\idxcode{system}}%
Headers
\tcode{<cstdarg>} (variable arguments),
\tcode{<csetjmp>} (nonlocal jumps),
\tcode{<ctime>} (system clock \tcode{clock(), time()}),
\tcode{<csignal>} (signal handling),
and
\tcode{<cstdlib>} (runtime environment \tcode{getenv(), system()}).

\indexlibrary{\idxhdr{cstdarg}}%
\indexlibrary{\idxcode{va_arg}}%
\indexlibrary{\idxcode{va_end}}%
\indexlibrary{\idxcode{va_start}}%
\indexlibrary{\idxcode{va_list}}%
\begin{libsyntab4}{cstdarg}{tab:support.hdr.cstdarg}
\macros &   \tcode{va_arg}      &   \tcode{va_end}  &   \tcode{va_start}    \\
\rowsep
\type   &   \tcode{va_list}       &                     &                       \\
\end{libsyntab4}

\indexlibrary{\idxhdr{csetjmp}}%
\indexlibrary{\idxcode{setjmp}}%
\indexlibrary{\idxcode{jmp_buf}}%
\indexlibrary{\idxcode{longjmp}}%
\begin{libsyntab2}{csetjmp}{tab:support.hdr.csetjmp}
\macro      &   \tcode{setjmp}  \\ \rowsep
\type       &   \tcode{jmp_buf} \\ \rowsep
\function   &   \tcode{longjmp} \\
\end{libsyntab2}

\indexlibrary{\idxhdr{ctime}}%
\indexlibrary{\idxcode{CLOCKS_PER_SEC}}%
\indexlibrary{\idxcode{clock_t}}%
\indexlibrary{\idxcode{clock}}%
\begin{libsyntab2}{ctime}{tab:support.hdr.ctime}
\macro      &   \tcode{CLOCKS_PER_SEC}  \\ \rowsep
\type       &   \tcode{clock_t}         \\ \rowsep
\function   &   \tcode{clock}           \\
\end{libsyntab2}

\indexlibrary{\idxhdr{csignal}}%
\indexlibrary{\idxcode{SIG_IGN}}%
\indexlibrary{\idxcode{SIGABRT}}%
\indexlibrary{\idxcode{SIGFPE}}%
\indexlibrary{\idxcode{sig_atomic_t}}%
\indexlibrary{\idxcode{raise}}%
\indexlibrary{\idxcode{SIGILL}}%
\indexlibrary{\idxcode{SIGINT}}%
\indexlibrary{\idxcode{signal}}%
\indexlibrary{\idxcode{SIGSEGV}}%
\indexlibrary{\idxcode{SIGTERM}}%
\indexlibrary{\idxcode{SIG_DFL}}%
\indexlibrary{\idxcode{SIG_ERR}}%
\begin{libsyntab5}{csignal}{tab:support.hdr.csignal}
\macros             &   \tcode{SIGABRT} &   \tcode{SIGILL}  &   \tcode{SIGSEGV} &   \tcode{SIG_DFL} \\
\tcode{SIG_IGN}     &   \tcode{SIGFPE}  &   \tcode{SIGINT}  &   \tcode{SIGTERM} &   \tcode{SIG_ERR} \\ \rowsep
\type               &   \tcode{sig_atomic_t}    &           &                   &                   \\ \rowsep
\functions          &   \tcode{raise}   &   \tcode{signal}  &                   &                   \\
\end{libsyntab5}

\indexlibrary{\idxhdr{cstdlib}}%
\indexlibrary{\idxcode{getenv}}%
\indexlibrary{\idxcode{system}}%
\begin{libsyntab3}{cstdlib}{tab:support.hdr.cstdlib1}
\functions  &   \tcode{getenv}  &   \tcode{system}  \\
\end{libsyntab3}

\pnum
\indexlibrary{\idxhdr{stdarg.h}}%
\indexlibrary{\idxhdr{setjmp.h}}%
\indexlibrary{\idxhdr{time.h}}%
\indexlibrary{\idxhdr{signal.h}}%
\indexlibrary{\idxhdr{stdlib.h}}%
The contents of these headers are the same as the Standard C library headers
\tcode{<stdarg.h>},
\tcode{<setjmp.h>},
\tcode{<time.h>},
\tcode{<signal.h>},
and
\tcode{<stdlib.h>},
respectively, with the following changes:

\pnum
The restrictions that ISO C places on the second parameter to the
\indexlibrary{\idxcode{va_start}}%
\tcode{va_start()}
macro in header
\indexlibrary{\idxhdr{stdarg.h}}%
\tcode{<stdarg.h>}
are different in this International Standard.
The parameter
\tcode{parmN}
is the identifier of the rightmost parameter in the variable parameter list
of the function definition (the one just before the
\tcode{...}).
If the parameter
\tcode{parmN}
is declared with a function, array, or reference type, or with a type that
is not compatible with the type that results when passing an argument for
which there is no parameter, the behavior is undefined.

\xref ISO C subclause~4.8.1.1.

\pnum
The function signature
\indexlibrary{\idxcode{longjmp}}%
\tcode{longjmp(jmp_buf jbuf, int val)}
has more restricted behavior in this International Standard.
If any automatic objects would be destroyed by a thrown exception transferring
control to another (destination) point in the program, then a call to
\tcode{longjmp(jbuf, val)} at the throw point that transfers control to the
same (destination) point has undefined behavior.

\xref ISO C subclause~7.10.4, 7.8, 7.6, 7.12.

\pnum
The common subset of the C and \Cpp languages consists of all declarations,
definitions, and expressions that may appear in a well formed \Cpp program
and also in a conforming C program.
A
\indextext{POF}%
\indextext{function!plain old}%
POF (``plain old function'') is a function that uses only features from
this common subset, and that does not directly or indirectly use any
function that is not a POF. All signal handlers shall have C linkage.
A POF that could be used as a signal handler in a conforming C program
does not produce undefined behavior when used as a signal handler in a
\Cpp program.
The behavior of any other function used as a signal handler in a
\Cpp program is \impldef{use of non-POF function as signal handler}.\footnote{In
particular, a signal handler using exception handling is very likely to
have problems.}
