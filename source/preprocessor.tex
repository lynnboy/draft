\rSec0[cpp]{Preprocessing directives}%
\indextext{preprocessing directives|(}

\indextext{compiler control line|see{preprocessing directives}}%
\indextext{control line|see{preprocessing directives}}%
\indextext{directive, preprocessing|see{preprocessing directives}}

%gram: \rSec1[gram.cpp]{Preprocessing directives}
%gram:

\pnum
A preprocessing directive consists of a sequence of preprocessing tokens.
The first token in the sequence is a
\tcode{\#}
preprocessing token that is either the first character in the source file
(optionally after white space containing no new-line characters)
or that follows white space containing at least one new-line character.
The last token in the sequence is the first new-line character
that follows the first token in the sequence.\footnote{Thus,
preprocessing directives are commonly called ``lines.''
These ``lines'' have no other syntactic significance,
as all white space is equivalent except in certain situations
during preprocessing (see the
\tcode{\#}
character string literal creation operator in~\ref{cpp.stringize}, for example).}

\begin{bnf}
\nontermdef{preprocessing-file}\br
    group\opt
\end{bnf}

\begin{bnf}
\nontermdef{group}\br
    group-part\br
    group group-part
\end{bnf}

\begin{bnf}
\nontermdef{group-part}\br
    pp-tokens\opt new-line\br
    if-section\br
    control-line
\end{bnf}

\begin{bnf}
\nontermdef{if-section}\br
    if-group elif-groups\opt else-group\opt endif-line
\end{bnf}

\begin{bnftab}
\nontermdef{if-group}\br
\>\terminal{\# if}\>\>constant-expression new-line group\opt\br
\>\terminal{\# ifdef}\>\>identifier new-line group\opt\br
\>\terminal{\# ifndef}\>\>identifier new-line group\opt
\end{bnftab}

\begin{bnf}
\nontermdef{elif-groups}\br
    elif-group\br
    elif-groups elif-group
\end{bnf}

\begin{bnftab}
\nontermdef{elif-group}\br
\>\terminal{\# elif}\>\>constant-expression new-line group\opt
\end{bnftab}

\begin{bnftab}
\nontermdef{else-group}\br
\>\terminal{\# else}\>\>new-line group\opt
\end{bnftab}

\begin{bnftab}
\nontermdef{endif-line}\br
\>\terminal{\# endif}\>\>new-line
\end{bnftab}

\begin{bnftab}
\nontermdef{control-line}\br
\>\terminal{\# include}\>\>pp-tokens new-line\br
\>\terminal{\# define}\>\>identifier replacement-list new-line\br
\>\terminal{\# define}\>\>identifier lparen identifier-list\opt \terminal{)} replacement-list new-line\br
\>\terminal{\# undef}\>\>identifier new-line\br
\>\terminal{\# line}\>\>pp-tokens new-line\br
\>\terminal{\# error}\>\>pp-tokens\opt new-line\br
\>\terminal{\# pragma}\>\>pp-tokens\opt new-line\br
\>\terminal{\# }\>\>new-line
\end{bnftab}

\begin{bnf}
\nontermdef{lparen}\br
    \descr{the left-parenthesis character without preceding white-space}
\end{bnf}

\begin{bnf}
\nontermdef{replacement-list}\br
    pp-tokens\opt
\end{bnf}

\begin{bnf}
\nontermdef{pp-tokens}\br
    preprocessing-token\br
    pp-tokens preprocessing-token
\end{bnf}

\begin{bnf}
\nontermdef{new-line}\br
    \descr{the new-line character}
\end{bnf}

\pnum
The only white-space characters that shall appear
between preprocessing tokens
within a preprocessing directive
(from just after the introducing
\tcode{\#}
preprocessing token through just before the terminating new-line character)
are space and horizontal-tab
(including spaces that have replaced comments
or possibly other white-space characters
in translation phase 3).

\pnum
The implementation can
process and skip sections of source files conditionally,
include other source files,
and replace macros.
These capabilities are called
\term{preprocessing},
because conceptually they occur
before translation of the resulting translation unit.

\pnum
The preprocessing tokens within a preprocessing directive
are not subject to macro expansion unless otherwise stated.

\rSec1[cpp.cond]{Conditional inclusion}%
\indextext{preprocessing directive!conditional inclusion}%
\indextext{inclusion!conditional|see{preprocessing directive, conditional inclusion}}

\pnum
The expression that controls conditional inclusion
shall be an integral constant expression except that:
it shall not contain a cast; identifiers
(including those lexically identical to keywords)
are interpreted as described below;\footnote{Because the controlling constant expression is evaluated
during translation phase 4,
all identifiers either are or are not macro names ---
there simply are no keywords, enumeration constants, and so on.}
and it may contain unary operator expressions of the form

\begin{ncbnf}
\terminal{defined} identifier
\end{ncbnf}

or

\begin{ncbnf}
\terminal{defined (} identifier \terminal{)}
\end{ncbnf}

which evaluate to
\tcode{1}
if the identifier is currently defined
as a macro name
(that is, if it is predefined
or if it has been the subject of a
\tcode{\#define}
preprocessing directive
without an intervening
\tcode{\#undef}
directive with the same subject identifier), zero if it is not.

\pnum
Each preprocessing token that remains
after all macro replacements have occurred
shall be in the lexical form of a token~(\ref{lex.token}).

\pnum
Preprocessing directives of the forms

\begin{ncbnftab}
\indextext{\idxcode{\#if}}%
\terminal{\# if}\>\>constant-expression new-line group\opt\br
\indextext{\idxcode{\#elif}}%
\terminal{\# elif}\>\>constant-expression new-line group\opt
\end{ncbnftab}

check whether the controlling constant expression evaluates to nonzero.

\pnum
Prior to evaluation,
macro invocations in the list of preprocessing tokens
that will become the controlling constant expression
are replaced
(except for those macro names modified by the
\tcode{defined}
unary operator),
just as in normal text.
If the token
\tcode{defined}
is generated as a result of this replacement process
or use of the
\tcode{defined}
unary operator does not match one of the two specified forms
prior to macro replacement,
the behavior is undefined.
After all replacements due to macro expansion and the
\tcode{defined}
unary operator have been performed,
all remaining identifiers and keywords\footnote{An alternative
token~(\ref{lex.digraph}) is not an identifier,
even when its spelling consists entirely of letters and underscores.
Therefore it is not subject to this replacement.},
except for
\tcode{true}
and
\tcode{false},
are replaced with the pp-number
\tcode{0},
and then each preprocessing token is converted into a token.
The resulting tokens comprise the controlling constant expression
which is evaluated according to the rules of~\ref{expr.const}
using arithmetic that has at least the ranges specified
in~\ref{lib.support.limits}, except that \tcode{int} and \tcode{unsigned int}
act as if they have the same representation as, respectively,
\tcode{long} and \tcode{unsigned long}.
This includes interpreting character literals, which may involve
converting escape sequences into execution character set members.
Whether the numeric value for these character literals
matches the value obtained when an identical character literal
occurs in an expression
(other than within a
\tcode{\#if}
or
\tcode{\#elif}
directive)
is \impldef{numeric values of character literals in \tcode{\#if}
directives}.\footnote{Thus, the constant expression in the following
\tcode{\#if}
directive and
\tcode{if}
statement is not guaranteed to evaluate to the same value in these two
contexts.
\begin{tabbing}
\hspace{.6in}\=\kill%
\>\tcode{\#if 'z' - 'a' == 25}\\
\>\tcode{if ('z' - 'a' == 25)}
\end{tabbing}
}
Also, whether a single-character character literal may have a negative
value is \impldef{negative value of character literal in preprocessor}.
Each subexpression with type
\tcode{bool}
is subjected to integral promotion before processing continues.

\pnum
Preprocessing directives of the forms

\begin{ncbnftab}
\terminal{\# ifdef}\>\>identifier new-line group\opt\br
\indextext{\idxcode{\#ifdef}}%
\terminal{\# ifndef}\>\>identifier new-line group\opt
\indextext{\idxcode{\#ifndef}}%
\end{ncbnftab}

check whether the identifier is or is not currently defined as a macro name.
Their conditions are equivalent to
\tcode{\#if}
\tcode{defined}
\term{identifier}
and
\tcode{\#if}
\tcode{!defined}
\term{identifier}
respectively.

\pnum
Each directive's condition is checked in order.
If it evaluates to false (zero),
the group that it controls is skipped:
directives are processed only through the name that determines
the directive in order to keep track of the level
of nested conditionals;
the rest of the directives' preprocessing tokens are ignored,
as are the other preprocessing tokens in the group.
Only the first group
whose control condition evaluates to true (nonzero) is processed.
If none of the conditions evaluates to true,
and there is a
\tcode{\#else}
\indextext{\idxcode{\#else}}%
directive,
the group controlled by the
\tcode{\#else}
is processed; lacking a
\tcode{\#else}
directive, all the groups until the
\tcode{\#endif}
\indextext{\idxcode{\#endif}}%
are skipped.\footnote{As indicated by the syntax,
a preprocessing token shall not follow a
\tcode{\#else}
or
\tcode{\#endif}
directive before the terminating new-line character.
However,
comments may appear anywhere in a source file,
including within a preprocessing directive.}

\rSec1[cpp.include]{Source file inclusion}
\indextext{preprocessing directives!header inclusion}
\indextext{preprocessing directives!source-file inclusion}
\indextext{inclusion!source~file|see{preprocessing directives, source-file inclusion}}%
\indextext{\idxcode{\#include}}%

\pnum
A
\tcode{\#include}
directive shall identify a header or source file
that can be processed by the implementation.

\pnum
\indextext{\idxcode{<...>}|see{preprocessing directive, header}}%
A preprocessing directive of the form

\begin{ncsimplebnf}
\terminal{\# include <}h-char-sequence\terminal{>} new-line
\end{ncsimplebnf}

searches a sequence of
\impldef{sequence of places searched for a header}
places
for a header identified uniquely by the specified sequence
between the
\tcode{<}
and
\tcode{>}
delimiters,
and causes the replacement of that
directive by the entire contents of the header.
How the places are specified
or the header identified
is \impldef{search locations for \tcode{<>} header}.

\pnum
\indextext{\idxcode{\"{}...\"{}}|see{preprocessing directives, source-file inclusion}}%
A preprocessing directive of the form

\begin{ncsimplebnf}
\terminal{\# include "}q-char-sequence\terminal{"} new-line
\end{ncsimplebnf}

causes the replacement of that
directive by the entire contents of the
source file identified by the specified sequence between the
\tcode{"}
delimiters.
The named source file is searched for in an
\impldef{manner of search for included source file}
manner.
If this search is not supported,
or if the search fails,
the directive is reprocessed as if it read

\begin{ncsimplebnf}
\terminal{\# include <}h-char-sequence\terminal{>} new-line
\end{ncsimplebnf}

with the identical contained sequence (including
\tcode{>}
characters, if any) from the original directive.

\pnum
A preprocessing directive of the form

\begin{ncsimplebnf}
\terminal{\# include} pp-tokens new-line
\end{ncsimplebnf}

(that does not match one of the two previous forms) is permitted.
The preprocessing tokens after
\tcode{include}
in the directive are processed just as in normal text
(each identifier currently defined as a macro name is replaced by its
replacement list of preprocessing tokens).
If the directive resulting after all replacements does not match
one of the two previous forms, the behavior is
undefined.\footnote{Note that adjacent string literals are not concatenated into
a single string literal
(see the translation phases in~\ref{lex.phases});
thus, an expansion that results in two string literals is an
invalid directive.}
The method by which a sequence of preprocessing tokens between a
\tcode{<}
and a
\tcode{>}
preprocessing token pair or a pair of
\tcode{"}
characters is combined into a single header name
preprocessing token is \impldef{search locations for \tcode{""""} header}.

\pnum
The mapping between the delimited sequence and the external source file name
is \impldef{mapping between include and external source file}.
The implementation provides unique mappings for
sequences consisting of one or more
\grammarterm{nondigit}{s}~(\ref{lex.name})
followed by a period
(\tcode{.})
and a single
\grammarterm{nondigit}.
The implementation may ignore the distinctions of alphabetical case.

\pnum
A
\tcode{\#include}
preprocessing directive may appear
in a source file that has been read because of a
\tcode{\#include}
directive in another file,
up to an \impldef{nesting limit for \tcode{\#include} directives} nesting limit.

\pnum
\enterexample
The most common use of \tcode{\#include} preprocessing directives are as
in the following:

\begin{codeblock}
#include <stdio.h>
#include "myprog.h"
\end{codeblock}

\exitexampleb

\pnum
\enterexample
Here is a macro-replaced
\tcode{\#include}
directives:

\begin{codeblock}
#if VERSION == 1
	#define INCFILE  "vers1.h"
#elif VERSION == 2
	#define INCFILE  "vers2.h"   /* and so on */
#else
	#define INCFILE  "versN.h"
#endif
#include INCFILE
\end{codeblock}
\exitexampleb

\rSec1[cpp.replace]{Macro replacement}%
\indextext{macro!replacement|(}%
\indextext{replacement!macro|see{macro, replacement}}%
\indextext{preprocessing directives!macro replacement|see{macro, replacement}}

\pnum
\indextext{macro!replacement list}%
Two replacement lists are identical if and only if
the preprocessing tokens in both have
the same number, ordering, spelling, and white-space separation,
where all white-space separations are considered identical.

\pnum
An identifier currently defined as a macro without use of lparen (an
\indextext{object-like macro|see{macro, object-like}}%
\indextext{macro!object-like}%
\grammarterm{object-like}
macro) may be redefined by another
\tcode{\#define}
preprocessing directive provided that the second definition is an
object-like macro definition and the two replacement lists
are identical, otherwise the program is ill-formed.

\pnum
An identifier currently defined as
a macro using lparen (a
\indextext{function-like macro|see{macro, function-like}}%
\indextext{macro!function-like}%
\grammarterm{function-like}
macro) may be redefined by another
\tcode{\#define}
preprocessing directive provided that the second definition is a
function-like macro definition that has the same number and spelling
of parameters,
and the two replacement lists are identical,
otherwise the program is ill-formed.

\pnum
The number of arguments in an invocation of a funciton-like macro shall
agree with the number of parameters in the macro definition, and there
shall exist a \tcode{)} preprocessing token that terminates the invocation.

\pnum
A parameter identifier in a function-like macro
shall be uniquely declared within its scope.

\pnum
The identifier immediately following the
\tcode{define}
is called the
\indextext{macro!name}%
\indextext{name!macro|see{macro, name}}%
\term{macro name}.
There is one name space for macro names.
Any white-space characters preceding or following the
replacement list of preprocessing tokens are not considered
part of the replacement list for either form of macro.

\pnum
If a
\indextext{\#\#0~operator@\tcode{\#}~operator}
\tcode{\#}
preprocessing token,
followed by an identifier,
occurs lexically
at the point at which a preprocessing directive could begin,
the identifier is not subject to macro replacement.

\pnum
A preprocessing directive of the form

\begin{ncsimplebnf}
\terminal{\# define} identifier replacement-list new-line
\indextext{\idxcode{\#define}}%
\end{ncsimplebnf}

defines an
\indextext{macro!object-like}%
object-like macro that
causes each subsequent instance of the macro name\footnote{Since, by macro-replacement time,
all character literals and string literals are preprocessing tokens,
not sequences possibly containing identifier-like subsequences
(see \ref{lex.phases}.1.2, translation phases),
they are never scanned for macro names or parameters.}
to be replaced by the replacement list of preprocessing tokens
that constitute the remainder of the directive.\footnote{An alternative token~(\ref{lex.digraph}) is not an identifier,
even when its spelling consists entirely of letters and underscores.
Therefore it is not possible to define a macro
whose name is the same as that of an alternative token.}
The replacement list is then rescanned for more macro names as
specified below.

\pnum
A preprocessing directive of the form

\begin{ncsimplebnf}
\terminal{\# define} identifier lparen identifier-list\opt \terminal{)} replacement-list new-line
\end{ncsimplebnf}

\indextext{macro!function-like}%
defines a function-like macro with parameters,
similar syntactically to a function call.
The parameters
\indextext{parameters!macro}%
are specified by the optional list of identifiers,
whose scope extends from their declaration in the identifier list
until the new-line character that terminates the
\tcode{\#define}
preprocessing directive.
Each subsequent instance of the function-like macro name followed by a
\tcode{(}
as the next preprocessing token
introduces the sequence of preprocessing tokens that is replaced
by the replacement list in the definition
(an invocation of the macro).
\indextext{invocation!macro}%
The replaced sequence of preprocessing tokens is terminated by the matching
\tcode{)}
preprocessing token, skipping intervening matched pairs of left and
right parenthesis preprocessing tokens.
Within the sequence of preprocessing tokens making up an invocation
of a function-like macro,
new-line is considered a normal white-space character.

\pnum
\indextext{macro!function-like!arguments}%
The sequence of preprocessing tokens
bounded by the outside-most matching parentheses
forms the list of arguments for the function-like macro.
The individual arguments within the list
are separated by comma preprocessing tokens,
but comma preprocessing tokens between matching
inner parentheses do not separate arguments.
If (before argument substitution) any argument consists of no preprocessing
tokens, the behavior is undefined.
If there are sequences of preprocessing tokens within the list of
arguments that would otherwise act as preprocessing directives,
the behavior is undefined.

\rSec2[cpp.subst]{Argument substitution}%
\indextext{macro!argument substitution}%
\indextext{argument~substitution|see{macro, argument substitution}}%

\pnum
After the arguments for the invocation of a function-like macro have
been identified, argument substitution takes place.
A parameter in the replacement list, unless preceded by a
\tcode{\#}
or
\tcode{\#\#}
preprocessing token or followed by a
\tcode{\#\#}
preprocessing token (see below),
is replaced by the corresponding argument after all macros
contained therein have been expanded.
Before being substituted,
each argument's preprocessing tokens are completely
macro replaced as if they formed the rest of the translation unit;
no other preprocessing tokens are available.

\rSec2[cpp.stringize]{The \tcode{\#} operator}%
\indextext{\#\#0~operator@\tcode{\#}~operator}%
\indextext{stringize|see{\tcode{\#}}}

\pnum
Each
\tcode{\#}
preprocessing token in the replacement list for a function-like
macro shall be followed by a parameter as the next preprocessing
token in the replacement list.

\pnum
If, in the replacement list, a parameter is immediately
preceded by a
\tcode{\#}
preprocessing token,
both are replaced by a single character string literal preprocessing token that
contains the spelling of the preprocessing token sequence for the
corresponding argument.
Each occurrence of white space between the argument's preprocessing
tokens becomes a single space character in the character string literal.
White space before the first preprocessing token and after the last
preprocessing token comprising the argument is deleted.
Otherwise, the original spelling of each preprocessing token in the
argument is retained in the character string literal,
except for special handling for producing the spelling of
string literals and character literals:
a
\tcode{\textbackslash}
character is inserted before each
\tcode{"}
and
\tcode{\textbackslash}
character of a character literal or string literal
(including the delimiting
\tcode{"}
characters).
If the replacement that results is not a valid character string literal,
the behavior is undefined.
The order of evaluation of
\tcode{\#}
and
\tcode{\#\#}
operators is unspecified.

\rSec2[cpp.concat]{The \tcode{\#\#} operator}%
\indextext{\#\#1 operator@\tcode{\#\#} operator}%
\indextext{concatenation!macro argument|see{\tcode{\#\#}}}

\pnum
A
\tcode{\#\#}
preprocessing token shall not occur at the beginning or
at the end of a replacement list for either form
of macro definition.

\pnum
If, in the replacement list, a parameter is
immediately preceded or followed by a
\tcode{\#\#}
preprocessing token, the parameter is replaced by the
corresponding argument's preprocessing token sequence.

\pnum
For both object-like and function-like macro invocations, before the
replacement list is reexamined for more macro names to replace,
each instance of a
\tcode{\#\#}
preprocessing token in the replacement list
(not from an argument) is deleted and the
preceding preprocessing token is concatenated
with the following preprocessing token.
If the result is not a valid preprocessing token,
the behavior is undefined.
The resulting token is available for further macro replacement.
The order of evaluation of
\tcode{\#\#}
operators is unspecified.

\rSec2[cpp.rescan]{Rescanning and further replacement}%
\indextext{macro!rescanning and replacement}%
\indextext{rescanning and replacement|see{macro, rescanning and replacement}}

\pnum
After all parameters in the replacement list have been substituted,
the resulting preprocessing token sequence is rescanned with all
subsequent preprocessing tokens of the source file for more macro names
to replace.

\pnum
If the name of the macro being replaced is found during this scan of
the replacement list
(not including the rest of the source file's preprocessing tokens),
it is not replaced.
Further,
if any nested replacements encounter the name of the macro being replaced,
it is not replaced.
These nonreplaced macro name preprocessing tokens are no longer available
for further replacement even if they are later (re)examined in contexts
in which that macro name preprocessing token would otherwise have been
replaced.

\pnum
The resulting completely macro-replaced preprocessing token sequence
is not processed as a preprocessing directive even if it resembles one.

\rSec2[cpp.scope]{Scope of macro definitions}%
\indextext{macro!scope of definition}%
\indextext{scope!macro definition|see{macro, scope of definition}}

\pnum
A macro definition lasts
(independent of block structure)
until a corresponding
\tcode{\#undef}
directive is encountered or
(if none is encountered)
until the end of the translation unit.

\pnum
A preprocessing directive of the form

\begin{ncsimplebnf}
\terminal{\# undef} identifier new-line
\indextext{\idxcode{\#undef}}%
\end{ncsimplebnf}

causes the specified identifier no longer to be defined as a macro name.
It is ignored if the specified identifier is not currently defined as
a macro name.

\pnum
\enternote
The simplest use of this facility is to define a ``manifest constant,''
as in
\begin{codeblock}
	#define TABSIZE 100
	int table[TABSIZE];
\end{codeblock}

\pnum
The following defines a function-like
macro whose value is the maximum of its arguments.
It has the advantages of working for any compatible types of the arguments
and of generating in-line code without the overhead of function calling.
It has the disadvantages of evaluating one or the other of its arguments
a second time
(including
\indextext{side effects}%
side effects)
and generating more code than a function if invoked several times.
It also cannot have its address taken,
as it has none.

\begin{codeblock}
#define max(a, b) ((a) > (b) ? (a) : (b))
\end{codeblock}

The parentheses ensure that the arguments and
the resulting expression are bound properly.

\pnum
To illustrate the rules for redefinition and reexamination,
the sequence

\begin{codeblock}
	#define x     3
	#define f(a)  f(x * (a))
	#undef  x
	#define x     2
	#define g     f
	#define z     z[0]
	#define h     g~
	#define m(a)  a(w)
	#define w     0,1
	#define t(a)  a

	f(y+1) + f(f(z)) % t(t(g)(0) + t)(1);
	g(x+(3,4)-w) | h 5) & m
		(f)^m(m);
\end{codeblock}

results in

\begin{codeblock}
f(2 * (y+1)) + f(2 * (f(2 * (z[0])))) % f(2 * (0)) + t(1);
f(2 * (2+(3,4)-0,1)) | f(2 * (~5)) & f(2 * (0,1))^m(0,1);
\end{codeblock}

\pnum
To illustrate the rules for creating character string literals
and concatenating tokens,
the sequence

\begin{codeblock}
	#define str(s)	    # s
	#define xstr(s)	    str(s)
	#define debug(s, t) printf("x" # s "= %d, x" # t "= %s", @\textbackslash@
					x ## s, x ## t)
	#define INCFILE(n)  vers ## n  /* from previous \tcode{\#include} example */
	#define glue(a, b)  a ## b
	#define xglue(a, b) glue(a, b)
	#define HIGHLOW	    "hello"
	#define LOW	    LOW ", world"

	debug(1, 2);
	fputs(str(strncmp("abc@\textbackslash@0d", "abc", '@\textbackslash@4')  /* this goes away */
		== 0) str(: @\atsign\textbackslash@n), s);
	#include xstr(INCFILE(2).h)
	glue(HIGH, LOW);
	xglue(HIGH, LOW)
\end{codeblock}

results in

\begin{codeblock}
printf("x" "1" "= %d, x" "2" "= %s", x1, x2);
fputs("strncmp(@\textbackslash@"abc@\textbackslash\textbackslash@0d@\textbackslash@", @\textbackslash@"abc@\textbackslash@", '@\textbackslash\textbackslash@4') == 0" ": @\atsign\textbackslash@n", s);
#include "vers2.h"    @\textit{(after macro replacement, before file access)}@
"hello";
"hello" ", world"
\end{codeblock}

or, after concatenation of the character string literals,

\begin{codeblock}
printf("x1= %d, x2= %s", x1, x2);
fputs("strncmp(@\textbackslash@"abc@\textbackslash\textbackslash@0d@\textbackslash@", @\textbackslash@"abc@\textbackslash@", '@\textbackslash\textbackslash@4') == 0: @\atsign\textbackslash@n", s);
#include "vers2.h"    @\textit{(after macro replacement, before file access)}@
"hello";
"hello, world"
\end{codeblock}

Space around the
\tcode{\#}
and
\tcode{\#\#}
tokens in the macro definition is optional.

\pnum
And finally, to demonstrate the redefinition rules,
the following sequence is valid.

\begin{codeblock}
#define OBJ_LIKE       (1-1)
#define OBJ_LIKE       @\tcode{/* white space */ (1-1) /* other */}@
#define FUNC_LIKE(a)   ( a )
#define FUNC_LIKE( a )(		 @\tcode{/* note the white space */ \textbackslash}@
				 a @\tcode{/* other stuff on this line}@
				   @\tcode{*/}@ )
\end{codeblock}

But the following redefinitions are invalid:

\begin{codeblock}
#define OBJ_LIKE     (0)     /* different token sequence */
#define OBJ_LIKE     (1 - 1) /* different white space */
#define FUNC_LIKE(b) ( a )   /* different parameter usage */
#define FUNC_LIKE(b) ( b )   /* different parameter spelling */
\end{codeblock}

\exitnoteb%
\indextext{macro!replacement|)}

\rSec1[cpp.line]{Line control}%
\indextext{preprocessing directives!line control}%
\indextext{\idxcode{\#line}|see{preprocessing directives, line control}}

\pnum
The string literal of a
\tcode{\#line}
directive, if present,
shall be a character string literal.

\pnum
The
\term{line number}
of the current source line is one greater than
the number of new-line characters read or introduced
in translation phase 1~(\ref{lex.phases})
while processing the source file to the current token.

\pnum
A preprocessing directive of the form

\begin{ncsimplebnf}
\terminal{\# line} digit-sequence new-line
\end{ncsimplebnf}

causes the implementation to behave as if
the following sequence of source lines begins with a
source line that has a line number as specified
by the digit sequence (interpreted as a decimal integer).
If the digit sequence specifies zero
or a number greater than 32767,
the behavior is undefined.

\pnum
A preprocessing directive of the form

\begin{ncsimplebnf}
\terminal{\# line} digit-sequence \terminal{"}s-char-sequence\opt\terminal{"} new-line
\end{ncsimplebnf}

sets the line number similarly and changes the
presumed name of the source file to be the contents
of the character string literal.

\pnum
A preprocessing directive of the form

\begin{ncsimplebnf}
\terminal{\# line} pp-tokens new-line
\end{ncsimplebnf}

(that does not match one of the two previous forms)
is permitted.
The preprocessing tokens after
\tcode{line}
on the directive are processed just as in normal text
(each identifier currently defined as a macro name is replaced by its
replacement list of preprocessing tokens).
If the directive resulting after all replacements does not match
one of the two previous forms, the behavior is undefined;
otherwise, the result is processed as appropriate.

\rSec1[cpp.error]{Error directive}%
\indextext{preprocessing directives!error}%
\indextext{\idxcode{\#error}|see{preprocessing directives, error}}

\pnum
A preprocessing directive of the form

\begin{ncsimplebnf}
\terminal{\# error} pp-tokens\opt new-line
\end{ncsimplebnf}

causes the implementation to produce
a diagnostic message that includes the specified sequence of preprocessing tokens,
and renders the program ill-formed.

\rSec1[cpp.pragma]{Pragma directive}%
\indextext{preprocessing directives!pragma}%
\indextext{\idxcode{\#pragma}|see{preprocessing directives, pragma}}

\pnum
A preprocessing directive of the form

\begin{ncsimplebnf}
\terminal{\# pragma} pp-tokens\opt new-line
\end{ncsimplebnf}

causes the implementation to behave
in an \impldef{\#pragma@\tcode{\#pragma}} manner.
Any pragma that is not recognized by the implementation is ignored.

\rSec1[cpp.null]{Null directive}%
\indextext{preprocessing directives!null}

\pnum
A preprocessing directive of the form

\begin{ncsimplebnf}
\terminal{\#} new-line
\end{ncsimplebnf}

has no effect.

\rSec1[cpp.predefined]{Predefined macro names}
\indextext{macro!predefined}%
\indextext{name!predefined macro|see{macro, predefined}}

\pnum
The following macro names shall be defined by the implementation:

\begin{description}

\indextext{\xname{LINE}@\mname{LINE}}%
\item \mname{LINE}\\
The line number of the current source line
(a decimal constant).

\indextext{\xname{FILE}@\mname{FILE}}%
\item \mname{FILE}\\
The presumed name of the source file (a character string
literal).

\indextext{\xname{DATE}@\mname{DATE}}%
\item \mname{DATE}\\
The date of translation of the source file
(a character string literal of the form
\tcode{"Mmm~dd~yyyy"},
where the names of the months are the same as those generated
by the
\tcode{asctime}
function,
and the first character of
\tcode{dd}
is a space character if the value is less than 10).
If the date of translation is not available,
an \impldef{text of \mname{DATE} when date of translation is not available} valid date
is supplied.

\indextext{\xname{TIME}@\mname{TIME}}%
\item \mname{TIME}\\
The time of translation of the source file
(a character string literal of the form
\tcode{"hh:mm:ss"}
as in the time generated by the
\tcode{asctime}
function).
If the time of translation is not available,
an \impldef{text of \mname{TIME} when time of translation is not available} valid time is supplied.

\indextext{\xname{STDC}@\mname{STDC}}%
\indextext{\xname{STDC}@\mname{STDC}!implementation-defined}%
\item \mname{STDC}\\
Whether \mname{STDC} is predefined and if so, what its value is,
are \impldef{definition and meaning of \mname{STDC}}.

\indextext{\idxcode{\unun cplusplus}}%
\item \tcode{\xname{cplusplus}}\\
The name \tcode{\,\xname{cplusplus}} is defined
to the value
\tcode{\cppver}
when
compiling a \Cpp translation unit.\footnote{It is intended that future
versions of this standard will
replace the value of this macro with a greater value.
Non-conforming compilers should use a value with at most
five decimal digits.}

\end{description}

\pnum
The values of the predefined macros
(except for
\mname{LINE}
and
\mname{FILE})
remain constant throughout the translation unit.

\pnum
If any of the pre-defined macro names in this subclause,
or the identifier
\tcode{defined},
is the subject of a
\tcode{\#define}
or a
\tcode{\#undef}
preprocessing directive,
the behavior is undefined.%
\indextext{preprocessing directives|)}
