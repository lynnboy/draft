\infannex{gram}{Grammar summary}

\begin{paras}

\pnum
\index{grammar}%
\index{summary, syntax}%
This summary of \Cpp\  syntax is intended to be an aid to comprehension.
It is not an exact statement of the language.
In particular, the grammar described here accepts
a superset of valid \Cpp\  constructs.
Disambiguation rules (\ref{stmt.ambig}, \ref{dcl.spec}, \ref{class.member.lookup})
must be applied to distinguish expressions from declarations.
Further, access control, ambiguity, and type rules must be used
to weed out syntactically valid but meaningless constructs.

\rSec1[gram.key]{Keywords}

\pnum
\index{keyword}%
New context-dependent keywords are introduced into a program by
\tcode{typedef}~(\ref{dcl.typedef}),
namespace~(\ref{namespace.def}),
class~(clause \ref{class}), enumeration~(\ref{dcl.enum}), and
\tcode{template}~(clause \ref{temp})
declarations.

\begin{bnf}
typedef-name:\br
	identifier
\end{bnf}

\begin{bnf}
namespace-name:\br
	original-namespace-name\br
	namespace-alias

original-namespace-name:\br
	identifier

namespace-alias:\br
	identifier
\end{bnf}

\begin{bnf}
class-name:\br
	identifier\br
	template-id
\end{bnf}

\begin{bnf}
enum-name:\br
	identifier
\end{bnf}

\begin{bnf}
template-name:\br
	identifier
\end{bnf}

Note that a
\textit{typedef-name}\ 
naming a class is also a
\textit{class-name}\ 
(\ref{class.name}).

\end{paras}

% machine generated after this line; do not edit
\rSec1[gram.lex]{Lexical conventions}

\begin{bnf}
\nontermdef{hex-quad}\br
    hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
\end{bnf}


\begin{bnf}
\nontermdef{universal-character-name}\br
    \terminal{\textbackslash u} hex-quad\br
    \terminal{\textbackslash U} hex-quad hex-quad
\end{bnf}


\begin{bnf}
\nontermdef{preprocessing-token}\br
    header-name\br
    identifier\br
    pp-number\br
    character-literal\br
    string-literal\br
    preprocessing-op-or-punc\br
    \textnormal{each non-white-space character that cannot be one of the above}
\end{bnf}


\begin{bnf}
\nontermdef{token}\br
    identifier\br
    keyword\br
    literal\br
    operator\br
    punctuator
\end{bnf}


\begin{bnf}
\nontermdef{header-name}\br
    \terminal{<} h-char-sequence \terminal{>}\br
    \terminal{"} q-char-sequence \terminal{"}
\end{bnf}


\begin{bnf}
\nontermdef{h-char-sequence}\br
    h-char\br
    h-char-sequence h-char
\end{bnf}


\begin{bnftab}
\nontermdef{h-char}\br
\>\textnormal{any member of the source character set except}\br
\>\>\textnormal{new-line and \terminal{>}}
\end{bnftab}


\begin{bnf}
\nontermdef{q-char-sequence}\br
    q-char\br
    q-char-sequence q-char
\end{bnf}


\begin{bnftab}
\nontermdef{q-char}\br
\>\textnormal{any member of the source character set except}\br
\>\>\textnormal{new-line and \terminal{"}}
\end{bnftab}


\begin{bnf}
\nontermdef{pp-number}\br
    digit\br
    \terminal{.} digit\br
    pp-number digit\br
    pp-number nondigit\br
    pp-number \terminal{e} sign\br
    pp-number \terminal{E} sign\br
    pp-number \terminal{.}
\end{bnf}


\begin{bnf}
\nontermdef{identifier}\br
    nondigit\br
    identifier nondigit\br
    identifier digit
\end{bnf}


\begin{bnf}
\nontermdef{nondigit} \textnormal{one of}\br
    universal-character-name\br
    \terminal{_ a b c d e f g h i j k l m}\br
    \terminal{n o p q r s t u v w x y z}\br
    \terminal{A B C D E F G H I J K L M}\br
    \terminal{N O P Q R S T U V W X Y Z}
\end{bnf}


\begin{bnf}
\nontermdef{digit} \textnormal{one of}\br
    \terminal{0 1 2 3 4 5 6 7 8 9}
\end{bnf}


\begin{bnfkeywordtab}
\nontermdef{preprocessing-op-or-punc} \textnormal{one of}\br
\>\{ \>\} \>[ \>] \>\# \>\#\# \>( \>)\br
\><: \>:> \><\% \>\%> \>\%: \>\%:\%: \>; \>: \>.{..}\br
\>new \>delete \>? \>:: \>. \>.*\br
\>+ \>- \>* \>/ \>\% \>\^{} \>\& \>| \>\tilde\br
\>! \>= \>< \>> \>+= \>-= \>*= \>/= \>\%=\br
\>\^{}= \>\&= \>|= \>\shl \>\shr \>\shr= \>\shl= \>== \>!=\br
\><= \>>= \>\&\& \>|| \>++ \>-{-} \>, \>->* \>->\br
\>and \>and_eq \>bitand \>bitor \>compl \>not \>not_eq\br
\>or \>or_eq \>xor \>xor_eq
\end{bnfkeywordtab}

\begin{bnf}
\nontermdef{literal}\br
    integer-literal\br
    character-literal\br
    floating-literal\br
    string-literal\br
    boolean-literal\br
\end{bnf}


\begin{bnf}
\nontermdef{integer-literal}\br
    decimal-literal integer-suffix\opt\br
    octal-literal integer-suffix\opt\br
    hexadecimal-literal integer-suffix\opt
\end{bnf}


\begin{bnf}
\nontermdef{decimal-literal}\br
    nonzero-digit\br
    decimal-literal digit
\end{bnf}


\begin{bnf}
\nontermdef{octal-literal}\br
    \terminal{0}\br
    octal-literal octal-digit
\end{bnf}


\begin{bnf}
\nontermdef{hexadecimal-literal}\br
    \terminal{0x} hexadecimal-digit\br
    \terminal{0X} hexadecimal-digit\br
    hexadecimal-literal hexadecimal-digit
\end{bnf}


\begin{bnf}
\nontermdef{nonzero-digit} \textnormal{one of}\br
    \terminal{1  2  3  4  5  6  7  8  9}
\end{bnf}


\begin{bnf}
\nontermdef{octal-digit} \textnormal{one of}\br
    \terminal{0  1  2  3  4  5  6  7}
\end{bnf}


\begin{bnf}
\nontermdef{hexadecimal-digit} \textnormal{one of}\br
    \terminal{0  1  2  3  4  5  6  7  8  9}\br
    \terminal{a  b  c  d  e  f}\br
    \terminal{A  B  C  D  E  F}
\end{bnf}


\begin{bnf}
\nontermdef{integer-suffix}\br
    unsigned-suffix long-suffix\opt \br
    long-suffix unsigned-suffix\opt \br
\end{bnf}


\begin{bnf}
\nontermdef{unsigned-suffix} \textnormal{one of}\br
    \terminal{u  U}
\end{bnf}


\begin{bnf}
\nontermdef{long-suffix} \textnormal{one of}\br
    \terminal{l  L}
\end{bnf}


\begin{bnf}
\nontermdef{character-literal}\br
    \terminal{'} c-char-sequence \terminal{'}\br
    L\terminal{'} c-char-sequence \terminal{'}
\end{bnf}


\begin{bnf}
\nontermdef{c-char-sequence}\br
    c-char\br
    c-char-sequence c-char
\end{bnf}


\begin{bnftab}
\nontermdef{c-char}\br
\>\textnormal{any member of the source character set except}\br
\>\>\textnormal{the single-quote \terminal{'}, backslash \terminal{\textbackslash}, or new-line character}\br
\>escape-sequence\br
\>universal-character-name
\end{bnftab}


\begin{bnf}
\nontermdef{escape-sequence}\br
    simple-escape-sequence\br
    octal-escape-sequence\br
    hexadecimal-escape-sequence
\end{bnf}


\begin{bnf}
\nontermdef{simple-escape-sequence} \textnormal{one of}\br
    \terminal{\textbackslash'}\quad\terminal{\textbackslash"}\quad\terminal{\textbackslash ?}\quad\terminal{\textbackslash\textbackslash}\br
    \terminal{\textbackslash a}\quad\terminal{\textbackslash b}\quad\terminal{\textbackslash f}\quad\terminal{\textbackslash n}\quad\terminal{\textbackslash r}\quad\terminal{\textbackslash t}\quad\terminal{\textbackslash v}
\end{bnf}


\begin{bnf}
\nontermdef{octal-escape-sequence}\br
    \terminal{\textbackslash} octal-digit\br
    \terminal{\textbackslash} octal-digit octal-digit\br
    \terminal{\textbackslash} octal-digit octal-digit octal-digit
\end{bnf}


\begin{bnf}
\nontermdef{hexadecimal-escape-sequence}\br
    \terminal{\textbackslash x} hexadecimal-digit\br
    hexadecimal-escape-sequence hexadecimal-digit
\end{bnf}


\begin{bnf}
\nontermdef{floating-literal}\br
    fractional-constant exponent-part\opt floating-suffix\opt\br
    digit-sequence exponent-part floating-suffix\opt
\end{bnf}


\begin{bnf}
\nontermdef{fractional-constant}\br
    digit-sequence\opt \terminal{.} digit-sequence\br
    digit-sequence \terminal{.}
\end{bnf}


\begin{bnf}
\nontermdef{exponent-part}\br
    \terminal{e} sign\opt digit-sequence\br
    \terminal{E} sign\opt digit-sequence
\end{bnf}


\begin{bnf}
\nontermdef{sign} \textnormal{one of}\br
    \terminal{+  -}
\end{bnf}


\begin{bnf}
\nontermdef{digit-sequence}\br
    digit\br
    digit-sequence digit
\end{bnf}


\begin{bnf}
\nontermdef{floating-suffix} \textnormal{one of}\br
    \terminal{f  l  F  L}
\end{bnf}


\begin{bnf}
\nontermdef{string-literal}\br
    \terminal{"} s-char-sequence\opt \terminal{"}\br
    \terminal{L"} s-char-sequence\opt \terminal{"}\br
\end{bnf}


\begin{bnf}
\nontermdef{s-char-sequence}\br
    s-char\br
    s-char-sequence s-char
\end{bnf}


\begin{bnftab}
\nontermdef{s-char}\br
\>\textnormal{any member of the source character set except}\br
\>\>\textnormal{the double-quote \terminal{"}, backslash \terminal{\textbackslash}, or new-line character}\br
\>escape-sequence\br
\>universal-character-name
\end{bnftab}


\begin{bnf}
\nontermdef{boolean-literal}\br
    \terminal{false}\br
    \terminal{true}
\end{bnf}


\rSec1[gram.basic]{Basic concepts}

\begin{bnf}
\nontermdef{translation-unit}\br
    declaration-seq\opt
\end{bnf}


\rSec1[gram.expr]{Expressions}

\begin{bnf}
\nontermdef{primary-expression}\br
    literal\br
    \terminal{this}\br
    \terminal{(} expression \terminal{)}\br
    id-expression
\end{bnf}


\begin{bnf}
\nontermdef{id-expression}\br
    unqualified-id\br
    qualified-id
\end{bnf}


\begin{bnf}
\nontermdef{unqualified-id}\br
    identifier\br
    operator-function-id\br
    conversion-function-id\br
    \terminal{\tilde} class-name\br
    template-id
\end{bnf}


\begin{bnf}
\nontermdef{qualified-id}\br
    \terminal{::}\opt nested-name-specifier \terminal{template}\opt unqualified-id\br
    \terminal{::} identifier\br
    \terminal{::} operator-function-id\br
    \terminal{::} template-id
\end{bnf}


\begin{bnf}
\nontermdef{nested-name-specifier}\br
    class-or-namespace-name \terminal{::} nested-name-specifier\opt\br
    class-or-namespace-name \terminal{::} \terminal{template} nested-name-specifier
\end{bnf}


\begin{bnf}
\nontermdef{class-or-namespace-name}\br
    class-name\br
    namespace-name
\end{bnf}


\begin{bnf}
\nontermdef{postfix-expression}\br
    primary-expression\br
    postfix-expression \terminal{[} expression \terminal{]}\br
    postfix-expression \terminal{(} expression-list\opt \terminal{)}\br
    simple-type-specifier \terminal{(} expression-list\opt \terminal{)}\br
    \terminal{typename} \terminal{::}\opt nested-name-specifier identifier
	\terminal{(} expression-list\opt \terminal{)}\br
    \terminal{typename} \terminal{::}\opt nested-name-specifier
	\terminal{template}\opt template-id
	\terminal{(} expression-list\opt \terminal{)}\br
    postfix-expression \terminal{. template}\opt id-expression\br
    postfix-expression \terminal{-> template}\opt id-expression\br
    postfix-expression \terminal{.} pseudo-destructor-name\br
    postfix-expression \terminal{->} pseudo-destructor-name\br
    postfix-expression \terminal{++}\br
    postfix-expression \terminal{-{-}}\br
    \terminal{dynamic_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{static_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{reinterpret_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{const_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{typeid (} expression \terminal{)}\br
    \terminal{typeid (} type-id \terminal{)}
\end{bnf}


\begin{bnf}
\nontermdef{expression-list}\br
    assignment-expression\br
    expression-list \terminal{,} assignment-expression
\end{bnf}


\begin{bnf}
\nontermdef{pseudo-destructor-name}\br
    \terminal{::}\opt nested-name-specifier\opt type-name \terminal{::\,\tilde} type-name\br
    \terminal{::}\opt nested-name-specifier \terminal{template} template-id \terminal{::\,\tilde} type-name\br
    \terminal{::}\opt nested-name-specifier\opt \terminal{\tilde} type-name
\end{bnf}


\begin{bnf}
\nontermdef{unary-expression}\br
    postfix-expression\br
    \terminal{++} cast-expression\br
    \terminal{-{-}} cast-expression\br
    unary-operator cast-expression\br
    \terminal{sizeof} unary-expression\br
    \terminal{sizeof (} type-id \terminal{)}\br
    new-expression\br
    delete-expression
\end{bnf}


\begin{bnf}
\nontermdef{unary-operator} \textnormal{one of}\br
    \terminal{*  \&  +  -  !  \tilde}
\end{bnf}


\begin{bnf}
\nontermdef{new-expression}\br
    \terminal{::}\opt \terminal{new} new-placement\opt new-type-id new-initializer\opt \br
    \terminal{::}\opt \terminal{new} new-placement\opt \terminal{(} type-id \terminal{)} new-initializer\opt
\end{bnf}


\begin{bnf}
\nontermdef{new-placement}\br
    \terminal{(} expression-list \terminal{)}
\end{bnf}


\begin{bnf}
\nontermdef{new-type-id}\br
    type-specifier-seq new-declarator\opt
\end{bnf}


\begin{bnf}
\nontermdef{new-declarator}\br
    ptr-operator new-declarator\opt \br
    direct-new-declarator
\end{bnf}


\begin{bnf}
\nontermdef{direct-new-declarator}\br
    \terminal{[} expression \terminal{]}\br
    direct-new-declarator \terminal{[} constant-expression \terminal{]}
\end{bnf}


\begin{bnf}
\nontermdef{new-initializer}\br
    \terminal{(} expression-list\opt \terminal{)}
\end{bnf}


\begin{bnf}
\nontermdef{delete-expression}\br
    \terminal{::}\opt \terminal{delete} cast-expression\br
    \terminal{::}\opt \terminal{delete [ ]} cast-expression
\end{bnf}


\begin{bnf}
\nontermdef{cast-expression}\br
    unary-expression\br
    \terminal{(} type-id \terminal{)} cast-expression
\end{bnf}


\begin{bnf}
\nontermdef{pm-expression}\br
    cast-expression\br
    pm-expression \terminal{.*} cast-expression\br
    pm-expression \terminal{->*} cast-expression
\end{bnf}


\begin{bnf}
\nontermdef{multiplicative-expression}\br
    pm-expression\br
    multiplicative-expression \terminal{*} pm-expression\br
    multiplicative-expression \terminal{/} pm-expression\br
    multiplicative-expression \terminal{\%} pm-expression
\end{bnf}


\begin{bnf}
\nontermdef{additive-expression}\br
    multiplicative-expression\br
    additive-expression \terminal{+} multiplicative-expression\br
    additive-expression \terminal{-} multiplicative-expression
\end{bnf}


\begin{bnf}
\nontermdef{shift-expression}\br
    additive-expression\br
    shift-expression \terminal{\shl} additive-expression\br
    shift-expression \terminal{\shr} additive-expression
\end{bnf}


\begin{bnf}
\nontermdef{relational-expression}\br
    shift-expression\br
    relational-expression \terminal{<} shift-expression\br
    relational-expression \terminal{>} shift-expression\br
    relational-expression \terminal{<=} shift-expression\br
    relational-expression \terminal{>=} shift-expression
\end{bnf}


\begin{bnf}
\nontermdef{equality-expression}\br
    relational-expression\br
    equality-expression \terminal{==} relational-expression\br
    equality-expression \terminal{!=} relational-expression
\end{bnf}


\begin{bnf}
\nontermdef{and-expression}\br
    equality-expression\br
    and-expression \terminal{\&} equality-expression
\end{bnf}


\begin{bnf}
\nontermdef{exclusive-or-expression}\br
    and-expression\br
    exclusive-or-expression \terminal{\^{}} and-expression
\end{bnf}


\begin{bnf}
\nontermdef{inclusive-or-expression}\br
    exclusive-or-expression\br
    inclusive-or-expression \terminal{|} exclusive-or-expression
\end{bnf}


\begin{bnf}
\nontermdef{logical-and-expression}\br
    inclusive-or-expression\br
    logical-and-expression \terminal{\&\&} inclusive-or-expression
\end{bnf}


\begin{bnf}
\nontermdef{logical-or-expression}\br
    logical-and-expression\br
    logical-or-expression \terminal{||} logical-and-expression
\end{bnf}


\begin{bnf}
\nontermdef{conditional-expression}\br
    logical-or-expression\br
    logical-or-expression \terminal{?} expression \terminal{:} assignment-expression
\end{bnf}


\begin{bnf}
\nontermdef{assignment-expression}\br
    conditional-expression\br
    logical-or-expression assignment-operator assignment-expression\br
    throw-expression
\end{bnf}


\begin{bnf}
\nontermdef{assignment-operator} \textnormal{one of}\br
    \terminal{=  *=  /=  \%=   +=  -=  \shr=  \shl=  \&=  \^{}=  |=}
\end{bnf}


\begin{bnf}
\nontermdef{expression}\br
    assignment-expression\br
    expression \terminal{,} assignment-expression
\end{bnf}


\begin{bnf}
\nontermdef{constant-expression}\br
    conditional-expression
\end{bnf}


\rSec1[gram.stmt.stmt]{Statements}

\begin{bnf}
\nontermdef{statement}\br
    labeled-statement\br
    expression-statement\br
    compound-statement\br
    selection-statement\br
    iteration-statement\br
    jump-statement\br
    declaration-statement\br
    try-block
\end{bnf}


\begin{bnf}
\nontermdef{labeled-statement}\br
    identifier \terminal{:} statement\br
    \terminal{case} constant-expression \terminal{:} statement\br
    \terminal{default :} statement
\end{bnf}


\begin{bnf}
\nontermdef{expression-statement}\br
    expression\opt \terminal{;}
\end{bnf}


\begin{bnf}
\nontermdef{compound-statement}\br
    \terminal{\{} statement-seq\opt \terminal{\}}
\end{bnf}


\begin{bnf}
\nontermdef{statement-seq}\br
    statement\br
    statement-seq statement
\end{bnf}


\begin{bnf}
\nontermdef{selection-statement}\br
    \terminal{if (} condition \terminal{)} statement\br
    \terminal{if (} condition \terminal{)} statement \terminal{else} statement\br
    \terminal{switch (} condition \terminal{)} statement
\end{bnf}


\begin{bnf}
\nontermdef{condition}\br
    expression\br
    type-specifier-seq declarator \terminal{=} assignment-expression
\end{bnf}


\begin{bnf}
\nontermdef{iteration-statement}\br
    \terminal{while (} condition \terminal{)} statement\br
    \terminal{do} statement \terminal{while (} expression \terminal{) ;}\br
    \terminal{for (} for-init-statement condition\opt \terminal{;} expression\opt \terminal{)} statement\br
\end{bnf}


\begin{bnf}
\nontermdef{for-init-statement}\br
    expression-statement\br
    simple-declaration
\end{bnf}


\begin{bnf}
\nontermdef{jump-statement}\br
    \terminal{break ;}\br
    \terminal{continue ;}\br
    \terminal{return} expression\opt \terminal{;}\br
    \terminal{goto} identifier \terminal{;}
\end{bnf}


\begin{bnf}
\nontermdef{declaration-statement}\br
    block-declaration
\end{bnf}


\rSec1[gram.dcl.dcl]{Declarations}

\begin{bnf}
\nontermdef{declaration-seq}\br
    declaration\br
    declaration-seq declaration
\end{bnf}


\begin{bnf}
\nontermdef{declaration}\br
    block-declaration\br
    function-definition\br
    template-declaration\br
    explicit-instantiation\br
    explicit-specialization\br
    linkage-specification\br
    namespace-definition
\end{bnf}


\begin{bnf}
\nontermdef{block-declaration}\br
    simple-declaration\br
    asm-definition\br
    namespace-alias-definition\br
    using-declaration\br
    using-directive
\end{bnf}


\begin{bnf}
\nontermdef{simple-declaration}\br
    decl-specifier-seq\opt init-declarator-list\opt \terminal{;}
\end{bnf}


\begin{bnf}
\nontermdef{decl-specifier}\br
    storage-class-specifier\br
    type-specifier\br
    function-specifier\br
    \terminal{friend}\br
    \terminal{typedef}
\end{bnf}


\begin{bnf}
\nontermdef{decl-specifier-seq}\br
    decl-specifier-seq\opt decl-specifier
\end{bnf}


\begin{bnf}
\nontermdef{storage-class-specifier}\br
    \terminal{auto}\br
    \terminal{register}\br
    \terminal{static}\br
    \terminal{extern}\br
    \terminal{mutable}
\end{bnf}


\begin{bnf}
\nontermdef{function-specifier}\br
    \terminal{inline}\br
    \terminal{virtual}\br
    \terminal{explicit}
\end{bnf}


\begin{bnf}
\nontermdef{typedef-name}\br
    identifier
\end{bnf}


\begin{bnf}
\nontermdef{type-specifier}\br
    simple-type-specifier\br
    class-specifier\br
    enum-specifier\br
    elaborated-type-specifier\br
    cv-qualifier
\end{bnf}


\begin{bnf}
\nontermdef{simple-type-specifier}\br
    \terminal{::}\opt nested-name-specifier\opt type-name\br
    \terminal{::}\opt nested-name-specifier \terminal{template} template-id\br
    \terminal{char}\br
    \terminal{wchar_t}\br
    \terminal{bool}\br
    \terminal{short}\br
    \terminal{int}\br
    \terminal{long}\br
    \terminal{signed}\br
    \terminal{unsigned}\br
    \terminal{float}\br
    \terminal{double}\br
    \terminal{void}
\end{bnf}


\begin{bnf}
\nontermdef{type-name}\br
    class-name\br
    enum-name\br
    typedef-name
\end{bnf}


\begin{bnf}
\nontermdef{elaborated-type-specifier}\br
    class-key \terminal{::}\opt nested-name-specifier\opt identifier\br
    class-key \terminal{::}\opt nested-name-specifier\opt \terminal{template}\opt template-id\br
    \terminal{enum} \terminal{::}\opt nested-name-specifier\opt identifier\br
    typename \terminal{::}\opt nested-name-specifier identifier\br
    typename \terminal{::}\opt nested-name-specifier \terminal{template}\opt template-id
\end{bnf}


\begin{bnf}
\nontermdef{enum-name}\br
    identifier
\end{bnf}


\begin{bnf}
\nontermdef{enum-specifier}\br
    \terminal{enum} identifier\opt \terminal{\{} enumerator-list\opt \terminal{\}}
\end{bnf}


\begin{bnf}
\nontermdef{enumerator-list}\br
    enumerator-definition\br
    enumerator-list \terminal{,} enumerator-definition
\end{bnf}


\begin{bnf}
\nontermdef{enumerator-definition}\br
    enumerator\br
    enumerator \terminal{=} constant-expression
\end{bnf}


\begin{bnf}
\nontermdef{enumerator}\br
    identifier
\end{bnf}


\begin{bnf}
\nontermdef{namespace-name}\br
        original-namespace-name\br
        namespace-alias
\end{bnf}


\begin{bnf}
\nontermdef{original-namespace-name}\br
        identifier
\end{bnf}


\begin{bnf}
\nontermdef{namespace-definition}\br
        named-namespace-definition\br
        unnamed-namespace-definition
\end{bnf}


\begin{bnf}
\nontermdef{named-namespace-definition}\br
        original-namespace-definition\br
        extension-namespace-definition
\end{bnf}


\begin{bnf}
\nontermdef{original-namespace-definition}\br
        \terminal{namespace} identifier \terminal{\{} namespace-body \terminal{\}}
\end{bnf}


\begin{bnf}
\nontermdef{extension-namespace-definition}\br
        \terminal{namespace} original-namespace-name \terminal{\{} namespace-body \terminal{\}}
\end{bnf}


\begin{bnf}
\nontermdef{unnamed-namespace-definition}\br
        \terminal{namespace \{} namespace-body \terminal{\}}
\end{bnf}


\begin{bnf}
\nontermdef{namespace-body}\br
        declaration-seq\opt
\end{bnf}


\begin{bnf}
\nontermdef{namespace-alias}\br
        identifier
\end{bnf}


\begin{bnf}
\nontermdef{namespace-alias-definition}\br
        \terminal{namespace} identifier \terminal{=} qualified-namespace-specifier \terminal{;}
\end{bnf}


\begin{bnf}
\nontermdef{qualified-namespace-specifier}\br
	\terminal{::}\opt nested-name-specifier\opt namespace-name
\end{bnf}


\begin{bnf}
\nontermdef{using-declaration}\br
    \terminal{using typename\opt ::\opt} nested-name-specifier unqualified-id \terminal{;}\br
    \terminal{using ::} unqualified-id \terminal{;}
\end{bnf}


\begin{bnf}
\nontermdef{using-directive}\br
    \terminal{using  namespace ::\opt} nested-name-specifier\opt namespace-name \terminal{;}
\end{bnf}


\begin{bnf}
\nontermdef{asm-definition}\br
    \terminal{asm (} string-literal \terminal{) ;}
\end{bnf}


\begin{bnf}
\nontermdef{linkage-specification}\br
    \terminal{extern} string-literal \terminal{\{} declaration-seq\opt \terminal{\}}\br
    \terminal{extern} string-literal declaration
\end{bnf}


\rSec1[gram.dcl.decl]{Declarators}

\begin{bnf}
\nontermdef{init-declarator-list}\br
    init-declarator\br
    init-declarator-list \terminal{,} init-declarator
\end{bnf}


\begin{bnf}
\nontermdef{init-declarator}\br
    declarator initializer\opt
\end{bnf}


\begin{bnf}
\nontermdef{declarator}\br
    direct-declarator\br
    ptr-operator declarator
\end{bnf}


\begin{bnf}
\nontermdef{direct-declarator}\br
    declarator-id\br
    direct-declarator \terminal{(} parameter-declaration-clause \terminal{)}
	cv-qualifier-seq\opt exception-specification\opt\br
    direct-declarator \terminal{[} constant-expression\opt \terminal{]}\br
    \terminal{(} declarator \terminal{)}
\end{bnf}


\begin{bnf}
\nontermdef{ptr-operator}\br
    \terminal{*} cv-qualifier-seq\opt\br
    \terminal{\&} \br
    \terminal{::}\opt nested-name-specifier \terminal{*} cv-qualifier-seq\opt
\end{bnf}


\begin{bnf}
\nontermdef{cv-qualifier-seq}\br
    cv-qualifier cv-qualifier-seq\opt
\end{bnf}


\begin{bnf}
\nontermdef{cv-qualifier}\br
    \terminal{const}\br
    \terminal{volatile}
\end{bnf}


\begin{bnf}
\nontermdef{declarator-id}\br
    id-expression\br
    \terminal{::}\opt nested-name-specifier\opt type-name
\end{bnf}


\begin{bnf}
\nontermdef{type-id}\br
    type-specifier-seq abstract-declarator\opt
\end{bnf}


\begin{bnf}
\nontermdef{type-specifier-seq}\br
    type-specifier type-specifier-seq\opt
\end{bnf}


\begin{bnf}
\nontermdef{abstract-declarator}\br
    ptr-operator abstract-declarator\opt\br
    direct-abstract-declarator
\end{bnf}


\begin{bnftab}
\nontermdef{direct-abstract-declarator}\br
    \>direct-abstract-declarator\opt\br
	\>\>\terminal{(} parameter-declaration-clause \terminal{)}
	cv-qualifier-seq\opt exception-specification\opt\br
    \>direct-abstract-declarator\opt \terminal{[} constant-expression\opt{} \terminal{]}\br
    \>\terminal{(} abstract-declarator \terminal{)}
\end{bnftab}


\begin{bnf}
\nontermdef{parameter-declaration-clause}\br
    parameter-declaration-list\opt \terminal{...}\opt\br
    parameter-declaration-list \terminal{,} \terminal{...}
\end{bnf}


\begin{bnf}
\nontermdef{parameter-declaration-list}\br
    parameter-declaration\br
    parameter-declaration-list \terminal{,} parameter-declaration
\end{bnf}


\begin{bnf}
\nontermdef{parameter-declaration}\br
    decl-specifier-seq declarator\br
    decl-specifier-seq declarator \terminal{=} assignment-expression\br
    decl-specifier-seq abstract-declarator\opt\br
    decl-specifier-seq abstract-declarator\opt \terminal{=} assignment-expression
\end{bnf}


\begin{bnf}
\nontermdef{function-definition}\br
    decl-specifier-seq\opt declarator ctor-initializer\opt function-body\br
    decl-specifier-seq\opt declarator function-try-block
\end{bnf}


\begin{bnf}
function-body:\br
    compound-statement
\end{bnf}


\begin{bnf}
\nontermdef{initializer}\br
    \terminal{=} initializer-clause\br
    \terminal{(} expression-list \terminal{)}
\end{bnf}


\begin{bnf}
\nontermdef{initializer-clause}\br
    assignment-expression\br
    \terminal{\{} initializer-list \terminal{,\opt} \terminal{\}}\br
    \terminal{\{} \terminal{\}}
\end{bnf}


\begin{bnf}
\nontermdef{initializer-list}\br
    initializer-clause\br
    initializer-list \terminal{,} initializer-clause
\end{bnf}


\rSec1[gram.class]{Classes}

\begin{bnf}
\nontermdef{class-name}\br
    identifier\br
    template-id
\end{bnf}


\begin{bnf}
\nontermdef{class-specifier}\br
    class-head \terminal{\{} member-specification\opt \terminal{\}}
\end{bnf}


\begin{bnf}
\nontermdef{class-head}\br
    class-key identifier\opt base-clause\opt\br
    class-key nested-name-specifier identifier base-clause\opt\br
    class-key nested-name-specifier\opt template-id base-clause\opt
\end{bnf}


\begin{bnf}
\nontermdef{class-key}\br
    \terminal{class}\br
    \terminal{struct}\br
    \terminal{union}
\end{bnf}


\begin{bnf}
\nontermdef{member-specification}\br
    member-declaration member-specification\opt\br
    access-specifier \terminal{:} member-specification\opt
\end{bnf}


\begin{bnf}
\nontermdef{member-declaration}\br
    decl-specifier-seq\opt member-declarator-list\opt \terminal{;}\br
    function-definition \terminal{;\opt}\br
    \terminal{::}\opt nested-name-specifier \terminal{template}\opt unqualified-id \terminal{;}\br
    using-declaration\br
    template-declaration
\end{bnf}


\begin{bnf}
\nontermdef{member-declarator-list}\br
    member-declarator\br
    member-declarator-list \terminal{,} member-declarator
\end{bnf}


\begin{bnf}
\nontermdef{member-declarator}\br
    declarator pure-specifier\opt\br
    declarator constant-initializer\opt\br
    identifier\opt \terminal{:} constant-expression
\end{bnf}


\begin{bnf}
\nontermdef{pure-specifier}\br
    \terminal{= 0}
\end{bnf}


\begin{bnf}
\nontermdef{constant-initializer}\br
    \terminal{=} constant-expression
\end{bnf}


\rSec1[gram.class.derived]{Derived classes}

\begin{bnf}
\nontermdef{base-clause}\br
    \terminal{:} base-specifier-list
\end{bnf}


\begin{bnf}
\nontermdef{base-specifier-list}\br
    base-specifier\br
    base-specifier-list \terminal{,} base-specifier
\end{bnf}


\begin{bnf}
\nontermdef{base-specifier}\br
    \terminal{::}\opt nested-name-specifier\opt class-name\br
    \terminal{virtual} access-specifier\opt \terminal{::}\opt nested-name-specifier\opt class-name\br
    access-specifier \terminal{virtual}\opt \terminal{::}\opt nested-name-specifier\opt class-name
\end{bnf}


\begin{bnf}
\nontermdef{access-specifier}\br
    \terminal{private}\br
    \terminal{protected}\br
    \terminal{public}
\end{bnf}


\rSec1[gram.special]{Special member functions}

\begin{bnf}
\nontermdef{conversion-function-id}\br
    \terminal{operator} conversion-type-id
\end{bnf}


\begin{bnf}
\nontermdef{conversion-type-id}\br
    type-specifier-seq conversion-declarator\opt
\end{bnf}


\begin{bnf}
\nontermdef{conversion-declarator}\br
    ptr-operator conversion-declarator\opt
\end{bnf}


\begin{bnf}
\nontermdef{ctor-initializer}\br
    \terminal{:} mem-initializer-list
\end{bnf}


\begin{bnf}
\nontermdef{mem-initializer-list}\br
    mem-initializer\br
    mem-initializer \terminal{,} mem-initializer-list
\end{bnf}


\begin{bnf}
\nontermdef{mem-initializer}\br
    mem-initializer-id \terminal{(} expression-list\opt \terminal{)}
\end{bnf}


\begin{bnf}
\nontermdef{mem-initializer-id}\br
    \terminal{::}\opt nested-name-specifier\opt class-name\br
    identifier
\end{bnf}


\rSec1[gram.over]{Overloading}

\begin{bnf}
\nontermdef{operator-function-id}\br
    \terminal{operator} operator\br
    \terminal{operator} operator \terminal{<} template-argument-list\opt \terminal{>}
\end{bnf}


\begin{bnfkeywordtab}
\nontermdef{operator} \textnormal{one of}\br
\>new\>delete\>new[]\>delete[]\br
\>+\>-\>*\>/\>\%\>\^{}\>\&\>|\>$\sim$\br
\>!\>=\><\>>\>+=\>-=\>*=\>/=\>\%=\br
\>\^{}=\>\&=\>|=\>\shl\>\shr\>\shr=\>\shl=\>={=}\>!=\br
\><=\>>=\>\&\&\>|{|}\>++\>-{-}\>,\>->*\>->\br
\>(\,)\>[\,]
\end{bnfkeywordtab}

\rSec1[gram.temp]{Templates}

\begin{bnf}
\nontermdef{template-declaration}\br
  \terminal{export}\opt \terminal{template <} template-parameter-list \terminal{>} declaration
\end{bnf}


\begin{bnf}
\nontermdef{template-parameter-list}\br
  template-parameter\br
  template-parameter-list \terminal{,} template-parameter
\end{bnf}


\begin{bnf}
\nontermdef{template-parameter}\br
  type-parameter\br
  parameter-declaration
\end{bnf}


\begin{bnf}
\nontermdef{type-parameter}\br
  \terminal{class} identifier\opt\br
  \terminal{class} identifier\opt \terminal{=} type-id\br
  \terminal{typename} identifier\opt\br
  \terminal{typename} identifier\opt \terminal{=} type-id\br
  \terminal{template <} template-parameter-list \terminal{> class} identifier\opt\br
  \terminal{template <} template-parameter-list \terminal{> class} identifier\opt \terminal{=} id-expression
\end{bnf}


\begin{bnf}
\nontermdef{template-id}\br
  template-name \terminal{<} template-argument-list\opt \terminal{>}
\end{bnf}


\begin{bnf}
\nontermdef{template-name}\br
  identifier
\end{bnf}


\begin{bnf}
\nontermdef{template-argument-list}\br
  template-argument\br
  template-argument-list \terminal{,} template-argument
\end{bnf}


\begin{bnf}
\nontermdef{template-argument}\br
  assignment-expression\br
  type-id\br
  id-expression
\end{bnf}


\begin{bnf}
\nontermdef{explicit-instantiation}\br
  \terminal{template} declaration
\end{bnf}


\begin{bnf}
\nontermdef{explicit-specialization}\br
  \terminal{template < >} declaration
\end{bnf}


\rSec1[gram.except]{Exception handling}

\begin{bnf}
\nontermdef{try-block}\br
    \terminal{try} compound-statement handler-seq
\end{bnf}


\begin{bnf}
\nontermdef{function-try-block}\br
    \terminal{try} ctor-initializer\opt function-body handler-seq
\end{bnf}


\begin{bnf}
\nontermdef{handler-seq}\br
    handler handler-seq\opt
\end{bnf}


\begin{bnf}
\nontermdef{handler}\br
    \terminal{catch (} exception-declaration \terminal{)} compound-statement
\end{bnf}


\begin{bnf}
\nontermdef{exception-declaration}\br
    type-specifier-seq declarator\br
    type-specifier-seq abstract-declarator\br
    type-specifier-seq\br
    \terminal{...}
\end{bnf}


\begin{bnf}
\nontermdef{throw-expression}\br
    \terminal{throw}  assignment-expression\opt
\end{bnf}


\begin{bnf}
\nontermdef{exception-specification}\br
    \terminal{throw (} type-id-list\opt \terminal{)}
\end{bnf}


\begin{bnf}
\nontermdef{type-id-list}\br
    type-id\br
    type-id-list \terminal{,} type-id
\end{bnf}


\rSec1[gram.cpp]{Preprocessing directives}

\begin{bnf}
\nontermdef{preprocessing-file}\br
    group\opt
\end{bnf}


\begin{bnf}
\nontermdef{group}\br
    group-part\br
    group group-part
\end{bnf}


\begin{bnf}
\nontermdef{group-part}\br
    pp-tokens\opt new-line\br
    if-section\br
    control-line
\end{bnf}


\begin{bnf}
\nontermdef{if-section}\br
    if-group elif-groups\opt else-group\opt endif-line
\end{bnf}


\begin{bnftab}
\nontermdef{if-group}\br
\>\terminal{\# if}\>\>constant-expression new-line group\opt\br
\>\terminal{\# ifdef}\>\>identifier new-line group\opt\br
\>\terminal{\# ifndef}\>\>identifier new-line group\opt
\end{bnftab}


\begin{bnf}
\nontermdef{elif-groups}\br
    elif-group\br
    elif-groups elif-group
\end{bnf}


\begin{bnftab}
\nontermdef{elif-group}\br
\>\terminal{\# elif}\>\>constant-expression new-line group\opt
\end{bnftab}


\begin{bnftab}
\nontermdef{else-group}\br
\>\terminal{\# else}\>\>new-line group\opt
\end{bnftab}


\begin{bnftab}
\nontermdef{endif-line}\br
\>\terminal{\# endif}\>\>new-line
\end{bnftab}


\begin{bnftab}
\nontermdef{control-line}\br
\>\terminal{\# include}\>\>pp-tokens new-line\br
\>\terminal{\# define}\>\>identifier replacement-list new-line\br
\>\terminal{\# define}\>\>identifier lparen identifier-list\opt \terminal{)} replacement-list new-line\br
\>\terminal{\# undef}\>\>identifier new-line\br
\>\terminal{\# line}\>\>pp-tokens new-line\br
\>\terminal{\# error}\>\>pp-tokens\opt new-line\br
\>\terminal{\# pragma}\>\>pp-tokens\opt new-line\br
\>\terminal{\# }\>\>new-line
\end{bnftab}


\begin{bnf}
\nontermdef{lparen}\br
    \descr{the left-parenthesis character without preceding white-space}
\end{bnf}


\begin{bnf}
\nontermdef{replacement-list}\br
    pp-tokens\opt
\end{bnf}


\begin{bnf}
\nontermdef{pp-tokens}\br
    preprocessing-token\br
    pp-tokens preprocessing-token
\end{bnf}


\begin{bnf}
\nontermdef{new-line}\br
    \descr{the new-line character}
\end{bnf}


