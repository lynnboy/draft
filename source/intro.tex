\rSec0[intro]{General}

\indextext{diagnostic message|see{message, diagnostic}}%
\indextext{dynamic type|see{type, dynamic}}%
\indextext{static type|see{type, static}}%
\indextext{ill-formed program|see{program, ill-formed}}%
\indextext{well-formed program|see{program, well-formed}}%
\indextext{implementation-defined behavior|see{behavior, implemen\-tation-defined}}%
\indextext{undefined behavior|see{behavior, undefined}}%
\indextext{unspecified behavior|see{behavior, unspecified}}%
\indextext{implementation limits|see{limits, implementation}}%
\indextext{locale-specific behavior|see{behavior, locale-specific}}%
\indextext{multibyte character|see{character, multibyte}}%
\indextext{object|seealso{object model}}%
\indextext{subobject|seealso{object model}}%
\indextext{derived class!most|see{most derived class}}%
\indextext{derived object!most|see{most derived object}}%
\indextext{program execution!as-if rule|see{as-if~rule}}%
\indextext{observable behavior|see{behavior, observable}}%
\indextext{precedence of operator|see{operator, precedence of}}%
\indextext{order of evaluation in expression|see{expression, order of evaluation of}}%
\indextext{normative references|see{references, normative}}

\rSec1[intro.scope]{Scope}

\pnum
\indextext{scope|(}%
This International Standard specifies requirements for implementations
of the \Cpp programming language. The first such requirement is that
they implement the language, and so this International Standard also
defines \Cpp. Other requirements and relaxations of the first
requirement appear at various places within this International Standard.

\pnum
\Cpp is a general purpose programming language based on the C
programming language as specified in ISO/IEC 9899:1990,
\doccite{Programming languages -- C} (\ref{intro.refs}). In addition to
the facilities provided by C, \Cpp provides additional data types,
classes, templates, exceptions, namespaces, inline functions, operator
overloading, function name overloading, references, free store
management operators, and additional library facilities.%
\indextext{scope|)}

\rSec1[intro.refs]{Normative references}

\pnum
\indextext{references!normative|(}%
The following referenced documents are indispensable for the application
of this document. For dated references, only the edition cited applies.
For undated references, the latest edition of the referenced document
(including any amendments) applies.

ISO/IEC 2382 (all parts), \doccite{Information technology --
Vocabulary}

ISO/IEC 9899:1999, \doccite{Programming languages -- C}

ISO/IEC 10646-1:2000, \doccite{Information technology --
Universal Multiple-Octet Coded Character Set (UCS) -- Part 1:
Architecture and Basic Multilingual Plane}

\pnum
The library described in clause 7 of ISO/IEC 9899:1990 and clause 7 of
ISO/IEC 9899:1999/Amd.1:1995 is hereinafter called the
\indexdefn{C!standard library}\term{Standard C
library}.\footnote{With the qualifications noted in clauses~\ref{lib.library}
through~\ref{\lastlibchapter}, and in~\ref{diff.library}, the Standard
C library is a subset of the Standard \Cpp library.}
\indextext{references!normative|)}

\rSec1[intro.defs]{Terms et definitions}

\indextext{definitions|(}%
For the purposes of this document, the definitions given in
ISO/IEC 2382 and the following apply.
\ref{lib.definitions}
defines additional terms that are used only in clauses~\ref{lib.library}
through~\ref{\lastlibchapter}.

\pnum
Terms that are used only in a small portion of this International
Standard are defined where they are used and italicized where they are
defined.

\indexdefn{argument}%
\indexdefn{argument!function call expression}
\indexdefn{argument!function-like macro}%
\indexdefn{argument!throw expression}%
\indexdefn{argument!template instantiation}%
\definition{argument}{defns.argument}
an expression in the comma-separated list bounded by the parentheses
in a function call expression,
a sequence of preprocessing tokens in the
comma-separated list bounded by the parentheses in a
function-like macro invocation,
the operand of \tcode{throw},
or an expression,
\grammarterm{type-id}  or \grammarterm{template-name} in the comma-separated
list bounded by the angle brackets in a template instantiation.
Also known as an
\defn{actual argument} or
\defn{actual parameter}.

\indexdefn{message!diagnostic}%
\definition{diagnostic message}{defns.diagnostic}
a message belonging to an \impldef{diagnostic message} subset of the
implementation's output messages.

\indexdefn{type!dynamic}%
\definition{dynamic type}{defns.dynamic.type}
the type of the most derived object~(\ref{intro.object}) to which the
lvalue denoted by an lvalue expression refers.
\enterexample
if a pointer~(\ref{dcl.ptr}) \tcode{p} whose static type is ``pointer to
class \tcode{B}'' is pointing to an object of class \tcode{D}, derived
from \tcode{B} (clause~\ref{class.derived}), the dynamic type of the
expression \tcode{*p} is ``\tcode{D}.'' References~(\ref{dcl.ref}) are
treated similarly.
\exitexample
The dynamic type of an rvalue expression is its static type.

\indexdefn{program!ill-formed}%
\definition{ill-formed program}{defns.ill.formed}
input to a \Cpp implementation that is not a
well-formed program~(\ref{defns.well.formed}).

\indexdefn{behavior!implementation-defined}%
\definition{implementation-defined behavior}{defns.impl.defined}
behavior, for a well-formed program construct and correct data, that
depends on the implementation and that each implementation shall document.

\indexdefn{limits!implementation}%
\definition{implementation limits}{defns.impl.limits}
restrictions imposed upon programs by the implementation.

\indexdefn{behavior!locale-specific}%
\definition{locale-specific behavior}{defns.locale.specific}
behavior that depends on local conventions of nationality, culture, and
language that each implementation shall document.

\indexdefn{character!multibyte}%
\definition{multibyte character}{defns.multibyte}
a sequence of one or more bytes representing a member of the extended
character set of either the source or the execution environment.
The extended character set is a superset of the basic character
set~(\ref{lex.charset}).

\indexdefn{parameter}%
\indexdefn{parameter!function}%
\indexdefn{parameter!catch clause}%
\indexdefn{parameter!function-like macro}%
\indexdefn{parameter!template}%
\definition{parameter}{defns.parameter}
an object or reference declared as part of a function declaration or
definition, or in the catch clause of an exception handler, that
acquires a value on entry to the function or handler;
an identifier from
the comma-separated list bounded by the parentheses immediately
following the macro name in a function-like macro definition; or
a \grammarterm{template-parameter}.
Parameters are also known as
\defn{formal arguments} or
\defn{formal parameters}.

\indexdefn{signature}%
\definition{signature}{defns.signature}
the information about a function that participates in
overload resolution~(\ref{over.match}): the types of its parameters and,
if the function is a class member, the \cv- qualifiers (if any) on the function
itself and the class in which the member function is declared.\footnote{
Function signatures do not include return type, because that does not
participate in overload resolution.}
The signature of a function template specialization includes the types of
its template arguments~(\ref{temp.over.link}).

\indexdefn{type!static}%
\definition{static type}{defns.static.type}
the type of an expression~(\ref{basic.types}), which type results from
analysis of the program without considering execution semantics.
The static type of an expression depends only on the form of the program in
which the expression appears, and does not change while the program is
executing.

\indexdefn{behavior!undefined}%
\definition{undefined behavior}{defns.undefined}
behavior, such as might arise upon use of an erroneous program construct
or erroneous data, for which this International Standard
imposes no requirements.
Undefined behavior may also be expected when
this International Standard omits the description of any explicit
definition of behavior.
\enternote permissible undefined behavior ranges
from ignoring the situation completely with unpredictable results, to
behaving during translation or program execution in a documented manner
characteristic of the environment (with or without the issuance of a
diagnostic message), to terminating a translation or execution (with the
issuance of a diagnostic message). Many erroneous program constructs do
not engender undefined behavior; they are required to be diagnosed.
\exitnote

\indexdefn{behavior!unspecified}%
\definition{unspecified behavior}{defns.unspecified}
behavior, for a well-formed program construct and correct data, that
depends on the implementation.
The implementation is not required to document which behavior occurs.
\enternote usually, the range of
possible behaviors is delineated by this International Standard.
\exitnote

\indexdefn{program!well-formed}%
\definition{well-formed program}{defns.well.formed}
a \Cpp program constructed according to the syntax rules, diagnosable
semantic rules, and the One Definition Rule~(\ref{basic.def.odr}).%
\indextext{definitions|)}

\rSec1[intro.compliance]{Implementation compliance}

\pnum
\indextext{conformance requirements|(}%
\indextext{conformance requirements!general|(}%
The set of
\defn{diagnosable rules}
consists of all syntactic and semantic rules in this International
Standard except for those rules containing an explicit notation that
``no diagnostic is required'' or which are described as resulting in
``undefined behavior.''

\pnum
\indextext{conformance requirements!method of description}%
Although this International Standard states only requirements on \Cpp
implementations, those requirements are often easier to understand if
they are phrased as requirements on programs, parts of programs, or
execution of programs. Such requirements have the following meaning:
\begin{itemize}

\item
If a program contains no violations of the rules in this
International Standard, a conforming implementation shall,
within its resource limits, accept and correctly execute\footnote{``Correct execution'' can include undefined behavior, depending on
the data being processed; see~\ref{intro.defs} and~\ref{intro.execution}.}
that program.

\item
\indextext{message!diagnostic}%
If a program contains a violation of any diagnosable rule,
a conforming implementation
shall issue at least one diagnostic message, except that

\item
\indextext{behavior!undefined}%
If a program contains a violation of a rule for which no diagnostic
is required, this International Standard places no requirement on
implementations with respect to that program.

\end{itemize}

\pnum
\indextext{conformance requirements!library|(}%
\indextext{conformance requirements!classes}%
\indextext{conformance requirements!class templates}%
For classes and class templates, the library clauses specify partial
definitions. Private members~(clause~\ref{class.access}) are not
specified, but each implementation shall supply them to complete the
definitions according to the description in the library clauses.

\pnum
For functions, function templates, objects, and values, the library
clauses specify declarations. Implementations shall supply definitions
consistent with the descriptions in the library clauses.

\pnum
The names defined in the library have namespace
scope~(\ref{basic.namespace}). A \Cpp  translation
unit~(\ref{lex.phases}) obtains access to these names by including the
appropriate standard library header~(\ref{cpp.include}).

\pnum
The templates, classes, functions, and objects in the library have
external linkage~(\ref{basic.link}). The implementation provides
definitions for standard library entities, as necessary, while combining
translation units to form a complete \Cpp  program~(\ref{lex.phases}).%
\indextext{conformance requirements!library|)}

\pnum
Two kinds of implementations are defined: \defn{hosted} and
\defn{freestanding}. For a hosted implementation, this
International Standard defines the set of available libraries. A freestanding
implementation is one in which execution may take place without the benefit of
an operating system, and has an \impldef{required libraries for freestanding
implementation} set of libraries that includes certain language-support
libraries~(\ref{lib.compliance}).

\pnum
A conforming implementation may have extensions (including
additional library functions), provided they do not alter the
behavior of any well-formed program.
Implementations are required to diagnose programs that use such
extensions that are ill-formed according to this International Standard.
Having done so, however, they can compile and execute such programs.
\indextext{conformance requirements!general|)}%
\indextext{conformance requirements|)}%

\rSec1[intro.structure]{Structure of this International Standard}

\pnum
\indextext{standard!structure of|(}%
\indextext{standard!structure of}%
Clauses~\ref{lex} through~\ref{cpp} describe the \Cpp  programming
language. That description includes detailed syntactic specifications in
a form described in~\ref{syntax}. For convenience, Annex~\ref{gram}
repeats all such syntactic specifications.

\pnum
Clauses~\ref{lib.library} through~\ref{\lastlibchapter}
(the \defn{library clauses}) describe the Standard \Cpp  library,
which provides definitions for the following kinds of entities:
macros~(\ref{cpp.replace}), values (clause~\ref{basic}),
types~(\ref{dcl.name}, \ref{dcl.meaning}),
templates (clause~\ref{temp}), classes (clause~\ref{class}),
functions~(\ref{dcl.fct}), and objects (clause~\ref{dcl.dcl}).

\pnum
Annex~\ref{limits} recommends lower bounds on the capacity of conforming
implementations.

\pnum
Annex~\ref{diff} summarizes the evolution of \Cpp  since its first
published description, and explains in detail the differences between
\Cpp  and C. Certain features of \Cpp  exist solely for compatibility
purposes; Annex~\ref{depr} describes those features.

\pnum
Finally, Annex~\ref{extendid} says what characters are valid in
universal-character names in \Cpp identifiers~(\ref{lex.name}).

\pnum
Throughout this International Standard, each example is introduced by
``\enterexample'' and terminated by ``\exitexample''. Each note is
introduced by ``\enternote'' and terminated by ``\exitnote''. Examples
and notes may be nested.%
\indextext{standard!structure of|)}

\rSec1[syntax]{Syntax notation}

\pnum
\indextext{notation!syntax|(}%
In the syntax notation used in this International Standard, syntactic
categories are indicated by \grammarterm{italic} type, and literal words
and characters in \tcode{constant width} type. Alternatives are
listed on separate lines except in a few cases where a long set of
alternatives is presented on one line, marked by the phrase ``one of.''
An optional terminal or nonterminal symbol is indicated by the subscript
``\opt'', so

\begin{ncbnf}
\terminal{\{} expression\opt \terminal{\}}
\end{ncbnf}

indicates an optional expression enclosed in braces.%

\pnum
Names for syntactic categories have generally been chosen according to
the following rules:
\begin{itemize}
\item \grammarterm{X-name} is a use of an identifier in a context that
determines its meaning (e.g., \grammarterm{class-name},
\grammarterm{typedef-name}).
\item \grammarterm{X-id} is an identifier with no context-dependent meaning
(e.g., \grammarterm{qualified-id}).
\item \grammarterm{X-seq} is one or more \grammarterm{X}'s without intervening
delimiters (e.g., \grammarterm{declaration-seq} is a sequence of
declarations).
\item \grammarterm{X-list} is one or more \grammarterm{X}'s separated by
intervening commas (e.g., \grammarterm{expression-list} is a sequence of
expressions separated by commas).
\end{itemize}%
\indextext{notation!syntax|)}

\rSec1[intro.memory]{The \Cpp memory model}

\pnum
\indextext{memory model|(}%
The fundamental storage unit in the \Cpp memory model is the
\defn{byte}.
A byte is at least large enough to contain any member of the basic
\indextext{character set!basic execution}%
execution character set and is composed of a contiguous sequence of
bits, the number of which is \impldef{bits in a byte}. The least
significant bit is called the \defn{low-order} bit; the most
significant bit is called the \defn{high-order} bit. The memory
available to a \Cpp program consists of one or more sequences of
contiguous bytes. Every byte has a unique address.

\pnum
\enternote the representation of types is described
in~\ref{basic.types}. \exitnote

\indextext{memory model|)}

\rSec1[intro.object]{The \Cpp object model}

\pnum
\indextext{object model|(}%
\indextext{object}%
The constructs in a \Cpp program create, destroy, refer to, access, and
manipulate objects. An \defn{object} is a region of storage.
\enternote A function is not an object, regardless of whether or not it
occupies storage in the way that objects do. \exitnote An object is
created by a \grammarterm{definition}~(\ref{basic.def}), by a
\grammarterm{new-expression}~(\ref{expr.new}) or by the
implementation~(\ref{class.temporary}) when needed. The properties of an
object are determined when the object is created. An object can have a
\grammarterm{name}~(clause~\ref{basic}). An object has a \term{storage
duration}~(\ref{basic.stc}) which influences its
\term{lifetime}~(\ref{basic.life}). An object has a
\term{type}~(\ref{basic.types}). The term \defn{object type} refers to
the type with which the object is created.
Some objects are
\term{polymorphic}~(\ref{class.virtual}); the implementation
generates information associated with each such object that makes it
possible to determine that object's type during program execution. For
other objects, the interpretation of the values found therein is
determined by the type of the \grammarterm{expression}{s} (clause~\ref{expr})
used to access them.

\pnum
\indextext{sub-object}%
Objects can contain other objects, called \defnx{sub-objects}{sub-object}.
A sub-object can be
a \defn{member sub-object}~(\ref{class.mem}), a \defn{base class sub-object}
(clause~\ref{class.derived}), or an array element.
\indextext{object!complete}%
An object that is not a sub-object of any other object is called a \defn{complete
object}.

\pnum
For every object \tcode{x}, there is some object called
\defn{the complete object of} \tcode{x}, determined as follows:

\begin{itemize}

\item
If \tcode{x} is a complete object, then \tcode{x} is the complete
object of \tcode{x}.

\item
Otherwise, the complete object of \tcode{x} is the complete object
of the (unique) object that contains \tcode{x}.

\end{itemize}

\pnum
If a complete object, a data member~(\ref{class.mem}), or an array element is of
class type, its type is considered the \defn{most derived}
class, to distinguish it from the class type of any base class subobject;
an object of a most derived class type is called a
\defn{most derived object}.

\pnum
\indextext{most derived object!bit-field}%
Unless it is a bit-field~(\ref{class.bit}), a most derived object shall have a
non-zero size and shall occupy one or more bytes of storage. Base class
sub-objects may have zero size. An object of POD\footnote{The acronym POD stands for ``plain old data.''}
type~(\ref{basic.types}) shall occupy contiguous bytes of
storage.

\pnum
\enternote 
\Cpp  provides a variety of built-in types and several ways of composing
new types from existing types~(\ref{basic.types}).
\exitnote%
\indextext{object model|)}

\rSec1[intro.execution]{Program execution}

\pnum
\indextext{program execution|(}%
\indextext{program execution!abstract machine|(}%
The semantic descriptions in this International Standard define a
parameterized nondeterministic abstract machine. This International
Standard places no requirement on the structure of conforming
implementations. In particular, they need not copy or emulate the
structure of the abstract machine.
\indextext{as-if~rule}%
\indextext{behavior!observable}%
Rather, conforming implementations are required to emulate (only) the observable
behavior of the abstract machine as explained below.\footnote{This provision is
sometimes called the ``as-if'' rule, because an implementation is free to
disregard any requirement of this International Standard as long as the result
is \emph{as if} the requirement had been obeyed, as far as can be determined
from the observable behavior of the program. For instance, an actual
implementation need not evaluate part of an expression if it can deduce that its
value is not used and that no
\indextext{side effects}%
side effects affecting the
observable behavior of the program are produced.}

\indextext{behavior!implementation-defined}%
\pnum
Certain aspects and operations of the abstract machine are described in this
International Standard as implementation-defined (for example,
\tcode{sizeof(int)}). These constitute the parameters of the abstract machine.
Each implementation shall include documentation describing its characteristics
and behavior in these respects. Such documentation shall define the instance of the
abstract machine that corresponds to that implementation (referred to as the
``corresponding instance'' below).

\indextext{behavior!unspecified}%
\pnum
Certain other aspects and operations of the abstract machine are
described in this International Standard as unspecified (for example,
order of evaluation of arguments to a function). Where possible, this
International Standard defines a set of allowable behaviors. These
define the nondeterministic aspects of the abstract machine. An instance
of the abstract machine can thus have more than one possible execution
sequence for a given program and a given input.

\indextext{behavior!undefined}%
\pnum
Certain other operations are described in this International Standard as
undefined (for example, the effect of dereferencing  the null pointer).
\enternote this International Standard imposes no requirements on the
behavior of programs that contain undefined behavior. \exitnote

\indextext{program!well-formed}%
\pnum
A conforming implementation executing a well-formed program shall
produce the same observable behavior as one of the possible execution
sequences of the corresponding instance of the abstract machine with the
same program and the same input. However, if any such execution sequence
contains an undefined operation, this International Standard places no
requirement on the implementation executing that program with that input
(not even with regard to operations preceding the first undefined
operation).

\indextext{behavior!observable}%
\pnum
The observable behavior of the abstract machine is its sequence of reads
and writes to \tcode{volatile} data and calls to library I/O functions.
\footnote{An implementation can offer additional library I/O functions as
an extension. Implementations that do so should treat calls to those
functions as ``observable behavior'' as well.}

\pnum
Accessing an object designated by a \tcode{volatile} lvalue~(\ref{basic.lval}),
modifying an object, calling a library I/O function, or calling a function
that does any of those operations are all \defn{side effects}, which are
changes in the state of the execution environment.
Evaluation of an expression might produce side effects.
At certain specified points in the execution sequence called
\defn{sequence points}, all side effects of previous evaluations
shall be complete and no side effects of subsequent evaluations shall
have taken place.\footnote{Note that some aspects of sequencing in the
abstract machine are unspecified; the preceding restriction upon side effects
applies to that particular execution sequence in which the actual code is
generated.  Also note that when a call to a library I/O function returns,
the side effect is considered complete, even though some external actions
implied by the call (such as the I/O itself) may not have completed yet.}

\pnum
Once the execution of a function begins, no expressions from the calling
function are evaluated until execution of the called function has completed.
\footnote{In other words, function executions do not interleave with each other.}

\indextext{behavior!unspecified}%
\indextext{behavior!undefined}%
\indextext{behavior!on receipt of signal}%
\indextext{signal}%
\pnum
When the processing of the abstract machine is interrupted by receipt of
a signal, the values of objects with type other than
\tcode{volatile sig_atomic_t} are unspecified, and the value of any object
not of \tcode{volatile sig_atomic_t} that is modified by the handler becomes
undefined.

\indextext{program execution!abstract machine|)}

\pnum
An instance of each object with automatic storage
duration~(\ref{basic.stc.auto}) is associated with each entry into its
block. Such an object exists and retains its last-stored value during
the execution of the block and while the block is suspended (by a call
of a function or receipt of a signal).

\indextext{conformance requirements}
\pnum
The least requirements on a conforming implementation are:

\begin{itemize}

\item
At sequence points, volatile objects are stable in the sense that
previous evaluations are complete and subsequent evaluations have
not yet occurred.

\item
At program termination, all data written into files shall be
identical to one of the possible results that execution of the program
according to the abstract semantics would have produced.

\item
The input and output dynamics of interactive devices shall take
place in such a fashion that prompting messages actually appear prior
to a program waiting for input. What constitutes an interactive device is
\impldef{interactive device}.

\end{itemize}

\enternote more stringent correspondences between abstract and actual
semantics may be defined by each implementation. \exitnote

\pnum
\indextext{full-expression}%
A \defn{full-expression} is an expression that is not a
subexpression of another expression. If a language construct is defined
to produce an implicit call of a function, a use of the language
construct is considered to be an expression for the purposes of this
definition.

\pnum
\enternote certain contexts in \Cpp cause the evaluation of a full-expression
that results from a syntactic construct other than
\grammarterm{expression}~(\ref{expr.comma}).
For example, in~\ref{dcl.init} one syntax for \grammarterm{initializer} is

\begin{ncbnf}
\terminal{(} expression-list \terminal{)}
\end{ncbnf}

but the resulting construct is a function call upon a constructor function with
\grammarterm{expression-list} as an argument list; such a function call is
a full-expression. For example, in~\ref{dcl.init}, another syntax for
\grammarterm{initializer} is

\begin{ncbnf}
\terminal{=} initializer-clause
\end{ncbnf}

bug again the resulting construct might be a function call upon a constructor
function with one \grammarterm{assignment-expression} as an argument;
again, the function call is a full-expression. \exitnote

\pnum
\enternote the evaluation of a full-expression can include the
evaluation of subexpressions that are not lexically part of the
full-expression. For example, subexpressions involved in evaluating
default argument expressions~(\ref{dcl.fct.default}) are considered to
be created in the expression that calls the function, not the expression
that defines the default argument. \exitnote

\pnum
\indextext{operator!precedence of}%
\indextext{expression!order of evaluation of}%
\enternote operators can be regrouped according to the usual
mathematical rules only where the operators really are associative or
commutative.\footnote{Overloaded operators are never assumed to be associative or
commutative. }
For example, in the following fragment
\begin{codeblock}
int a, b;
/*...*/
a = a + 32760 + b + 5;
\end{codeblock}
the expression statement behaves exactly the same as
\begin{codeblock}
a = (((a + 32760) + b) + 5);
\end{codeblock}
due to the associativity and precedence of these operators. Thus, the
result of the sum \tcode{(a + 32760)} is next added to \tcode{b}, and
that result is then added to 5 which results in the value assigned to
\tcode{a}. On a machine in which overflows produce an exception and in
which the range of values representable by an \tcode{int} is
\crange{-32768}{+32767}, the implementation cannot rewrite this
expression as
\begin{codeblock}
a = ((a + b) + 32765);
\end{codeblock}
since if the values for \tcode{a} and \tcode{b} were, respectively,
-32754 and -15, the sum \tcode{a + b} would produce an exception while
the original expression would not; nor can the expression be rewritten
either as
\begin{codeblock}
a = ((a + 32765) + b);
\end{codeblock}
or
\begin{codeblock}
a = (a + (b + 32765));
\end{codeblock}
since the values for \tcode{a} and \tcode{b} might have been,
respectively, 4 and -8 or -17 and 12. However on a machine in which
overflows do not produce an exception and in which the results of
overflows are reversible, the above expression statement can be
rewritten by the implementation in any of the above ways because the
same result will occur. \exitnote

\pnum
There is a sequence point at the completion of evaluation of each
full-expression\footnote{As specified in~\ref{class.temporary}, after the
"end-of-full-expression" sequence point, a sequence of zero or more invocations
of destructor functions for temporary objects takes place, usually in
reverse order of the construction of each temporary object}.

\pnum
When calling a function (whether or not the function is inline), there is a
sequence point after the evaluation of all function arguments (if any)
which takes place before execution of any expressions or statements in
the function body.  There is also a sequence point after the copying of a
returned value and before the execution of any expressions outside
the function\footnote{The sequence point at the function return is not
explicitly specified in ISO C, and can be considered redundant with
sequence points at full-expressions, but the extra clarity is important
in \Cpp. In \Cpp, there are more ways in which a called function can terminate
its execution, such as the throw of an exception.}.
Several contexts in \Cpp  cause evaluation of a function call, even
though no corresponding function call syntax appears in the translation
unit.
\enterexample
evaluation of a \tcode{new} expression invokes one or more allocation
and constructor functions; see~\ref{expr.new}. For another example,
invocation of a conversion function~(\ref{class.conv.fct}) can arise in
contexts in which no function call syntax appears.
\exitexample
The sequence points at function-entry and function-exit (as
described above) are features of the function calls as evaluated,
whatever the syntax of the expression that calls the function might be.%

\pnum
In the evaluation of each of the expressions
\begin{codeblock}
a && b
a || b
a ? b : c
a , b
\end{codeblock}
using the built-in meaning of the operators in these
expressions~(\ref{expr.log.and}, \ref{expr.log.or}, \ref{expr.cond},
\ref{expr.comma}),
there is a sequence point after the evaluation of the first
expression\footnote{The operators indicated in this paragraph are the
built-in operators, as described in clause~\ref{expr}. When one of these
operators is overloaded (clause~\ref{over}) in a valid context, thus
designating a user-defined operator function, the expression designates a
function invocation, and the operands form an argument list, without an
implied sequence point between them.}.

\indextext{program execution|)}

\rSec1[intro.ack]{Acknowledgments}

\pnum
The \Cpp  programming language as described in this International
Standard is based on the language as described in Chapter R (Reference
Manual) of Stroustrup: \doccite{The \Cpp  Programming Language} (second
edition, Addison-Wesley Publishing Company, ISBN 0-201-53992-6,
copyright \copyright 1991 AT\&T). That, in turn, is based on the C
programming language as described in Appendix A of Kernighan and
Ritchie: \doccite{The C Programming Language} (Prentice-Hall, 1978, ISBN
0-13-110163-3, copyright \copyright 1978 AT\&T).

\pnum
Portions of the library clauses of this International Standard are based
on work by P.J. Plauger, which was published as \doccite{The Draft
Standard \Cpp  Library} (Prentice-Hall, ISBN 0-13-117003-1, copyright
\copyright 1995 P.J. Plauger).

\pnum
All rights in these originals are reserved.
