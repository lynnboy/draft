\rSec0[class.access]{Member access control}%
\indextext{access control|(}

\indextext{protection|see{access control}}
\indextext{\idxcode{private}|see{access control, \tcode{private}}}
\indextext{\idxcode{protected}|see{access control, \tcode{protected}}}
\indextext{\idxcode{public}|see{access control, \tcode{public}}}

\pnum
A member of a class can be
\begin{itemize}
\item
\indextext{access control!\idxcode{private}}%
\tcode{private};
that is, its name can be used only by members and friends
of the class in which it is declared.
\item
\indextext{access control!\idxcode{protected}}%
\tcode{protected};
that is, its name can be used only by members and friends
of the class in which it is declared, and by members and friends of classes
derived from this class (see~\ref{class.protected}).
\item
\indextext{access control!\idxcode{public}}%
\tcode{public};
that is, its name can be used anywhere without access restriction.
\end{itemize}

\pnum
\indextext{access control!member name}%
\indextext{default access control|see{access control, default}}%
\indextext{access control!default}%
Members of a class defined with the keyword
\tcode{class}
are
\tcode{private}
by default.
Members of a class defined with the keywords
\tcode{struct}
or
\tcode{union}
are
\tcode{public}
by default.
\enterexample

\begin{codeblock}
class X {
    int a;			// \tcode{X::a} is private by default
};

struct S {
    int a;			// \tcode{S::a} is public by default
};
\end{codeblock}
\exitexampleb

\pnum
Access control is applied uniformly to all names, whether the names are
referred to from declarations or expressions.
\enternote
access control applies to names nominated by
\tcode{friend}
declarations~(\ref{class.friend}) and
\grammarterm{using-declaration}{s}~(\ref{namespace.udecl}).
\exitnote
In the case of overloaded function names, access control is applied to
the function selected by overload resolution.
\enternote
because access control applies to names, if access control is applied to a
typedef name, only the accessibility of the typedef name itself is considered.
The accessibility of the entity referred to by the typedef is not considered.
For example,

\begin{codeblock}
class A
{
	class B { };
public:
	typedef B BB;
};

void f()
{
	A::BB x;		// OK, typedef name \tcode{A::BB} is public
	A::B y;			// access error, \tcode{A::B} is private
}
\end{codeblock}
\exitnoteb

\pnum
It should be noted that it is
\term{access}
to members and base classes that is controlled, not their
\term{visibility}.
Names of members are still visible, and implicit conversions to base
classes are still considered, when those members and base classes are
inaccessible.
The interpretation of a given construct is
established without regard to access control.
If the interpretation
established makes use of inaccessible member names or base classes,
the construct is ill-formed.

\pnum
All access controls in clause~\ref{class.access} affect the ability to access a class member name from a particular scope. The access control for names used in
the definition of a class member that appears outside of the member's class
definition is done as if the entire member definition appeared in the scope
of the member's class. In particular, access controls apply as usual to
member names accessed as part of a function return type, even though it is not
possible to determine the acess privileges of that use without first parsing
the rest of the function declarator. Similarly, access control for implicit
calls to the constructors, the conversion functions, or the destructor called
to create and destroy a static data member is performed as if these calls
appeared in the scope of the member's class.
\enterexample

\begin{codeblock}
class A {
    typedef int I;		// private member
    I f();
    friend I g(I);
    static I x;
};

A::I A::f() { return 0; }
A::I g(A::I p = A::x);
A::I g(A::I p) { return 0; }
A::I A::x = 0;
\end{codeblock}

Here, all the uses of
\tcode{A::I}
are well-formed because
\tcode{A::f}
and \tcode{A::x}
are members of class
\tcode{A}
and
\tcode{g}
is a friend of class
\tcode{A}.
This implies, for example, that access checking on the first use of
\tcode{A::I}
must be deferred until it is determined that this use of
\tcode{A::I}
is as the return type of a member of class
\tcode{A}.
\exitexample

\pnum
In the definition of a member of a nested class that appears outside of its
class definition, the name of the member may be qualified by the names of
enclosing classes of the member's class even if these names are private
members of their enclosing classes.
\enterexample

\begin{codeblock}
class D {
    class E {
	static int m;
    };
};
int D::E::m = 1;		// OK, no access error on private \tcode{E}
\end{codeblock}

\exitexampleb

\pnum
\indextext{argument!access checking~and default}%
\indextext{access control!default argument}%
The names in a default argument expression~(\ref{dcl.fct.default}) are
bound at the point of declaration, and access is checked at that
point rather than at any points of use of the default argument expression.
Access checking for default arguments in function templates and in
member functions of class templates are performed as described in~\ref{temp.inst}.

\rSec1[class.access.spec]{Access specifiers}%
\indextext{access~specifier}

\pnum
Member declarations can be labeled by an
\grammarterm{access-specifier}
(clause~\ref{class.derived}):

\begin{ncbnftab}
access-specifier \terminal{:} member-specification\opt
\end{ncbnftab}

An
\grammarterm{access-specifier}
specifies the access rules for members following it
until the end of the class or until another
\grammarterm{access-specifier}
is encountered.
\enterexample

\begin{codeblock}
class X {
    int a;			// \tcode{X::a} is private by default: \tcode{class} used
public:
    int b;			// \tcode{X::b} is public
    int c;			// \tcode{X::c} is public
};
\end{codeblock}
\exitexampleb
Any number of access specifiers is allowed and no particular order is required.
\enterexample

\begin{codeblock}
struct S {
    int a;			// \tcode{S::a} is public by default: \tcode{struct} used
protected:
    int b;			// \tcode{S::b} is protected
private:
    int c;			// \tcode{S::c} is private
public:
    int d;			// \tcode{S::d} is public
};
\end{codeblock}
\exitexampleb

\pnum
The order of allocation of data members with separate
\grammarterm{access-specifier} labels is unspecified~(\ref{class.mem}).

\pnum
When a member is redeclared within its class definition,
the access specified at its redeclaration shall
be the same as at its initial declaration.
\enterexample

\begin{codeblock}
struct S {
	class A;
private:
	class A { };		// error: cannot change access
};
\end{codeblock}
\exitexampleb

\rSec1[class.access.base]{Accessibility of base classes and base class members}%
\indextext{access control!base~class}%
\indextext{access~specifier}%
\indextext{base~class!\idxcode{private}}%
\indextext{base~class!\idxcode{protected}}%
\indextext{base~class!\idxcode{public}}

\pnum
If a class is declared to be a base class (clause~\ref{class.derived}) for another class using the
\tcode{public}
access specifier, the
\tcode{public}
members of the base class are accessible as
\tcode{public}
members of the derived class and
\tcode{protected}
members of the base class are accessible as
\tcode{protected}
members of the derived class.
If a class is declared to be a base class for another class using the
\tcode{protected}
access specifier, the
\tcode{public}
and
\tcode{protected}
members of the base class are accessible as
\tcode{protected}
members of the derived class.
If a class is declared to be a base class for another class using the
\tcode{private}
access specifier, the
\tcode{public}
and
\tcode{protected}
members of the base class are accessible as
\tcode{private}
members of the derived class\footnote{As specified previously in clause~\ref{class.access},
private members of a base class remain inaccessible even to derived classes
unless
\tcode{friend}
declarations within the base class declaration are used to grant access explicitly.}.

\pnum
In the absence of an
\grammarterm{access-specifier}
for a base class,
\tcode{public}
is assumed when the derived class is declared
\tcode{struct}
and
\tcode{private}
is assumed when the class is declared
\tcode{class}.
\enterexample

\begin{codeblock}
class B { /* ... */ };
class D1 : private B { /* ... */ };
class D2 : public B { /* ... */ };
class D3 : B { /* ... */ };     // \tcode{B} private by default
struct D4 : public B { /* ... */ };
struct D5 : private B { /* ... */ };
struct D6 : B { /* ... */ };    // \tcode{B} public by default
class D7 : protected B { /* ... */ };
struct D8 : protected B { /* ... */ };
\end{codeblock}

Here
\tcode{B}
is a public base of
\tcode{D2},
\tcode{D4},
and
\tcode{D6},
a private base of
\tcode{D1},
\tcode{D3},
and
\tcode{D5},
and a protected base of
\tcode{D7}
and
\tcode{D8}.
\exitexampleb

\pnum
\enternote
A member of a private base class might be inaccessible as an inherited
member name, but accessible directly.
Because of the rules on pointer conversions~(\ref{conv.ptr}) and explicit casts~(\ref{expr.cast}), a conversion from a pointer to a derived class to a pointer
to an inaccessible base class might be ill-formed if an implicit conversion
is used, but well-formed if an explicit cast is used.
For example,

\begin{codeblock}
class B {
public:
	int mi;                 // nonstatic member
	static int si;          // static member
};
class D : private B {
};
class DD : public D {
	void f();
};

void DD::f() {
	mi = 3;                 // error: \tcode{mi} is private in \tcode{D}
	si = 3;                 // error: \tcode{si} is private in \tcode{D}
	::B  b;
	b.mi = 3;               // OK (\tcode{b.mi} is different from \tcode{this->mi})
	b.si = 3;               // OK (\tcode{b.si} is different from \tcode{this->si})
	::B::si = 3;            // OK
	::B* bp1 = this;        // error: \tcode{B} is a private base class
	::B* bp2 = (::B*)this;  // OK with cast
	bp2->mi = 3;            // OK: access through a pointer to \tcode{B}.
}
\end{codeblock}
\exitnoteb

\pnum
A base class is said to be accessible if an invented public member of the
base class is accessible.
If a base class is accessible, one can implicitly convert a pointer to
a derived class to a pointer to that base class~(\ref{conv.ptr}, \ref{conv.mem}).
\enternote
it follows that
members and friends of a class
\tcode{X}
can implicitly convert an
\tcode{X*}
to a pointer to a private or protected immediate base class of
\tcode{X}.
\exitnote
The access to a member is affected by the class in which the member is
named.
This naming class is the class in which the member name was looked
up and found.
\enternote
this class can be explicit, e.g., when a
\grammarterm{qualified-id}
is used, or implicit, e.g., when a class member access operator~(\ref{expr.ref}) is used (including cases where an implicit
``\tcode{this->}''
is
added).
If both a class member access operator and a
\grammarterm{qualified-id}
are used to name the member (as in
\tcode{p->T::m}),
the class naming the member is the class named by the
\grammarterm{nested-name-specifier}
of the
\grammarterm{qualified-id}
(that is,
\tcode{T}).
\exitnote
A member
\tcode{m}
is accessible
when named in class
\tcode{N}
if
\begin{itemize}
\item
\tcode{m}
as a member of
\tcode{N}
is public, or
\item
\tcode{m}
as a member of
\tcode{N}
is private, and the reference
occurs in a member or friend of class
\tcode{N},
or
\item
\tcode{m}
as a member of
\tcode{N}
is protected, and the reference
occurs in a member or friend of class
\tcode{N},
or in a member or friend of a class
\tcode{P}
derived from
\tcode{N},
where
\tcode{m}
as a member of
\tcode{P}
is private or protected, or
\item
there exists a base class
\tcode{B}
of
\tcode{N}
that is accessible at the point of reference,
and
\tcode{m}
is accessible when named in class
\tcode{B}.
\enterexample

\begin{codeblock}
class B;
class A {
private:
  int i;
  friend void f(B*);
};
class B : public A { };
void f(B* p) {
  p->i = 1;			// OK: \tcode{B*} can be implicitly cast to \tcode{A*},
				// and \tcode{f} has access to \tcode{i} in \tcode{A}
}
\end{codeblock}
\exitexampleb
\end{itemize}

\pnum
If a class member access operator, including an implicit
``\tcode{this->},''
is used to access a nonstatic data member or nonstatic
member function, the reference is ill-formed if the
left operand (considered as a pointer in the
``\tcode{.}''
operator case) cannot be implicitly converted to a
pointer to the naming class of the right operand.
\enternote
this requirement is in addition to the requirement that
the member be accessible as named.
\exitnote

\rSec1[class.access.dcl]{Access declarations}%
\indextext{declaration!access}

\pnum
The access of a member of a base class can be changed in the derived class
by mentioning its \grammarterm{qualified-id} in the derived class
declaration. Such mention is called an \term{access declaration}. The
effect of an access declaration \grammarterm{qualified-id} \tcode{;} is
defined to be equivalent to the declaration
\tcode{using} \grammarterm{qualified-id} \tcode{;}.\footnote{Access
declarations are deprecated; member
\grammarterm{using-declaration}{s}~(\ref{namespace.udecl}) provide a better
means of doing the same things. In earlier versions of the \Cpp language,
access declarations were more limited; they were generalized and made
equivalent to \grammarterm{using-declaration}{s} in the interest of
simplicity. Programmers are encouraged to use
\grammarterm{using-declaration}{s}, rather than the new capabilities of
access declarations, in new code.}

\pnum
\enterexample

\begin{codeblock}
class A {
public:
    int z;
    int z1;
};

class B : public A {
    int a;
public:
    int b, c;
    int bf();
protected:
    int x;
    int y;
};

class D : private B {
    int d;
public:
    B::c;			// adjust access to \tcode{B::c}
    B::z;			// adjust access to \tcode{A::z}
    A::z1;			// adjust access to \tcode{A::z1}
    int e;
    int df();
protected:
    B::x;			// adjust access to \tcode{B::x}
    int g;
};

class X : public D {
    int xf();
};

int ef(D&);
int ff(X&);
\end{codeblock}

The external function \tcode{ef} can use only the names \tcode{c}, \tcode{z},
\tcode{z1}, \tcode{e}, and \tcode{df}. Being a member of \tcode{D}, the
function \tcode{df} can use the names \tcode{b}, \tcode{c}, \tcode{z},
\tcode{z1}, \tcode{bf}, \tcode{x}, \tcode{y}, \tcode{d}, \tcode{e}, \tcode{df},
and \tcode{g}, but not \tcode{a}. Being a member of \tcode{B}, the function
\tcode{bf} can use the members \tcode{a}, \tcode{b}, \tcode{c}, \tcode{z},
\tcode{z1}, \tcode{bf}, \tcode{x}, and \tcode{y}. The function \tcode{xf}
can use the public and protected names from \tcode{D}, that is, \tcode{c},
\tcode{z}, \tcode{z1}, \tcode{e}, and \tcode{df} (public), and \tcode{x},
and \tcode{g} (protected). Thus the external function \tcode{ff} has access
only to \tcode{c}, \tcode{z}, \tcode{z1}, \tcode{e}, and \tcode{df}. If
\tcode{D} were a protected or private base class of \tcode{X}, \tcode{xf}
would have the same privileges as before, but \tcode{ff} would have no
access at all.
\exitexample

\rSec1[class.friend]{Friends}%
\indextext{friend function!access and}%
\indextext{access control!friend function}

\pnum
A friend of a class is a function or class that is not a member of the class
but is permitted to use the private and protected member names from the class.
The name of a friend is not in the scope of the class, and the friend is not
called with the member access operators~(\ref{expr.ref}) unless it is a
member of another class.
\enterexample
the following example illustrates the differences between
members and friends:
\indextext{friend function!member~function~and}%
\indextext{example!friend function}%
\indextext{example!member~function}%

\begin{codeblock}
class X {
    int a;
    friend void friend_set(X*, int);
public:
    void member_set(int);
};

void friend_set(X* p, int i) { p->a = i; }
void X::member_set(int i) { a = i; }

void f()
{
    X obj;
    friend_set(&obj,10);
    obj.member_set(10);
}
\end{codeblock}
\exitexampleb

\pnum
\indextext{friend!class access~and}%
Declaring a class to be a friend implies that the names of private and
protected members from the class granting friendship can be accessed in
declarations of members of the befriended class.
\enternote
this means that access to private and protected names is also granted to
member functions of the friend class (as if the functions were each friends)
and to the static data member definitions of the friend class. This also
means that private and protected type names from the class granting friendship
can be used in the \grammarterm{base-clause} of a nested class of the friend
class. However, the declarations of members of classes nested within the
friend class cannot access the names of private and protected members from
the class granting friendship. Also, because the \grammarterm{base-clause}
of the friend class is not part of its member declarations, the
\grammarterm{base-clause} of the friend class cannot access the names of the
private and protected members from the class granting friendship. For example,

\begin{codeblock}
class A {
	class B { };
	friend class X;
};
class X : A::B {		// ill-formed: \tcode{A::B} cannot be accessed
				// in the \grammarterm{base-clause} for \tcode{X}
	A::B mx;		// OK: \tcode{A::B} used to declare member of \tcode{X}
	class Y : A::B {	// OK: \tcode{A::B} used to declare member of \tcode{X}
		A::B my;	// ill-formed: \tcode{A::B} cannot be accessed
				// to declare members of nested class of \tcode{X}
	};
};
\end{codeblock}
\exitnote
An \grammarterm{elaborated-type-specifier} shall be used in a friend
declaration for a class.\footnote{The \grammarterm{class-key} of the
\grammarterm{elaborated-type-specifier} is required.} A class shall not be
defined in a friend declaration.
\enterexample

\begin{codeblock}
class X {
    enum { a=100 };
    friend class Y;
};

class Y {
    int v[X::a];		// OK, \tcode{Y} is a friend of \tcode{X}
};

class Z {
    int v[X::a];		// error: \tcode{X::a} is private
};
\end{codeblock}
\exitexampleb

\pnum
\indextext{friend function!linkage~of}%
A function first declared in a friend declaration
has external linkage~(\ref{basic.link}).
Otherwise, the function retains its previous linkage~(\ref{dcl.stc}).

\pnum
\indextext{declaration!overloaded~name~and \tcode{friend}}%
When a
\tcode{friend}
declaration refers to an overloaded name or operator, only the function specified
by the parameter types becomes a friend.
A member function of a class
\tcode{X}
can be a friend of
a class
\tcode{Y}.
\indextext{member function!friend}%
\enterexample

\begin{codeblock}
class Y {
    friend char* X::foo(int);
    // ...
};
\end{codeblock}
\exitexampleb

\pnum
\indextext{friend function!inline}%
A function can be defined in a friend declaration of a class if and only if the
class is a non-local class~(\ref{class.local}), the function name is unqualified,
and the function has namespace scope.
\enterexample

\begin{codeblock}
class M {
	friend void f() { }     // definition of global \tcode{f}, a friend of \tcode{M},
                                // not the definition of a member function
};
\end{codeblock}
\exitexampleb
Such a function is implicitly
\tcode{inline}.
A
\tcode{friend}
function defined in a class is in the (lexical) scope of the class in which it is defined.
A friend function defined outside the class is not~(\ref{basic.lookup.unqual}).

\pnum
No
\grammarterm{storage-class-specifier}
shall appear in the
\grammarterm{decl-specifier-seq}
of a friend declaration.

\pnum
\indextext{friend!access~specifier~and}%
A name nominated by a friend declaration shall be accessible in the scope of the
class containing the friend declaration.
The meaning of the friend declaration is the same whether the friend declaration
appears in the
\tcode{private},
\tcode{protected}
or
\tcode{public}~(\ref{class.mem})
portion of the class
\grammarterm{member-specification}.

\pnum
\indextext{friend!inheritance~and}%
Friendship is neither inherited nor transitive.
\enterexample

\begin{codeblock}
class A {
    friend class B;
    int a;
};

class B {
    friend class C;
};

class C  {
    void f(A* p)
    {
	p->a++;			// error: \tcode{C} is not a friend of \tcode{A}
				// despite being a friend of a friend
    }
};

class D : public B  {
    void f(A* p)
    {
	p->a++;			// error: \tcode{D} is not a friend of \tcode{A}
				// despite being derived from a friend
    }
};
\end{codeblock}
\exitexampleb

\pnum
\indextext{local~class!friend}%
\indextext{friend!local~class~and}%
If a friend declaration appears in a local class~(\ref{class.local}) and the
name specified is an unqualified name, a prior declaration is looked
up without considering scopes that are outside the innermost enclosing
non-class scope.
For a friend function declaration, if there is no
prior declaration, the program is ill-formed.
For a friend class
declaration, if there is no prior declaration, the class that is
specified belongs to the innermost enclosing non-class scope, but if it is
subsequently referenced, its name is not found by name lookup
until a matching declaration is provided in the innermost enclosing
nonclass scope.
\enterexample

\begin{codeblock}
class X;
void a();
void f() {
    class Y;
    extern void b();
    class A {
	friend class X;		// OK, but \tcode{X} is a local class, not \tcode{::X}
	friend class Y;		// OK
	friend class Z;		// OK, introduces local class \tcode{Z}
	friend void a();	// error, \tcode{::a} is not considered
	friend void b();	// OK
	friend void c();	// error
    };
    X *px;			// OK, but \tcode{::X} is found
    Z *pz;			// error, no \tcode{Z} is found
}
\end{codeblock}
\exitexampleb

\rSec1[class.protected]{Protected member access}
\indextext{access control!\idxcode{protected}}%

\pnum
When a friend or a member function of a derived class references a protected
nonstatic member function or protected nonstatic data member of a base class,
an access check applies in addition to those described earlier in
clause~\ref{class.access}.\footnote{This additional check does not apply to
other members, e.g. static data members or enumerator member constants.}
Except when forming a pointer to member~(\ref{expr.unary.op}), the access
must be through a pointer to, reference to, or object of the derived class
itself (or any class derived from that class)~(\ref{expr.ref}). If the access
is to form a pointer to member, the \grammarterm{nested-name-specifier} shall
name the derived class (or any class derived from that class).
\enterexample

\begin{codeblock}
class B {
protected:
    int i;
    static int j;
};

class D1 : public B {
};

class D2 : public B {
    friend void fr(B*,D1*,D2*);
    void mem(B*,D1*);
};

void fr(B* pb, D1* p1, D2* p2)
{
    pb->i = 1;                  // ill-formed
    p1->i = 2;                  // ill-formed
    p2->i = 3;                  // OK (access through a \tcode{D2})
    p2->B::i = 4;               // OK (access through a \tcode{D2}, even though
                                // naming class is \tcode{B})
    int B::* pmi_B = &B::i;     // ill-formed
    int B::* pmi_B2 = &D2::i;   // OK (type of \tcode{\&D2::i} is \tcode{int B::*})
    B::j = 5;                   // OK (because refers to static member)
    D2::j = 6;                  // OK (because refers to static member)
}

void D2::mem(B* pb, D1* p1)
{
    pb->i = 1;                  // ill-formed
    p1->i = 2;                  // ill-formed
    i = 3;                      // OK (access through \tcode{this})
    B::i = 4;                   // OK (access through \tcode{this}, qualification ignored)
    int B::* pmi_B = &B::i;     // ill-formed
    int B::* pmi_B2 = &D2::i;   // OK
    j = 5;                      // OK (because \tcode{j} refers to static member)
    B::j = 6;                   // OK (because \tcode{B::j} refers to static member)
}

void g(B* pb, D1* p1, D2* p2)
{
    pb->i = 1;                  // ill-formed
    p1->i = 2;                  // ill-formed
    p2->i = 3;                  // ill-formed
}
\end{codeblock}
\exitexampleb

\rSec1[class.access.virt]{Access to virtual functions}%
\indextext{access control!virtual function}

\pnum
The access rules (clause~\ref{class.access}) for a virtual function are determined by its declaration
and are not affected by the rules for a function that later overrides it.
\enterexample

\begin{codeblock}
class B {
public:
    virtual int f();
};

class D : public B {
private:
    int f();
};

void f()
{
    D d;
    B* pb = &d;
    D* pd = &d;

    pb->f();                    // OK: \tcode{B::f()} is public,
                                // \tcode{D::f()} is invoked
    pd->f();                    // error: \tcode{D::f()} is private
}
\end{codeblock}
\exitexampleb
Access is checked at the call point using the type of the expression used
to denote the object for which the member function is called
(\tcode{B*}
in the example above).
The access of the member function in the class in which it was defined
(\tcode{D}
in the example above) is in general not known.

\rSec1[class.paths]{Multiple access}%
\indextext{access control!multiple access}

\pnum
If a name can be reached by several paths through a multiple inheritance
graph, the access is that of the path that gives most access.
\enterexample

\begin{codeblock}
class W { public: void f(); };
class A : private virtual W { };
class B : public virtual W { };
class C : public A, public B {
    void f() { W::f(); }        // OK
};
\end{codeblock}

Since
\tcode{W::f()}
is available to
\tcode{C::f()}
along the public path through
\tcode{B},
access is allowed.
\exitexample

\rSec1[class.access.nest]{Nested classes}%
\indextext{access control!nested class}%
\indextext{member function!nested class}

\pnum
The members of a nested class have no special access to members of an
enclosing class, nor to classes or functions that have granted friendship
to an enclosing class; the usual access rules (clause~\ref{class.access})
shall be obeyed.
The members of an enclosing class have no special access to members of a nested
class; the usual access rules (clause~\ref{class.access}) shall be obeyed.
\enterexample
\indextext{example!nested~class definition}%

\begin{codeblock}
class E {
    int x;
    class B { };

    class I {
	B b;                    // error: \tcode{E::B} is private
	int y;
	void f(E* p, int i)
	{
	    p->x = i;           // error: \tcode{E::x} is private
	}
    };

    int g(I* p)
    {
	return p->y;            // error: \tcode{I::y} is private
    }
};
\end{codeblock}
\exitexampleb

\pnum
\enternote
because a \grammarterm{base-clause} for a nested class is part of the
declaration of the nested class itself (and not part of the declarations
of the members of the nested class), the \grammarterm{base-clause} may
refer to the private members of the enclosing class. For example,

\begin{codeblock}
class C {
	class A { };
	A *p;			// OK
	class B : A		// OK
	{
		A *q;		// OK because of injection of name \tcode{A} in \tcode{A}
		C::A *r;	// error, \tcode{C::A} is inaccessible
		B *s;		// OK because of injection of name \tcode{B} in \tcode{B}
		C::B *t;	// error, \tcode{C::B} is inaccessible
	};
};
\end{codeblock}

\exitnoteb%
\indextext{access control|)}
