\rSec0[lib.strings]{Strings library}

\pnum
This clause describes components for manipulating sequences of ``characters,''
where characters may be of any POD~(\ref{basic.types}) type.
In this clause such types are called char-like types\indextext{char-like type},
and objects of
char-like types are called char-like objects\indextext{char-like object} or
simply ``characters.''

\pnum
The following subclauses describe a
character traits class, a string class, and
null-terminated sequence utilities,
as summarized in Table~\ref{tab:strings.lib.summary}.

\begin{libsumtab}{Strings library summary}{tab:strings.lib.summary}
\ref{lib.char.traits}     & Character traits                    & \tcode{<string>}  \\ \rowsep
\ref{lib.string.classes}  & String classes                      & \tcode{<string>}  \\ \rowsep
                      &                                     & \tcode{<cctype>}  \\
                      &                                     & \tcode{<cwctype>} \\
\ref{lib.c.strings}       & Null-terminated sequence utilities  & \tcode{<cstring>} \\
                      &                                     & \tcode{<cwchar>}  \\
                      &                                     & \tcode{<cstdlib>} \\
\end{libsumtab}

\rSec1[lib.char.traits]{Character traits}

\pnum
This subclause defines requirements on classes representing
\term{character traits},
and defines a class template
\tcode{char_traits<charT>},
along with two specializations,
\tcode{char_traits<char>}
and
\tcode{char_traits<wchar_t>},
that satisfy those requirements.

\pnum
Most classes specified in clauses~\ref{lib.string.classes}
and~\ref{lib.input.output} need a set of related types and functions
to complete the definition of their semantics.
These types and functions are provided as a set of member typedefs
and functions in the template parameter `traits' used by each such
template.
This subclause defines the semantics guaranteed by these
members.

\pnum
To specialize those templates to generate a string or
iostream class to handle a particular character container type
\tcode{CharT},
that and its related character traits class
\tcode{Traits}
are passed as a pair of parameters to the string or iostream template as
formal parameters
\tcode{charT}
and
\tcode{traits}.
\tcode{Traits::char_type}
shall be the same as
\tcode{CharT}.

\pnum
This subclause specifies a struct template,
\tcode{char_traits<charT>},
and two explicit specializations of it,
\tcode{char_traits<char>}
and
\tcode{char_traits<wchar_t>},
all of which appear in the header
\tcode{<string>}
and satisfy the requirements below.

\rSec2[lib.char.traits.require]{Character traits requirements}

\pnum
In Table~\ref{tab:char.traits.require},
\tcode{X}
denotes a Traits class defining types and functions for the
character container type
\tcode{CharT};
\tcode{c}
and
\tcode{d}
denote values of type
\tcode{CharT};
\tcode{p}
and
\tcode{q}
denote values of type
\tcode{const CharT*};
\tcode{s}
denotes a value of type
\tcode{CharT*};
\tcode{n},
\tcode{i}
and
\tcode{j}
denote values of type
\tcode{size_t};
\tcode{e}
and
\tcode{f}
denote values of type
\tcode{X::int_type};
\tcode{pos}
denotes a value of type
\tcode{X::pos_type};
and
\tcode{state}
denotes a value of type
\tcode{X::state_type}.
Operations on Traits shall not throw exceptions.

\begin{libreqtab4d}
{Traits requirements}
{tab:char.traits.require}
\\ \topline
\lhdr{expression}       &   \chdr{return type}  &   \chdr{assertion/note}   &   \rhdr{complexity}\\
                        &                       &   \chdr{pre/post-condition}   &               \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{expression}       &   \chdr{return type}  &   \chdr{assertion/note}   &   \rhdr{complexity}\\
                        &                       &   \chdr{pre/post-condition}   &               \\ \capsep
\endhead
\tcode{X::char_type}    &   \tcode{charT}       &
(described in~\ref{lib.char.traits.typedefs})   &   compile-time    \\ \rowsep
\tcode{X::int_type} &                       &
(described in~\ref{lib.char.traits.typedefs})   &   compile-time    \\ \rowsep
\tcode{X::off_type} &                       &
(described in~\ref{lib.char.traits.typedefs})   &   compile-time    \\ \rowsep
\tcode{X::pos_type} &                       &
(described in~\ref{lib.char.traits.typedefs})   &   compile-time    \\ \rowsep
\tcode{X::state_type}   &                       &
(described in~\ref{lib.char.traits.typedefs})   &   compile-time    \\ \rowsep
\tcode{X::assign(c,d)}  &   (not used)          &
assigns \tcode{c=d}.                            &   constant        \\ \rowsep
\tcode{X::eq(c,d)}      &   \tcode{bool}        &
yields: whether \tcode{c} is to be treated as equal to \tcode{d}.   &   constant    \\ \rowsep
\tcode{X::lt(c,d)}      &   \tcode{bool}        &
yields: whether \tcode{c} is to be treated as less than \tcode{d}.  &   constant    \\ \rowsep
\tcode{X::compare(p,q,n)}   &   \tcode{int}     &
yields: \tcode{0} if for each \tcode{i} in \tcode{[0,n)}, \tcode{X::eq(p[i],q[i])}
is true; else, a negative value if, for some \tcode{j} in \tcode{[0,n)},
\tcode{X::lt(p[j],q[j])} is true and for each \tcode{i} in \tcode{[0,j)}
\tcode{X::eq(p[i],q[i])} is true; else a positive value.            &   linear      \\ \rowsep
\tcode{X::length(p)}    &   \tcode{size_t}          &
yields: the smallest \tcode{i} such that \tcode{X::eq(p[i],charT())} is true.  &   linear  \\ \rowsep
\tcode{X::find(p,n,c)}  &   \tcode{const X::char_type*} &
yields: the smallest \tcode{q} in \tcode{[p,p+n)} such that
\tcode{X::eq(*q,c)} is true, zero otherwise.                        &   linear      \\ \rowsep
\tcode{X::move(s,p,n)}  &   \tcode{X::char_type*}   &
for each \tcode{i} in \tcode{[0,n)}, performs \tcode{X::assign(s[i],p[i])}.
Copies correctly even where the ranges \tcode{[p,p+n)} and \tcode{[s,s+n)} overlap. yields: \tcode{s}.    &   linear  \\ \rowsep
\tcode{X::copy(s,p,n)}  &   \tcode{X::char_type*}   &
pre: \tcode{p} not in \tcode{[s,s+n)}. yields: \tcode{s}. for each \tcode{i} in
\tcode{[0,n)}, performs \tcode{X::assign(s[i],p[i])}.               &   linear      \\ \rowsep
\tcode{X::assign\-(s,n,c)}  &   \tcode{X::char_type*}   &
for each \tcode{i} in \tcode{[0,n)}, performs
\tcode{X::assign(s[i],c)}. yields: \tcode{s}.                       &   linear      \\ \rowsep
\tcode{X::not_eof(e)}   &   \tcode{int_type}        &
yields: \tcode{e} if \tcode{X::eq_int_type(e,X::eof())} is false,
otherwise a value \tcode{f} such that
\tcode{X::eq_int_type(f,X::eof())} is false.                       &   constant    \\ \rowsep
\tcode{X::to_char_type\-(e)}    &   \tcode{X::char_type}    &
yields: if for some \tcode{c}, \tcode{X::eq_int_type(e,X::to_int_type(c))}
is true, \tcode{c}; else some unspecified value.                    &   constant    \\ \rowsep
\tcode{X::to_int_type\-(c)} &   \tcode{X::int_type} &
yields: some value \tcode{e}, constrained by the definitions of
\tcode{to_char_type} and \tcode{eq_int_type}.                  &   constant    \\ \rowsep
\tcode{X::eq_int_type\-(e,f)}   &   \tcode{bool}            &
yields: for all \tcode{c} and \tcode{d}, \tcode{X::eq(c,d)} is equal to
\tcode{X::eq_int_type(X::to_int_type(c), X::to_int_type(d))}; otherwise, yields true
if \tcode{e} and \tcode{f} are both copies of \tcode{X::eof()}; otherwise, yields false if
one of \tcode{e} and \tcode{f} is a copy of \tcode{X::eof()} and the other is not; otherwise
the value is unspecified.                                           &   constant    \\ \rowsep
\tcode{X::eof()}                &   \tcode{X::int_type} &
yields: a value \tcode{e} such that \tcode{X::eq_int_type(e,X::to_int_type(c))}
is false for all values \tcode{c}.                                  &   constant    \\
\end{libreqtab4d}

\pnum
The struct template

\indexlibrary{\idxcode{char_traits}}%
\begin{codeblock}
template<class charT> struct char_traits;
\end{codeblock}

shall be provided in the header
\tcode{<string>}
as a basis for explicit specializations.

\pnum
In the following subclauses, the token \tcode{charT} represents the parameter
of the traits template.

\rSec2[lib.char.traits.typedefs]{traits typedefs}

\indexlibrary{\idxcode{char_type}!\idxcode{char_traits}}%
\indexlibrary{\idxcode{char_traits}!\idxcode{char_type}}%
\begin{itemdecl}
typedef CHAR_T char_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
The type
\tcode{char_type}
is used to refer to the character container type
in the implementation of the library classes defined in~\ref{lib.string.classes} and clause~\ref{lib.input.output}.
\end{itemdescr}

\indexlibrary{\idxcode{int_type}!\idxcode{char_traits}}%
\indexlibrary{\idxcode{char_traits}!\idxcode{int_type}}%
\begin{itemdecl}
typedef INT_T int_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
For a certain character container type
\tcode{char_type},
a related container type
\tcode{INT_T}
shall be a type or class which can represent all of the
valid characters converted from the corresponding
\tcode{char_type}
values, as well as an end-of-file value,
\tcode{eof()}.
The type
\tcode{int_type}
represents a character container type
which can hold end-of-file to be used as a return type
of the iostream class member functions.\footnote{If
\tcode{eof()}
can be held in
\tcode{char_type}
then some iostreams operations may give surprising results.}
\end{itemdescr}

\indexlibrary{\idxcode{off_type}!\idxcode{char_traits}}%
\indexlibrary{\idxcode{char_traits}!\idxcode{off_type}}%
\indexlibrary{\idxcode{pos_type}!\idxcode{char_traits}}%
\indexlibrary{\idxcode{char_traits}!\idxcode{pos_type}}%
\begin{itemdecl}
typedef OFF_T off_type;
typedef POS_T pos_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Requirements for
\tcode{off_type}
and
\tcode{pos_type}
are described in~\ref{lib.iostreams.limits.pos}.
\end{itemdescr}

\indexlibrary{\idxcode{state_type}!\idxcode{char_traits}}%
\indexlibrary{\idxcode{char_traits}!\idxcode{state_type}}%
\begin{itemdecl}
typedef STATE_T state_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{state_type}
shall meet the requirements of
\tcode{CopyConstructible} types~(\ref{lib.copyconstructible}).
\end{itemdescr}

\rSec2[lib.char.traits.specializations]{\tcode{char_traits} specializations}

\indexlibrary{\idxcode{char_traits}}%
\begin{codeblock}
namespace std {
  template<> struct char_traits<char>;
  template<> struct char_traits<wchar_t>;
}
\end{codeblock}

\pnum
The header
\tcode{<string>}
declares two structs that are specializations of the template struct
\tcode{char_traits}.

\pnum
The struct \tcode{char_traits<char>} is the \tcode{char} type specialization
of the template struct \tcode{char_traits}, which contains all of the types
and functions necessary to ensure the behavior of the classes
in~\ref{lib.string.classes} and clause~\ref{lib.input.output}.

\pnum
The types and static member functions are described in detail
in~\ref{lib.char.traits.require}.

\rSec3[lib.char.traits.specializations.char]{\tcode{struct char_traits<char>}}

\indexlibrary{\idxcode{char_traits}}%
\begin{codeblock}
namespace std {
  template<>
  struct char_traits<char> {
    typedef char        char_type;
    typedef int         int_type;
    typedef streamoff   off_type;
    typedef streampos   pos_type;
    typedef mbstate_t   state_type;

    static void assign(char_type& c1, const char_type& c2);
    static bool eq(const char_type& c1, const char_type& c2);
    static bool lt(const char_type& c1, const char_type& c2);

    static int compare(const char_type* s1, const char_type* s2, size_t n);
    static size_t length(const char_type* s);
    static const char_type* find(const char_type* s, size_t n,
                                 const char_type& a);
    static char_type* move(char_type* s1, const char_type* s2, size_t n);
    static char_type* copy(char_type* s1, const char_type* s2, size_t n);
    static char_type* assign(char_type* s, size_t n, char_type a);

    static int_type not_eof(const int_type& c);
    static char_type to_char_type(const int_type& c);
    static int_type to_int_type(const char_type& c);
    static bool eq_int_type(const int_type& c1, const int_type& c2);
    static int_type eof();
  };
}
\end{codeblock}

\pnum
The header \tcode<string>~(\ref{lib.string.classes}) declares a specialization
of the template struct \tcode{char_traits} for \tcode{char}. It is for
narrow-oriented iostream classes.

\pnum
The defined types for
\tcode{int_type},
\tcode{pos_type},
\tcode{off_type},
and
\tcode{state_type}
are
\tcode{int},
\tcode{streampos},
\tcode{streamoff},
and
\tcode{mbstate_t}
respectively.

\pnum
The type
\tcode{streampos}
is an \impldef{type of \tcode{streampos}} type that satisfies the requirements for
\tcode{POS_T}
in~\ref{lib.char.traits.typedefs}.

\pnum
The type
\tcode{streamoff}
is an \impldef{type of \tcode{streamoff}} type that satisfies the requirements for
\tcode{OFF_T}
in~\ref{lib.char.traits.typedefs}.

\pnum
The type
\tcode{mbstate_t}
is defined in
\tcode{<cwchar>}
and can represent any of the conversion states possible to occur in an
\impldef{supported multibyte character encoding rules} set of supported multibyte
character encoding rules.

\pnum
The two-argument members \tcode{assign}, \tcode{eq},
and \tcode{lt} are defined identically to the built-in operators
\tcode{=}, \tcode{==}, and \tcode{<} respectively.

\pnum
The member
\tcode{eof()}
returns
\tcode{EOF}.

\rSec3[lib.char.traits.specializations.wchar.t]{\tcode{struct char_traits<wchar_t>}}

\indexlibrary{\idxcode{char_traits}}%
\begin{codeblock}
namespace std {
  template<>
  struct char_traits<wchar_t> {
    typedef wchar_t      char_type;
    typedef wint_t       int_type;
    typedef streamoff   off_type;
    typedef wstreampos   pos_type;
    typedef mbstate_t    state_type;

    static void assign(char_type& c1, const char_type& c2);
    static bool eq(const char_type& c1, const char_type& c2);
    static bool lt(const char_type& c1, const char_type& c2);

    static int compare(const char_type* s1, const char_type* s2, size_t n);
    static size_t length(const char_type* s);
    static const char_type* find(const char_type* s, size_t n,
                                 const char_type& a);
    static char_type* move(char_type* s1, const char_type* s2, size_t n);
    static char_type* copy(char_type* s1, const char_type* s2, size_t n);
    static char_type* assign(char_type* s, size_t n, char_type a);

    static int_type not_eof(const int_type& c);
    static char_type to_char_type(const int_type& c);
    static int_type to_int_type(const char_type& c);
    static bool eq_int_type(const int_type& c1, const int_type& c2);
    static int_type eof();
  };
}
\end{codeblock}

The header \tcode{<string>}~(\ref{lib.string.classes}) declares a
specialization of the template struct \tcode{char_traits} for \tcode{wchar_t}.
It is for wide-oriented iostream classes.

\pnum
The defined types for
\tcode{int_type},
\tcode{pos_type},
and
\tcode{state_type}
are
\tcode{wint_t},
\tcode{wstreampos},
and
\tcode{mbstate_t}
respectively.

\pnum
The type
\tcode{wstreampos}
is an \impldef{type of \tcode{wstreampos}} type that satisfies the requirements
for \tcode{POS_T} in~\ref{lib.char.traits.typedefs}.

\pnum
\enternote
This paragraph is intentionally empty.
\exitnoteb

\pnum
The type
\tcode{mbstate_t}
is defined in
\tcode{<cwchar>}
and can represent any of the conversion states possible to occur in an \impldef{supported
multibyte character encoding rules} set of supported multibyte character encoding rules.

\pnum
The two-argument members
\tcode{assign},
\tcode{eq},
and
\tcode{lt}
are defined identically to the built-in operators
\tcode{=},
\tcode{==},
and
\tcode{<}
respectively.

\pnum
The member
\tcode{eof()}
returns
\tcode{WEOF}.

\rSec1[lib.string.classes]{String classes}

\pnum
The header \tcode{<string>} defines a basic string
class template and its traits that can handle all char-like
(clause~\ref{lib.strings}) template arguments with several function
signatures for manipulating varying-length sequences of char-like objects.

\pnum
The header \tcode{<string>} also defines two specific template
classes \tcode{string} and \tcode{wstring} and their special traits.

\synopsis{Header \tcode{<string>} synopsis}

\indexlibrary{\idxhdr{string}}%
\begin{codeblock}
namespace std {
  // \ref{lib.char.traits}, character traits:
  template<class charT>
    struct char_traits;
  template <> struct char_traits<char>;
  template <> struct char_traits<wchar_t>;

  // \ref{lib.basic.string}, basic_string:
  template<class charT, class traits = char_traits<charT>,
           class Allocator = allocator<charT> >
    class basic_string;

  template<class charT, class traits, class Allocator>
    basic_string<charT,traits,Allocator>
      operator+(const basic_string<charT,traits,Allocator>& lhs,
                const basic_string<charT,traits,Allocator>& rhs);
  template<class charT, class traits, class Allocator>
    basic_string<charT,traits,Allocator>
      operator+(const charT* lhs,
                const basic_string<charT,traits,Allocator>& rhs);
  template<class charT, class traits, class Allocator>
    basic_string<charT,traits,Allocator>
      operator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);
  template<class charT, class traits, class Allocator>
    basic_string<charT,traits,Allocator>
      operator+(const basic_string<charT,traits,Allocator>& lhs,
                const charT* rhs);
  template<class charT, class traits, class Allocator>
    basic_string<charT,traits,Allocator>
      operator+(const basic_string<charT,traits,Allocator>& lhs, charT rhs);

  template<class charT, class traits, class Allocator>
    bool operator==(const basic_string<charT,traits,Allocator>& lhs,
                    const basic_string<charT,traits,Allocator>& rhs);
  template<class charT, class traits, class Allocator>
    bool operator==(const charT* lhs,
                    const basic_string<charT,traits,Allocator>& rhs);
  template<class charT, class traits, class Allocator>
    bool operator==(const basic_string<charT,traits,Allocator>& lhs,
                    const charT* rhs);
  template<class charT, class traits, class Allocator>
    bool operator!=(const basic_string<charT,traits,Allocator>& lhs,
                    const basic_string<charT,traits,Allocator>& rhs);
  template<class charT, class traits, class Allocator>
    bool operator!=(const charT* lhs,
                    const basic_string<charT,traits,Allocator>& rhs);
  template<class charT, class traits, class Allocator>
    bool operator!=(const basic_string<charT,traits,Allocator>& lhs,
                    const charT* rhs);

  template<class charT, class traits, class Allocator>
    bool operator< (const basic_string<charT,traits,Allocator>& lhs,
                    const basic_string<charT,traits,Allocator>& rhs);
  template<class charT, class traits, class Allocator>
    bool operator< (const basic_string<charT,traits,Allocator>& lhs,
                    const charT* rhs);
  template<class charT, class traits, class Allocator>
    bool operator< (const charT* lhs,
                    const basic_string<charT,traits,Allocator>& rhs);
  template<class charT, class traits, class Allocator>
    bool operator> (const basic_string<charT,traits,Allocator>& lhs,
                    const basic_string<charT,traits,Allocator>& rhs);
  template<class charT, class traits, class Allocator>
    bool operator> (const basic_string<charT,traits,Allocator>& lhs,
                    const charT* rhs);
  template<class charT, class traits, class Allocator>
    bool operator> (const charT* lhs,
                    const basic_string<charT,traits,Allocator>& rhs);

  template<class charT, class traits, class Allocator>
    bool operator<=(const basic_string<charT,traits,Allocator>& lhs,
                    const basic_string<charT,traits,Allocator>& rhs);
  template<class charT, class traits, class Allocator>
    bool operator<=(const basic_string<charT,traits,Allocator>& lhs,
                    const charT* rhs);
  template<class charT, class traits, class Allocator>
    bool operator<=(const charT* lhs,
                    const basic_string<charT,traits,Allocator>& rhs);
  template<class charT, class traits, class Allocator>
    bool operator>=(const basic_string<charT,traits,Allocator>& lhs,
                    const basic_string<charT,traits,Allocator>& rhs);
  template<class charT, class traits, class Allocator>
    bool operator>=(const basic_string<charT,traits,Allocator>& lhs,
                    const charT* rhs);
  template<class charT, class traits, class Allocator>
    bool operator>=(const charT* lhs,
                    const basic_string<charT,traits,Allocator>& rhs);

  // \ref{lib.string.special}:
  template<class charT, class traits, class Allocator>
     void swap(basic_string<charT,traits,Allocator>& lhs,
               basic_string<charT,traits,Allocator>& rhs);

  template<class charT, class traits, class Allocator>
   basic_istream<charT,traits>&
    operator>>(basic_istream<charT,traits>& is,
               basic_string<charT,traits,Allocator>& str);
  template<class charT, class traits, class Allocator>
   basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os,
               const basic_string<charT,traits,Allocator>& str);
  template<class charT, class traits, class Allocator>
   basic_istream<charT,traits>&
     getline(basic_istream<charT,traits>& is,
             basic_string<charT,traits,Allocator>& str,
             charT delim);
  template<class charT, class traits, class Allocator>
   basic_istream<charT,traits>&
     getline(basic_istream<charT,traits>& is,
             basic_string<charT,traits,Allocator>& str);

  typedef basic_string<char> string;
  typedef basic_string<wchar_t> wstring;
}
\end{codeblock}

\rSec1[lib.basic.string]{Class template \tcode{basic_string}}

\pnum
\indexlibrary{\idxcode{basic_string}}%
For a char-like type \tcode{charT}, the class template \tcode{basic_string}
describes objects that can store a sequence consisting of a varying number of
arbitrary char-like objects (clause~\ref{lib.strings}).
The first element of the sequence is at position zero.
Such a sequence is also called a ``string'' if the given char-like type
is clear from context. In the rest of this clause, \tcode{charT} denotes
such a given char-like type. Storage for the string is allocated and freed
as necessary by the member functions of class \tcode{basic_string}, via the
\tcode{Allocator} class passed as template parameter.
\tcode{Allocator::value_type} shall be the same as \tcode{charT}.

\pnum
The class template \tcode{basic_string} conforms to the requirements of a
Sequence, as specified in~(\ref{lib.sequence.reqmts}).
Additionally, because the iterators supported by \tcode{basic_string} are
random access iterators~(\ref{lib.random.access.iterators}),
\tcode{basic_string} conforms to the requirements of a Reversible Container,
as specified in~(\ref{lib.container.requirements}).

\pnum
In all cases,
\tcode{size() <= capacity()}.

\pnum
The functions described in this clause can report two
kinds of errors, each associated with a distinct exception:

\begin{itemize}
\item
a
\term{length}
error is associated with exceptions of type
\tcode{length_error}~(\ref{lib.length.error});
\indexlibrary{\idxcode{length_error}}%
\item
an
\term{out-of-range}
error is associated with exceptions of type
\tcode{out_of_range}~(\ref{lib.out.of.range}).
\indexlibrary{\idxcode{out_of_range}}%
\end{itemize}

\pnumalt
For any string operation, if as a result of the operation, \tcode{size()}
would exceed \tcode{max_size()} then the operation throws \tcode{length_error}.

\pnum
References, pointers, and iterators referring to the elements of a basic_string
sequence may be invalidated by the following uses of that basic_string object:

\begin{itemize}
\item As an argument to non-member functions
\tcode{swap()} (\ref{lib.string.special}),
\tcode{operator\shr()} (\ref{lib.string.io}),
and \tcode{getline()} (\ref{lib.string.io}).
\item As an argument to \tcode{basic_string::swap()}.
\item Calling \tcode{data()} and \tcode{c_str()} member functions.
\item Calling non-const member functions, except \tcode{operator[]()},
\tcode{at()}, \tcode{begin()}, \tcode{rbegin()}, \tcode{end()}, and
\tcode{rend()}.
\item Subsequent to any of the above uses except the forms of \tcode{insert()}
and \tcode{erase()} which return iterators, the first call to non-const member
functions \tcode{operator[]()}, \tcode{at()}, \tcode{begin()}, \tcode{rbegin()},
\tcode{end()}, or \tcode{rend()}.
\end{itemize}

\pnum
\enternote
These rules are formulated to allow, but not require, a reference counted
implementation. A reference counted implementation must have the same semantics
as a non-reference counted implementation.
\enterexample

\begin{codeblock}
string s1("abc");

string::iterator i = s1.begin();
string s2 = s1;

*i = 'a';                       // Must modify only \tcode{s1}
\end{codeblock}

\exitexampleb
\exitnoteb

\indexlibrary{\idxcode{basic_string}}%
\begin{codeblock}
namespace std {
  template<class charT, class traits = char_traits<charT>,
           class Allocator = allocator<charT> >
  class basic_string {
  public:
    // types:
    typedef          traits                     traits_type;
    typedef typename traits::char_type          value_type;
    typedef          Allocator                  allocator_type;
    typedef typename Allocator::size_type       size_type;
    typedef typename Allocator::difference_type difference_type;

    typedef typename Allocator::reference       reference;
    typedef typename Allocator::const_reference const_reference;
    typedef typename Allocator::pointer         pointer;
    typedef typename Allocator::const_pointer   const_pointer;

    typedef @\impdef@             iterator;          // See \ref{lib.container.requirements}
    typedef @\impdef@             const_iterator;    // See \ref{lib.container.requirements}
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    static const size_type npos = -1;

    // \ref{lib.string.cons}, construct/copy/destroy:
    explicit basic_string(const Allocator& a = Allocator());
    basic_string(const basic_string& str);
    basic_string(const basic_string& str, size_type pos, size_type n = npos,
                 const Allocator& a = Allocator());
    basic_string(const charT* s,
                 size_type n, const Allocator& a = Allocator());
    basic_string(const charT* s, const Allocator& a = Allocator());
    basic_string(size_type n, charT c, const Allocator& a = Allocator());
    template<class InputIterator>
      basic_string(InputIterator begin, InputIterator end,
                   const Allocator& a = Allocator());
   ~basic_string();
    basic_string& operator=(const basic_string& str);
    basic_string& operator=(const charT* s);
    basic_string& operator=(charT c);

    // \ref{lib.string.iterators}, iterators:
    iterator       begin();
    const_iterator begin() const;
    iterator       end();
    const_iterator end() const;

    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    // \ref{lib.string.capacity}, capacity:
    size_type size() const;
    size_type length() const;
    size_type max_size() const;
    void resize(size_type n, charT c);
    void resize(size_type n);
    size_type capacity() const;
    void reserve(size_type res_arg = 0);
    void clear();
    bool empty() const;

    // \ref{lib.string.access}, element access:
    const_reference operator[](size_type pos) const;
    reference       operator[](size_type pos);
    const_reference at(size_type n) const;
    reference       at(size_type n);

    // \ref{lib.string.modifiers}, modifiers:
    basic_string& operator+=(const basic_string& str);
    basic_string& operator+=(const charT* s);
    basic_string& operator+=(charT c);
    basic_string& append(const basic_string& str);
    basic_string& append(const basic_string& str, size_type pos,
                         size_type n);
    basic_string& append(const charT* s, size_type n);
    basic_string& append(const charT* s);
    basic_string& append(size_type n, charT c);
    template<class InputIterator>
      basic_string& append(InputIterator first, InputIterator last);
    void push_back(charT c);

    basic_string& assign(const basic_string& str);
    basic_string& assign(const basic_string& str, size_type pos,
                         size_type n);
    basic_string& assign(const charT* s, size_type n);
    basic_string& assign(const charT* s);
    basic_string& assign(size_type n, charT c);
    template<class InputIterator>
      basic_string& assign(InputIterator first, InputIterator last);

    basic_string& insert(size_type pos1, const basic_string& str);
    basic_string& insert(size_type pos1, const basic_string& str,
                         size_type pos2, size_type n);
    basic_string& insert(size_type pos, const charT* s, size_type n);
    basic_string& insert(size_type pos, const charT* s);
    basic_string& insert(size_type pos, size_type n, charT c);
    iterator insert(iterator p, charT c);
    void     insert(iterator p, size_type n, charT c);
    template<class InputIterator>
      iterator insert(iterator p, InputIterator first, InputIterator last);

    basic_string& erase(size_type pos = 0, size_type n = npos);
    iterator erase(iterator position);
    iterator erase(iterator first, iterator last);

    basic_string& replace(size_type pos1, size_type n1,
                          const basic_string& str);
    basic_string& replace(size_type pos1, size_type n1,
                          const basic_string& str,
                          size_type pos2, size_type n2);
    basic_string& replace(size_type pos, size_type n1, const charT* s,
                          size_type n2);
    basic_string& replace(size_type pos, size_type n1, const charT* s);
    basic_string& replace(size_type pos, size_type n1, size_type n2,
                          charT c);

    basic_string& replace(iterator i1, iterator i2,
                          const basic_string& str);
    basic_string& replace(iterator i1, iterator i2, const charT* s,
                          size_type n);
    basic_string& replace(iterator i1, iterator i2, const charT* s);
    basic_string& replace(iterator i1, iterator i2,
                          size_type n, charT c);
    template<class InputIterator>
      basic_string& replace(iterator i1, iterator i2,
                            InputIterator j1, InputIterator j2);

    size_type copy(charT* s, size_type n, size_type pos = 0) const;
    void swap(basic_string& str);

    // \ref{lib.string.ops}, string operations:
    const charT* c_str() const;         // explicit
    const charT* data() const;
    allocator_type get_allocator() const;

    size_type find (const basic_string& str, size_type pos = 0) const;
    size_type find (const charT* s, size_type pos, size_type n) const;
    size_type find (const charT* s, size_type pos = 0) const;
    size_type find (charT c, size_type pos = 0) const;
    size_type rfind(const basic_string& str, size_type pos = npos) const;
    size_type rfind(const charT* s, size_type pos, size_type n) const;
    size_type rfind(const charT* s, size_type pos = npos) const;
    size_type rfind(charT c, size_type pos = npos) const;

    size_type find_first_of(const basic_string& str,
                            size_type pos = 0) const;
    size_type find_first_of(const charT* s,
                            size_type pos, size_type n) const;
    size_type find_first_of(const charT* s, size_type pos = 0) const;
    size_type find_first_of(charT c, size_type pos = 0) const;
    size_type find_last_of (const basic_string& str,
                            size_type pos = npos) const;
    size_type find_last_of (const charT* s,
                            size_type pos, size_type n) const;
    size_type find_last_of (const charT* s, size_type pos = npos) const;
    size_type find_last_of (charT c, size_type pos = npos) const;

    size_type find_first_not_of(const basic_string& str,
                                size_type pos = 0) const;
    size_type find_first_not_of(const charT* s, size_type pos,
                                size_type n) const;
    size_type find_first_not_of(const charT* s, size_type pos = 0) const;
    size_type find_first_not_of(charT c, size_type pos = 0) const;
    size_type find_last_not_of (const basic_string& str,
                                size_type pos = npos) const;
    size_type find_last_not_of (const charT* s, size_type pos,
                                size_type n) const;
    size_type find_last_not_of (const charT* s,
                                size_type pos = npos) const;
    size_type find_last_not_of (charT c, size_type pos = npos) const;

    basic_string substr(size_type pos = 0, size_type n = npos) const;
    int compare(const basic_string& str) const;
    int compare(size_type pos1, size_type n1,
                const basic_string& str) const;
    int compare(size_type pos1, size_type n1,
                const basic_string& str,
                size_type pos2, size_type n2) const;
    int compare(const charT* s) const;
    int compare(size_type pos1, size_type n1,
                const charT* s) const;
    int compare(size_type pos1, size_type n1,
                const charT* s, size_type n2) const;
  };
}
\end{codeblock}

\rSec2[lib.string.cons]{\tcode{basic_string} constructors}

\pnum
In all \tcode{basic_string} constructors, a copy of the \tcode{Allocator}
argument is used for any memory allocation performed by the constructor or
member functions during the lifetime of the object.

\indexlibrary{\idxcode{basic_string}!constructor}%
\begin{itemdecl}
explicit basic_string(const Allocator& a = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{basic_string}.
The postconditions of this function are indicated in Table~\ref{tab:strings.ctr.1}.

\begin{libefftabvalue}{\tcode{basic_string(const Allocator\&)} effects}{tab:strings.ctr.1}
\tcode{data()}      &   a non-null pointer that is copyable and can have 0 added to it  \\
\tcode{size()}      &   0                                                               \\
\tcode{capacity()}  &   an unspecified value                                            \\
\end{libefftabvalue}
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!constructor}%
\begin{itemdecl}
basic_string(const basic_string<charT,traits,Allocator>& str);

basic_string(const basic_string<charT,traits,Allocator>& str,
             size_type pos, size_type n = npos,
             const Allocator& a = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos <= str.size()}

\pnum
\throws
\tcode{out_of_range}
if
\tcode{pos > str.size()}.

\pnum
\effects
Constructs an object of class
\tcode{basic_string}
and determines the effective length \tcode{rlen} of the
initial string value as the smaller of \tcode{n} and \tcode{str.size() - pos},
as indicated in Table~\ref{tab:strings.ctr.2}.
In the first form, the \tcode{Allocator} value used is copied from
\tcode{str.get_allocator()}.

\begin{libefftabvalue}
{\tcode{basic_string(basic_string, size_type, size_type, const Allocator\&)} effects}
{tab:strings.ctr.2}
\tcode{data()}      &
points at the first element of an allocated copy of \tcode{rlen} consecutive elements
of the string controlled by \tcode{str} beginning at position \tcode{pos}              \\
\tcode{size()}      &   \tcode{rlen}                                                    \\
\tcode{capacity()}  &   a value at least as large as \tcode{size()}                     \\
\end{libefftabvalue}
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!constructor}%
\begin{itemdecl}
basic_string(const charT* s, size_type n,
             const Allocator& a = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{s} shall not be a null pointer and
\tcode{n < npos}.

\pnum
\enternote This paragraph is intentionally empty. \exitnoteb

\pnum
\effects
Constructs an object of class
\tcode{basic_string}
and determines its initial string value from the array of
\tcode{charT}
of length \tcode{n} whose first element is designated by \tcode{s},
as indicated in Table~\ref{tab:strings.ctr.3}.

\begin{libefftabvalue}
{\tcode{basic_string(const charT*, size_type, const Allocator\&)} effects}
{tab:strings.ctr.3}
\tcode{data()}      &
points at the first element of an allocated copy of the array whose first element
is pointed at by \tcode{s}                                                              \\
\tcode{size()}      &   \tcode{n}                                                       \\
\tcode{capacity()}  &   a value at least as large as \tcode{size()}                     \\
\end{libefftabvalue}
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!constructor}%
\begin{itemdecl}
basic_string(const charT* s, const Allocator& a = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{s} shall not be a null pointer.

\pnum
\effects
Constructs an object of class
\tcode{basic_string}
and determines its initial string value from the array of
\tcode{charT}
of length
\tcode{traits::length(s)}
whose first element is designated
by \tcode{s},
as indicated in Table~\ref{tab:strings.ctr.4}.

\begin{libefftabvalue}
{\tcode{basic_string(const charT*, const Allocator\&)} effects}
{tab:strings.ctr.4}
\tcode{data()}      &
points at the first element of an allocated copy of the array whose first element
is pointed at by \tcode{s}                                                              \\
\tcode{size()}      &   \tcode{traits::length(s)}                                       \\
\tcode{capacity()}  &   a value at least as large as \tcode{size()}                     \\
\end{libefftabvalue}

\pnum
\notes
Uses
\tcode{traits::length()}.
\indexlibrary{\idxcode{length}!\tcode{char_traits}}%
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!constructor}%
\begin{itemdecl}
basic_string(size_type n, charT c, const Allocator& a = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{n < npos}

\pnum
\enternote This paragraph is intentionally empty. \exitnoteb

\pnum
\effects
Constructs an object of class
\tcode{basic_string}
and determines its initial string value by repeating the char-like
object \tcode{c} for all \tcode{n} elements,
as indicated in Table~\ref{tab:strings.ctr.5}.

\begin{libefftabvalue}
{\tcode{basic_string(size_type, charT, const Allocator\&)} effects}
{tab:strings.ctr.5}
\tcode{data()}      &
points at the first element of an allocated array of \tcode{n} elements, each
storing the initial value \tcode{c}                                                     \\
\tcode{size()}      &   \tcode{n}                                                       \\
\tcode{capacity()}  &   a value at least as large as \tcode{size()}                     \\
\end{libefftabvalue}
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!constructor}%
\begin{itemdecl}
template<class InputIterator>
  basic_string(InputIterator begin, InputIterator end,
               const Allocator& a = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{InputIterator} is an integral type,
equivalent to

\begin{codeblock}
  basic_string(static_cast<size_type>(begin), static_cast<value_type>(end))
\end{codeblock}

Otherwise constructs a string from the values in the range [\tcode{begin}, \tcode{end}),
as indicated in the Sequence Requirements table
(see~\ref{lib.sequence.reqmts}).
%
\end{itemdescr}


\indexlibrary{\idxcode{operator=}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{operator=}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>&
  operator=(const basic_string<charT,traits,Allocator>& str);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If
\tcode{*this}
and \tcode{str} are not the same object,
modifies
\tcode{*this}
as shown in Table~\ref{tab:strings.op=}.

\begin{libefftabvalue}
{\tcode{operator=(const basic_string<charT, traits, Allocator>\&)} effects}
{tab:strings.op=}
\tcode{data()}      &
points at the first element of an allocated copy of the array whose first
element is pointed at by \tcode{str.data()}                                             \\
\tcode{size()}      &   \tcode{str.size()}                                              \\
\tcode{capacity()}  &   a value at least as large as \tcode{size()}                     \\
\end{libefftabvalue}

If
\tcode{*this}
and \tcode{str} are the same object,
the member has no effect.

\pnum
\returns
\tcode{*this}
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{operator=}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>&
  operator=(const charT* s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*this = basic_string<charT,traits,Allocator>(s)}.

\pnum
\notes
Uses
\indexlibrary{\idxcode{length}!\tcode{char_traits}}%
\tcode{traits::length()}.
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{operator=}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>& operator=(charT c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*this = basic_string<charT,traits,Allocator>(1,c)}.
\end{itemdescr}

\rSec2[lib.string.iterators]{\tcode{basic_string} iterator support}

\indexlibrary{\idxcode{basic_string}!\idxcode{begin}}%
\indexlibrary{\idxcode{begin}!\idxcode{basic_string}}%
\begin{itemdecl}
iterator       begin();
const_iterator begin() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
an iterator referring to the first character in the string.
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{end}}%
\begin{itemdecl}
iterator       end();
const_iterator end() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
an iterator which is the past-the-end value.
\end{itemdescr}

\indexlibrary{\idxcode{rbegin}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{rbegin}}%
\begin{itemdecl}
reverse_iterator       rbegin();
const_reverse_iterator rbegin() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
an iterator which is semantically equivalent to
\tcode{reverse_iterator(end())}.
\end{itemdescr}

\indexlibrary{\idxcode{rend}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{rend}}%
\begin{itemdecl}
reverse_iterator       rend();
const_reverse_iterator rend() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
an iterator which is semantically equivalent to
\tcode{reverse_iterator(begin())}.
\end{itemdescr}

\rSec2[lib.string.capacity]{\tcode{basic_string} capacity}

\indexlibrary{\idxcode{basic_string}!\idxcode{size}}%
\indexlibrary{\idxcode{size}!\idxcode{basic_string}}%
\begin{itemdecl}
size_type size() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
a count of the number of char-like objects currently in the string.
\end{itemdescr}

\indexlibrary{\idxcode{length}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{length}}%
\begin{itemdecl}
size_type length() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{size()}.
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!\idxcode{max_size}}%
\indexlibrary{\idxcode{max_size}!\idxcode{basic_string}}%
\begin{itemdecl}
size_type max_size() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The maximum size of the string.

\pnum
\note
See Container requirements table~(\ref{lib.container.requirements}).
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!\idxcode{resize}}%
\indexlibrary{\idxcode{resize}!\idxcode{basic_string}}%
\begin{itemdecl}
void resize(size_type n, charT c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{n <= max_size()}

\pnum
\throws
\tcode{length_error}
if
\tcode{n > max_size()}.

\pnum
\effects
Alters the length of the string designated by
\tcode{*this}
as follows:

\begin{itemize}
\item
If
\tcode{n <= size()},
the function replaces the string designated by
\tcode{*this}
with a string of length \tcode{n} whose elements are a
copy of the initial elements of the original string designated by
\tcode{*this}.
\item
If
\tcode{n > size()},
the function replaces the string designated by
\tcode{*this}
with a string of length \tcode{n} whose first
\tcode{size()}
elements are a copy of the original string designated by
\tcode{*this},
and whose remaining elements are all initialized to \tcode{c}.
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{resize}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{resize}}%
\begin{itemdecl}
void resize(size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\tcode{resize(n,charT())}.
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!\idxcode{capacity}}%
\indexlibrary{\idxcode{capacity}!\idxcode{basic_string}}%
\begin{itemdecl}
size_type capacity() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
the size of the allocated storage in the string.
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!\idxcode{reserve}}%
\indexlibrary{\idxcode{reserve}!\idxcode{basic_string}}%
\begin{itemdecl}
void reserve(size_type res_arg=0);
\end{itemdecl}

\begin{itemdescr}
\pnum
The member function
\tcode{reserve()}
is a directive that informs a
\tcode{basic_string}
object of a planned change in size,
so that it can manage the storage allocation accordingly.

\pnum
\effects
After
\tcode{reserve()},
\tcode{capacity()}
is greater or equal to the argument of
\tcode{reserve}.
\enternote
Calling
\tcode{reserve()}
with a \tcode{res_arg} argument less than
\tcode{capacity()}
is in effect a non-binding shrink request.
A call with
\tcode{res_arg <= size()}
is in effect a non-binding shrink-to-fit request.
\exitnoteb

\pnum
\throws
\tcode{length_error}
if
\tcode{res_arg > max_size()}.\footnote{\tcode{reserve()}
uses
\tcode{Allocator::allocate()}
which may throw an appropriate exception.}
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!\idxcode{clear}}%
\indexlibrary{\idxcode{clear}!\idxcode{basic_string}}%
\begin{itemdecl}
void clear();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Behaves as if the function calls:

\begin{codeblock}
erase(begin(), end());
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!\idxcode{empty}}%
\indexlibrary{\idxcode{empty}!\idxcode{basic_string}}%
\begin{itemdecl}
bool empty() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{size() == 0}.
\end{itemdescr}

\rSec2[lib.string.access]{\tcode{basic_string} element access}

\indexlibrary{\idxcode{basic_string}!\idxcode{operator[]}}%
\indexlibrary{\idxcode{operator[]}!\idxcode{basic_string}}%
\begin{itemdecl}
const_reference operator[](size_type pos) const;
reference       operator[](size_type pos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns If \tcode{pos < size()}, returns \tcode{data()[pos]}.
Otherwise if \tcode{pos == size()}, the \tcode{const} version returns
\tcode{charT()}. Otherwise, the behavior is undefined.
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!\idxcode{at}}%
\indexlibrary{\idxcode{at}!\idxcode{basic_string}}%
\begin{itemdecl}
const_reference at(size_type pos) const;
reference       at(size_type pos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos < size()}

\pnum
\throws
\tcode{out_of_range}
if
\tcode{pos >= size()}.

\pnum
\returns
\tcode{operator[](pos)}.
\end{itemdescr}

\rSec2[lib.string.modifiers]{\tcode{basic_string} modifiers}

\rSec3[lib.string::op+=]{\tcode{basic_string::operator+=}}

\indexlibrary{\idxcode{basic_string}!\idxcode{operator+=}}%
\indexlibrary{\idxcode{operator+=}!\idxcode{basic_string}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>&
  operator+=(const basic_string<charT,traits,Allocator>& str);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns append(str).
\end{itemdescr}

\indexlibrary{\idxcode{operator+=}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{operator+=}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>& operator+=(const charT* s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*this += basic_string<charT,traits,Allocator>(s)}.

\pnum
\notes
Uses \tcode{traits::length()}.
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!\idxcode{operator+=}}%
\indexlibrary{\idxcode{operator+=}!\idxcode{basic_string}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>& operator+=(charT c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{*this += basic_string<charT,traits,Allocator>(1,c)};
\end{itemdescr}


\rSec3[lib.string::append]{\tcode{basic_string::append}}

\indexlibrary{\idxcode{basic_string}!\idxcode{append}}%
\indexlibrary{\idxcode{append}!\idxcode{basic_string}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>&
  append(const basic_string<charT,traits>& str);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{append(str, 0, npos)}.
\end{itemdescr}

\indexlibrary{\idxcode{append}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{append}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>&
  append(const basic_string<charT,traits>& str, size_type pos, size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos <= str.size()}

\pnum
\throws
\tcode{out_of_range}
if
\tcode{pos > str.size()}.

\pnum
\effects
Determines the effective length \tcode{rlen}
of the string to append as the smaller of \tcode{n} and
\tcode{\tcode{str}.size() - \tcode{pos}}.
The function then throws \tcode{length_error} if \tcode{size() >= npos - rlen}.

Otherwise, the function replaces the string controlled by \tcode{*this} with
a string of length \tcode{size() + rlen} whose first \tcode{size()} elements
are a copy of the original string controlled by \tcode{*this} and whose
remaining elements are a copy of the initial elements of the string controlled
by \tcode{str} beginning at position \tcode{pos}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{append}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{append}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>&
  append(const charT* s, size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{append(basic_string<charT,traits,Allocator>(s,n))}.
\end{itemdescr}

\indexlibrary{\idxcode{append}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{append}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>& append(const charT* s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{append(basic_string<charT,traits,Allocator>(s))}.

\pnum
\notes
Uses \tcode{traits::length()}.
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!\idxcode{append}}%
\indexlibrary{\idxcode{append}!\idxcode{basic_string}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>&
  append(size_type n, charT c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{append(basic_string<charT,traits,Allocator>(n,c))}.
\end{itemdescr}

\indexlibrary{\idxcode{append}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{append}}%
\begin{itemdecl}
template<class InputIterator>
  basic_string& append(InputIterator first, InputIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{append(basic_string<charT,traits,Allocator>(first,last))}.
\end{itemdescr}

\indexlibrary{\idxcode{push_back}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{push_back}}%
\begin{itemdecl}
void push_back(charT c)
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to
\tcode{append(static_cast<size_type>(1), c)}.
\end{itemdescr}

\rSec3[lib.string::assign]{\tcode{basic_string::assign}}

\indexlibrary{\idxcode{basic_string}!\idxcode{assign}}%
\indexlibrary{\idxcode{assign}!\idxcode{basic_string}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>&
  assign(const basic_string<charT,traits>& str);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{assign(str, 0, npos)}.
\end{itemdescr}

\indexlibrary{\idxcode{assign}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{assign}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>&
  assign(const basic_string<charT,traits>& str, size_type pos,
         size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos <= str.size()}

\pnum
\throws
\tcode{out_of_range}
if
\tcode{pos > str.size()}.

\pnum
\effects
Determines the effective length \tcode{rlen}
of the string to assign as the smaller of \tcode{n} and
\tcode{\tcode{str}.size() - \tcode{pos}}.

The function then replaces the string controlled by \tcode{*this} with a
string of length \tcode{rlen} whose elements are a copy of the string
controlled by \tcode{str} beginning at position \tcode{pos}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{assign}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{assign}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>&
  assign(const charT* s, size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{assign(basic_string<charT,traits,Allocator>(s,n))}.
\end{itemdescr}

\indexlibrary{\idxcode{assign}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{assign}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>& assign(const charT* s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{assign(basic_string<charT,traits,Allocator>(s))}.

\pnum
\notes Uses \tcode{traits::length()}.
\end{itemdescr}

\indexlibrary{\idxcode{length}!\tcode{char_traits}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>&
  assign(size_type n, charT c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{assign(basic_string<charT,traits,Allocator>(n,c))}.
\end{itemdescr}

\indexlibrary{\idxcode{assign}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{assign}}%
\begin{itemdecl}
template<class InputIterator>
  basic_string& assign(InputIterator first, InputIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{assign(basic_string<charT,traits,Allocator>(first,last))}.
\end{itemdescr}

\rSec3[lib.string::insert]{\tcode{basic_string::insert}}

\indexlibrary{\idxcode{basic_string}!\idxcode{insert}}%
\indexlibrary{\idxcode{insert}!\idxcode{basic_string}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>&
  insert(size_type pos1,
         const basic_string<charT,traits,Allocator>& str);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{insert(pos1,str,0,npos)}.
\end{itemdescr}

\indexlibrary{\idxcode{insert}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{insert}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>&
  insert(size_type pos1,
         const basic_string<charT,traits,Allocator>& str,
         size_type pos2, size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos1 <= size()}
and
\tcode{pos2 <= str.size()}

\pnum
\throws
\tcode{out_of_range}
if
\tcode{pos1 > size()}
or
\tcode{pos2 > str.size()}.

\pnum
\effects
Determines the effective length \tcode{rlen} of the string to insert as the smaller
of \tcode{n} and
\tcode{str.size() - pos2}. Then throws \tcode{length_error} if
\tcode{size() >= npos - rlen}.

Otherwise, the function replaces the string controlled by \tcode{*this}
with a string of length \tcode{size() + rlen} whose first \tcode{pos1}
elements are a copy of the initial elements of the original string controlled
by \tcode{*this}, whose next \tcode{rlen} elements are a copy of the elements
of the string controlled by \tcode{str} beginning at position \tcode{pos2},
and whose remaining elements are a copy of the remaining elements of the
original string controlled by \tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{insert}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{insert}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>&
  insert(size_type pos, const charT* s, size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{insert(pos,basic_string<charT,traits,Allocator>(s,n))}.
\end{itemdescr}

\indexlibrary{\idxcode{insert}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{insert}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>&
  insert(size_type pos, const charT* s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{insert(pos,basic_string<charT,traits,Allocator>(s))}.

\pnum
\notes
Uses \tcode{traits::length()}.
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!\idxcode{insert}}%
\indexlibrary{\idxcode{insert}!\idxcode{basic_string}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>&
  insert(size_type pos, size_type n, charT c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{insert(pos,basic_string<charT,traits,Allocator>(n,c))}.
\end{itemdescr}

\indexlibrary{\idxcode{insert}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{insert}}%
\begin{itemdecl}
iterator insert(iterator p, charT c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{p} is a valid iterator on
\tcode{*this}.

\pnum
\effects
inserts a copy of \tcode{c} before the character referred to by \tcode{p}.

\pnum
\returns
an iterator which refers to the copy of the inserted character.
\end{itemdescr}

\indexlibrary{\idxcode{insert}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{insert}}%
\begin{itemdecl}
void insert(iterator p, size_type n, charT c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{p} is a valid iterator on
\tcode{*this}.

\pnum
\effects
inserts \tcode{n} copies of \tcode{c} before the character referred to by \tcode{p}.
\end{itemdescr}

\indexlibrary{\idxcode{insert}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{insert}}%
\begin{itemdecl}
template<class InputIterator>
  void insert(iterator p, InputIterator first, InputIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{p} is a valid iterator on
\tcode{*this}.
\tcode{[first,last)}
is a valid range.

\pnum
\effects
Equivalent to
\tcode{insert(p - begin(), basic_string(first, last))}.
\end{itemdescr}

\rSec3[lib.string::erase]{\tcode{basic_string::erase}}

\indexlibrary{\idxcode{basic_string}!\idxcode{erase}}%
\indexlibrary{\idxcode{erase}!\idxcode{basic_string}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>&
  erase(size_type pos = 0, size_type n = npos);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos}
\tcode{ <= size()}

\pnum
\throws
\tcode{out_of_range}
if \tcode{pos}
\tcode{> size()}.

\pnum
\effects
Determines the effective length \tcode{xlen}
of the string to be removed as the smaller of \tcode{n} and
\tcode{size() - pos}.

The function then replaces the string controlled by
\tcode{*this}
with a string of length
\tcode{size() - xlen}
whose first \tcode{pos} elements are a copy of the initial elements of the original string controlled by
\tcode{*this},
and whose remaining elements are a copy of the elements of the original string controlled by
\tcode{*this}
beginning at position
\tcode{pos + xlen}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{erase}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{erase}}%
\begin{itemdecl}
iterator erase(iterator p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{p} is a valid iterator on \tcode{*this}.

\pnum
\effects
removes the character referred to by \tcode{p}.

\pnum
\returns
an iterator which points to the element immediately following \tcode{p} prior to
the element being erased.
If no such element exists,
\tcode{end()}
is returned.
\end{itemdescr}

\indexlibrary{\idxcode{erase}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{erase}}%
\begin{itemdecl}
iterator erase(iterator first, iterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{first} and \tcode{last} are valid iterators on
\tcode{*this},
defining a range
\tcode{[first,last)}.

\pnum
\effects
removes the characters in the range
\tcode{[first,last)}.

\pnum
\returns
an iterator which points to the element pointed to by \tcode{last} prior to
the other elements being erased.
If no such element exists,
\tcode{end()}
is returned.
\end{itemdescr}

\rSec3[lib.string::replace]{\tcode{basic_string::replace}}

\indexlibrary{\idxcode{basic_string}!\idxcode{replace}}%
\indexlibrary{\idxcode{replace}!\idxcode{basic_string}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>&
  replace(size_type pos1, size_type n1,
          const basic_string<charT,traits,Allocator>& str);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{replace(pos1, n1, str, 0, npos)}.
\end{itemdescr}

\indexlibrary{\idxcode{replace}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{replace}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>&
  replace(size_type pos1, size_type n1,
          const basic_string<charT,traits,Allocator>& str,
          size_type pos2, size_type n2);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos1 <= size() \&\& pos2 <= str.size()}.

\pnum
\throws
\tcode{out_of_range}
if
\tcode{pos1 > size()}
or
\tcode{pos2 > str.size()}.

\pnum
\effects
Determines the effective length \tcode{xlen} of the string to be removed
as the smaller of \tcode{n1} and \tcode{size() - pos1}. It also determines
the effective length \tcode{rlen} of the string to be inserted as the
smaller of \tcode{n2} and \tcode{str.size() - pos2}.

\pnum
\throws
\tcode{length_error} if \tcode{size() - xlen >= npos - rlen}.

Otherwise, the function replaces the string controlled by \tcode{*this}
with a string of length \tcode{size() - xlen + rlen} whose first \tcode{pos1}
elements are a copy of the initial elements of the original string controlled
by \tcode{*this}, whose next \tcode{rlen} elements are a copy of the initial
elements of the string controlled by \tcode{str} beginning at position
\tcode{pos2}, and whose remaining elements are a copy of the elements of the
original string controlled by \tcode{*this} beginning at position
\tcode{pos1 + xlen}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{replace}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{replace}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>&
  replace(size_type pos, size_type n1, const charT* s, size_type n2);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{replace(pos,n1,basic_string<charT,traits,Allocator>(s,n2))}.
\end{itemdescr}

\indexlibrary{\idxcode{replace}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{replace}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>&
  replace(size_type pos, size_type n1, const charT* s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{replace(pos,n1,basic_string<charT,traits,Allocator>(s)}.

\pnum
\notes
Uses \tcode{traits::length()}.
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!\idxcode{replace}}%
\indexlibrary{\idxcode{replace}!\idxcode{basic_string}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>&
  replace(size_type pos, size_type n1,
          size_type n2, charT c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{replace(pos,n1,basic_string<charT,traits,Allocator>(n2,c))}.
\end{itemdescr}

\indexlibrary{\idxcode{replace}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{replace}}%
\begin{itemdecl}
basic_string& replace(iterator i1, iterator i2, const basic_string& str);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The iterators \tcode{i1} and \tcode{i2} are valid iterators on \tcode{*this},
defining a range \tcode{[i1,i2)}.

\pnum
\effects
Replaces the string controlled by \tcode{*this} with a string of length
\tcode{size() - (i2 - i1) + str.size()} whose first \tcode{begin() - i1}
elements are a copy of the initial elements of the original string controlled
by \tcode{*this}, whose next \tcode{str.size()} elements are a copy of the
string controlled by \tcode{str}, and whose remaining elements are a copy
of the elements of the original string controlled by \tcode{*this} beginning
at position \tcode{i2}.

\pnum
\returns
\tcode{*this}.

\pnum
\notes
After the call, the length of the string will be changed by:
\tcode{str.size() - (i2 - i1)}.
\end{itemdescr}

\indexlibrary{\idxcode{replace}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{replace}}%
\begin{itemdecl}
basic_string&
  replace(iterator i1, iterator i2, const charT* s, size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{replace(i1,i2,basic_string(s,n))}.

\pnum
\notes
Length change: \tcode{n - (i2 - i1)}.
\end{itemdescr}

\indexlibrary{\idxcode{replace}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{replace}}%
\begin{itemdecl}
basic_string& replace(iterator i1, iterator i2, const charT* s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{replace(i1,i2,basic_string(s))}.

\pnum
\notes
Length change: \tcode{traits::length(s) - (i2 - i1)}.

Uses \tcode{traits::length()}.
\end{itemdescr}

\indexlibrary{\idxcode{replace}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{replace}}%
\begin{itemdecl}
basic_string& replace(iterator i1, iterator i2, size_type n,
                      charT c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{replace(i1,i2,basic_string(n,c))}.

\pnum
\notes
Length change: \tcode{n - (i2 - i1)}.
\end{itemdescr}

\indexlibrary{\idxcode{replace}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{replace}}%
\begin{itemdecl}
template<class InputIterator>
  basic_string& replace(iterator i1, iterator i2,
                        InputIterator j1, InputIterator j2);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{replace(i1,i2,basic_string(j1,j2))}.

\pnum
\notes
Length change: \tcode{j2 - j1 - (i2 - i1)}.
\end{itemdescr}


\rSec3[lib.string::copy]{\tcode{basic_string::copy}}

\indexlibrary{\idxcode{basic_string}!\idxcode{copy}}%
\indexlibrary{\idxcode{copy}!\idxcode{basic_string}}%
\begin{itemdecl}
size_type copy(charT* s, size_type n, size_type pos = 0) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos <= size()}

\pnum
\throws
\tcode{out_of_range}
if
\tcode{pos > size()}.

\pnum
\effects
Determines the effective length \tcode{rlen}
of the string to copy as the smaller of \tcode{n} and
\tcode{size() - pos}.
\tcode{s} shall designate an array of at least \tcode{rlen} elements.

The function then replaces the string designated by \tcode{s}
with a string of length \tcode{rlen} whose elements are a copy of the
string controlled by
\tcode{*this}
beginning at position \tcode{pos}.

The function does not append a null object to the string designated
by \tcode{s}.

\pnum
\returns
\tcode{rlen}.
\end{itemdescr}

\rSec3[lib.string::swap]{\tcode{basic_string::swap}}

\indexlibrary{\idxcode{basic_string}!\idxcode{swap}}%
\indexlibrary{\idxcode{swap}!\idxcode{basic_string}}%
\begin{itemdecl}
void swap(basic_string<charT,traits,Allocator>& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Swaps the contents of the two strings.

\pnum
\postcondition
\tcode{*this}
contains the characters that were in \tcode{s},
\tcode{s} contains the characters that were in
\tcode{*this}.

\pnum
\complexity
constant time.
\end{itemdescr}

\rSec2[lib.string.ops]{\tcode{basic_string} string operations}

\indexlibrary{\idxcode{c_str}!\tcode{basic_string}}%
\begin{itemdecl}
const charT* c_str() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A pointer to the initial element of an array of length
\tcode{size() + 1} whose first \tcode{size()} elements equal the
corresponding elements of the string controlled by \tcode{*this}
and whose last element is a null character specified by \tcode{charT()}.

\pnum
\requires
The program shall not alter any of the values stored in the array.
Nor shall the program treat the returned value as a valid pointer
value after any subsequent call to a non-const member function of the
class \tcode{basic_string} that designates the same object as \tcode{this}.
\end{itemdescr}

\indexlibrary{\idxcode{data}!\tcode{basic_string}}%
\begin{itemdecl}
const charT* data() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns If \tcode{size()} is nonzero, the member returns a pointer to the 
initial element of an array whose first \tcode{size()} elements equal the
corresponding elements of the string controlled by \tcode{*this}.
If \tcode{size()} is zero, the member returns a non-null pointer that is
copyable and can have zero added to it.

\pnum
\requires
The program shall not alter any of the values stored in the character array.
Nor shall the program treat the returned value as a valid pointer
value after any subsequent call to a non-\tcode{const} member function of
\tcode{basic_string} that designates the same object as \tcode{this}.
\end{itemdescr}

\indexlibrary{\idxcode{get_allocator}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{get_allocator}}%
\begin{itemdecl}
allocator_type get_allocator() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
a copy of the
\tcode{Allocator}
object used to construct the string.
\end{itemdescr}

\rSec3[lib.string::find]{\tcode{basic_string::find}}

\indexlibrary{\idxcode{basic_string}!\idxcode{find}}%
\indexlibrary{\idxcode{find}!\idxcode{basic_string}}%
\begin{itemdecl}
size_type find(const basic_string<charT,traits,Allocator>& str,
               size_type pos = 0) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Determines the lowest position \tcode{xpos}, if possible, such that both of
the following conditions obtain:

\begin{itemize}
\item
\tcode{pos <= xpos} and
\tcode{xpos + str.size() <= size()};
\item
\indexlibrary{\idxcode{eq}!\tcode{char_traits}}%
\tcode{at(xpos+I) == str.at(I)}
for all elements \tcode{I} of the string controlled by \tcode{str}.
\end{itemize}

\pnum
\returns
\tcode{xpos} if the function can determine such a value for \tcode{xpos}.
Otherwise, returns
\tcode{npos}.

\pnum
\notes
Uses
\tcode{traits::eq()}.
\end{itemdescr}

\indexlibrary{\idxcode{find}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{find}}%
\begin{itemdecl}
size_type find(const charT* s, size_type pos, size_type n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{find(basic_string<charT,traits,Allocator>(s,n),pos)}.
\end{itemdescr}

\indexlibrary{\idxcode{find}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{find}}%
\begin{itemdecl}
size_type find(const charT* s, size_type pos = 0) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{find(basic_string<charT,traits,Allocator>(s),pos)}.

\pnum
\notes
Uses \tcode{traits::length()}.
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!\idxcode{find}}%
\indexlibrary{\idxcode{find}!\idxcode{basic_string}}%
\begin{itemdecl}
size_type find(charT c, size_type pos = 0) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{find(basic_string<charT,traits,Allocator>(1,c),pos)}.
\end{itemdescr}

\rSec3[lib.string::rfind]{\tcode{basic_string::rfind}}

\indexlibrary{\idxcode{basic_string}!\idxcode{rfind}}%
\indexlibrary{\idxcode{rfind}!\idxcode{basic_string}}%
\begin{itemdecl}
size_type rfind(const basic_string<charT,traits,Allocator>& str,
                size_type pos = npos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Determines the highest position \tcode{xpos}, if possible, such that both of
the following conditions obtain:

\begin{itemize}
\item
\tcode{xpos <= pos}
and
\tcode{xpos + str.size() <= size()};
\item
\indexlibrary{\idxcode{eq}!\tcode{char_traits}}%
\tcode{at(xpos+I) == str.at(I)}
for all elements \tcode{I} of the string controlled by \tcode{str}.
\end{itemize}

\pnum
\returns
\tcode{xpos} if the function can determine such a value for \tcode{xpos}.
Otherwise, returns
\tcode{npos}.

\pnum
\notes
Uses
\tcode{traits::eq()}.
\end{itemdescr}

\indexlibrary{\idxcode{rfind}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{rfind}}%
\begin{itemdecl}
size_type rfind(const charT* s, size_type pos, size_type n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rfind(basic_string<charT,traits,Allocator>(s,n),pos)}.
\end{itemdescr}

\indexlibrary{\idxcode{rfind}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{rfind}}%
\begin{itemdecl}
size_type rfind(const charT* s, size_type pos = npos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rfind(basic_string<charT,traits,Allocator>(s),pos)}.

\pnum
\notes
Uses \tcode{traits::length()}.
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!\idxcode{rfind}}%
\indexlibrary{\idxcode{rfind}!\idxcode{basic_string}}%
\begin{itemdecl}
size_type rfind(charT c, size_type pos = npos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rfind(basic_string<charT,traits,Allocator>(1,c),pos)}.
\end{itemdescr}

\rSec3[lib.string::find.first.of]{\tcode{basic_string::find_first_of}}

\indexlibrary{\idxcode{basic_string}!\idxcode{find_first_of}}%
\indexlibrary{\idxcode{find_first_of}!\idxcode{basic_string}}%
\begin{itemdecl}
size_type
  find_first_of(const basic_string<charT,traits,Allocator>& str,
                size_type pos = 0) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Determines the lowest position \tcode{xpos}, if possible, such that both of
the following conditions obtain:

\begin{itemize}
\item
\tcode{pos <= xpos}
and
\tcode{xpos < size()};
\item
\indexlibrary{\idxcode{eq}!\tcode{char_traits}}%
\tcode{at(xpos) == str.at(I)}
for some element \tcode{I} of the string controlled by \tcode{str}.
\end{itemize}

\pnum
\returns
\tcode{xpos} if the function can determine such a value for \tcode{xpos}.
Otherwise, returns
\tcode{npos}.

\pnum
\notes
Uses
\tcode{traits::eq()}.
\end{itemdescr}

\indexlibrary{\idxcode{find_first_of}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{find_first_of}}%
\begin{itemdecl}
size_type
  find_first_of(const charT* s, size_type pos, size_type n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{find_first_of(basic_string<charT,traits,Allocator>(s,n),pos)}.
\end{itemdescr}

\indexlibrary{\idxcode{find_first_of}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{find_first_of}}%
\begin{itemdecl}
size_type find_first_of(const charT* s, size_type pos = 0) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{find_first_of(basic_string<charT,traits,Allocator>(s),pos)}.

\pnum
\notes
Uses \tcode{traits::length()}.
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!\idxcode{find_first_of}}%
\indexlibrary{\idxcode{find_first_of}!\idxcode{basic_string}}%
\begin{itemdecl}
size_type find_first_of(charT c, size_type pos = 0) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{find_first_of(basic_string<charT,traits,Allocator>(1,c),pos)}.
\end{itemdescr}

\rSec3[lib.string::find.last.of]{\tcode{basic_string::find_last_of}}

\indexlibrary{\idxcode{basic_string}!\idxcode{find_last_of}}%
\indexlibrary{\idxcode{find_last_of}!\idxcode{basic_string}}%
\begin{itemdecl}
size_type
  find_last_of(const basic_string<charT,traits,Allocator>& str,
               size_type pos = npos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Determines the highest position \tcode{xpos}, if possible, such that both of
the following conditions obtain:

\begin{itemize}
\item
\tcode{xpos <= pos}
and
\tcode{xpos < size()};
\item
\indexlibrary{\idxcode{eq}!\tcode{char_traits}}%
\tcode{at(xpos) == str.at(I)}
for some element \tcode{I} of the string controlled by \tcode{str}.
\end{itemize}

\pnum
\returns
\tcode{xpos} if the function can determine such a value for \tcode{xpos}.
Otherwise, returns
\tcode{npos}.

\pnum
\notes
Uses
\tcode{traits::eq()}.
\end{itemdescr}

\indexlibrary{\idxcode{find_last_of}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{find_last_of}}%
\begin{itemdecl}
size_type find_last_of(const charT* s, size_type pos, size_type n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{find_last_of(basic_string<charT,traits,Allocator>(s,n),pos)}.
\end{itemdescr}

\indexlibrary{\idxcode{find_last_of}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{find_last_of}}%
\begin{itemdecl}
size_type find_last_of(const charT* s, size_type pos = npos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{find_last_of(basic_string<charT,traits,Allocator>(s),pos)}.

\pnum
\notes
Uses \tcode{traits::length()}.
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!\idxcode{find_last_of}}%
\indexlibrary{\idxcode{find_last_of}!\idxcode{basic_string}}%
\begin{itemdecl}
size_type find_last_of(charT c, size_type pos = npos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{find_last_of(basic_string<charT,traits,Allocator>(1,c),pos)}.
\end{itemdescr}

\rSec3[lib.string::find.first.not.of]{\tcode{basic_string::find_first_not_of}}

\indexlibrary{\idxcode{basic_string}!\idxcode{find_first_not_of}}%
\indexlibrary{\idxcode{find_first_not_of}!\idxcode{basic_string}}%
\begin{itemdecl}
size_type
  find_first_not_of(const basic_string<charT,traits,Allocator>& str,
                    size_type pos = 0) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Determines the lowest position \tcode{xpos}, if possible, such that both of
the following conditions obtain:

\begin{itemize}
\item
\tcode{pos <= xpos}
and
\tcode{xpos < size()};
\item
\indexlibrary{\idxcode{eq}!\tcode{char_traits}}%
\tcode{at(xpos) == str.at(I)}
for no element \tcode{I} of the string controlled by \tcode{str}.
\end{itemize}

\pnum
\returns
\tcode{xpos} if the function can determine such a value for \tcode{xpos}.
Otherwise, returns
\tcode{npos}.

\pnum
\notes
Uses
\tcode{traits::eq()}.
\end{itemdescr}

\indexlibrary{\idxcode{find_first_not_of}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{find_first_not_of}}%
\begin{itemdecl}
size_type
  find_first_not_of(const charT* s, size_type pos, size_type n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{find_first_not_of(basic_string<charT,traits,Allocator>(s,n),pos)}.
\end{itemdescr}

\indexlibrary{\idxcode{find_first_not_of}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{find_first_not_of}}%
\begin{itemdecl}
size_type find_first_not_of(const charT* s, size_type pos = 0) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{find_first_not_of(basic_string<charT,traits,Allocator>(s),pos)}.

\pnum
\notes
Uses \tcode{traits::length()}.
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!\idxcode{find_first_not_of}}%
\indexlibrary{\idxcode{find_first_not_of}!\idxcode{basic_string}}%
\begin{itemdecl}
size_type find_first_not_of(charT c, size_type pos = 0) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{find_first_not_of(basic_string<charT,traits,Allocator>(1,c),pos)}.
\end{itemdescr}

\rSec3[lib.string::find.last.not.of]{\tcode{basic_string::find_last_not_of}}

\indexlibrary{\idxcode{basic_string}!\idxcode{find_last_not_of}}%
\indexlibrary{\idxcode{find_last_not_of}!\idxcode{basic_string}}%
\begin{itemdecl}
size_type
  find_last_not_of(const basic_string<charT,traits,Allocator>& str,
                   size_type pos = npos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Determines the highest position \tcode{xpos}, if possible, such that both of
the following conditions obtain:

\begin{itemize}
\item
\tcode{xpos <= pos}
and
\tcode{xpos < size()};
\item
\indexlibrary{\idxcode{eq}!\tcode{char_traits}}%
\tcode{at(xpos) == str.at(I)}
for no element \tcode{I} of the string
controlled by \tcode{str}.
\end{itemize}

\pnum
\returns
\tcode{xpos} if the function can determine such a value for \tcode{xpos}.
Otherwise, returns
\tcode{npos}.

\pnum
\notes
Uses
\tcode{traits::eq()}.
\end{itemdescr}

\indexlibrary{\idxcode{find_last_not_of}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{find_last_not_of}}%
\begin{itemdecl}
size_type find_last_not_of(const charT* s, size_type pos,
                           size_type n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{find_last_not_of(basic_string<charT,traits,Allocator>(s,n),pos)}.
\end{itemdescr}

\indexlibrary{\idxcode{find_last_not_of}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{find_last_not_of}}%
\begin{itemdecl}
size_type find_last_not_of(const charT* s, size_type pos = npos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{find_last_not_of(basic_string<charT,traits,Allocator>(s),pos)}.

\pnum
\notes
Uses \tcode{traits::length()}.
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!\idxcode{find_last_not_of}}%
\indexlibrary{\idxcode{find_last_not_of}!\idxcode{basic_string}}%
\begin{itemdecl}
size_type find_last_not_of(charT c, size_type pos = npos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{find_last_not_of(basic_string<charT,traits,Allocator>(1,c),pos)}.
\end{itemdescr}

\rSec3[lib.string::substr]{\tcode{basic_string::substr}}

\indexlibrary{\idxcode{basic_string}!\idxcode{substr}}%
\indexlibrary{\idxcode{substr}!\idxcode{basic_string}}%
\begin{itemdecl}
basic_string<charT,traits,Allocator>
  substr(size_type pos = 0, size_type n = npos) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{pos <= size()}

\pnum
\throws
\tcode{out_of_range}
if
\tcode{pos > size()}.

\pnum
\effects
Determines the effective length \tcode{rlen} of the string to copy as the smaller of \tcode{n} and
\tcode{size() - pos}.

\pnum
\returns
\tcode{basic_string<charT,traits,Allocator>(data()+pos,rlen)}.
\end{itemdescr}

\rSec3[lib.string::compare]{\tcode{basic_string::compare}}

\indexlibrary{\idxcode{basic_string}!\idxcode{compare}}%
\indexlibrary{\idxcode{compare}!\idxcode{basic_string}}%
\begin{itemdecl}
int compare(const basic_string<charT,traits,Allocator>& str) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Determines the effective length
\textit{rlen}
of the strings to compare as the smallest of
\tcode{size()}
and
\tcode{str.size()}.
The function then compares the two strings by calling
\tcode{traits::compare(data(), str.data(), rlen)}.

\pnum
\returns
the nonzero result if the result of the comparison is nonzero.
Otherwise, returns a value as indicated in Table~\ref{tab:strings.compare}.

\begin{floattable}{\tcode{compare()} results}{tab:strings.compare}
{lc}
\topline
\lhdr{Condition}                &   \rhdr{Return Value} \\ \capsep
\tcode{size() < \ str.size()}  &   \tcode{< 0}         \\
\tcode{size() == str.size()}    &   \tcode{ \ 0}       \\
\tcode{size() > \ str.size()}  &   \tcode{> 0}         \\
\end{floattable}
\end{itemdescr}

\indexlibrary{\idxcode{compare}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{compare}}%
\begin{itemdecl}
int compare(size_type pos1, size_type n1,
            const basic_string<charT,traits,Allocator>& str) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
basic_string<charT,traits,Allocator>(*this,pos1,n1).compare(
             str) .
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{compare}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{compare}}%
\begin{itemdecl}
int compare(size_type pos1, size_type n1,
            const basic_string<charT,traits,Allocator>& str,
            size_type pos2, size_type n2) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
basic_string<charT,traits,Allocator>(*this,pos1,n1).compare(
             basic_string<charT,traits,Allocator>(str,pos2,n2)) .
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{compare}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{compare}}%
\begin{itemdecl}
int compare(const charT *s) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{this->compare(basic_string<charT,traits,Allocator>(s))}.
\end{itemdescr}

\indexlibrary{\idxcode{compare}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{compare}}%
\begin{itemdecl}
int compare(size_type pos, size_type n1,
            const charT *s) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
basic_string<charT,traits,Allocator>(*this,pos,n1).compare(
             basic_string<charT,traits,Allocator>(s))
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{compare}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{compare}}%
\begin{itemdecl}
int compare(size_type pos, size_type n1,
            const charT *s, size_type n2) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
basic_string<charT,traits,Allocator>(*this,pos,n1).compare(
             basic_string<charT,traits,Allocator>(s,n2))
\end{codeblock}
\end{itemdescr}

\rSec2[lib.string.nonmembers]{\tcode{basic_string} non-member functions}

\indexlibrary{\idxcode{basic_string}}

\rSec3[lib.string::op+]{\tcode{operator+}}

\indexlibrary{\idxcode{basic_string}!\idxcode{operator+}}%
\indexlibrary{\idxcode{operator+}!\idxcode{basic_string}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  basic_string<charT,traits,Allocator>
    operator+(const basic_string<charT,traits,Allocator>& lhs,
              const basic_string<charT,traits,Allocator>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{basic_string<charT,traits,Allocator>(lhs).append(rhs)}
\end{itemdescr}

\indexlibrary{\idxcode{operator+}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{operator+}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  basic_string<charT,traits,Allocator>
    operator+(const charT* lhs,
              const basic_string<charT,traits,Allocator>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{basic_string<charT,traits,Allocator>(lhs) + rhs}.

\pnum
\notes
Uses
\tcode{traits::length()}.
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!\idxcode{operator+}}%
\indexlibrary{\idxcode{operator+}!\idxcode{basic_string}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  basic_string<charT,traits,Allocator>
    operator+(charT lhs,
              const basic_string<charT,traits,Allocator>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{basic_string<charT,traits,Allocator>(1,lhs) + rhs}.
\end{itemdescr}

\indexlibrary{\idxcode{operator+}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{operator+}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  basic_string<charT,traits,Allocator>
    operator+(const basic_string<charT,traits,Allocator>& lhs,
              const charT* rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{lhs + basic_string<charT,traits,Allocator>(rhs)}.

\pnum
\notes
Uses
\tcode{traits::length()}.
\end{itemdescr}

\indexlibrary{\idxcode{basic_string}!\idxcode{operator+}}%
\indexlibrary{\idxcode{operator+}!\idxcode{basic_string}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  basic_string<charT,traits,Allocator>
    operator+(const basic_string<charT,traits,Allocator>& lhs,
              charT rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{lhs + basic_string<charT,traits,Allocator>(1,rhs)}.
\end{itemdescr}

\rSec3[lib.string::operator==]{\tcode{operator==}}

\indexlibrary{\idxcode{basic_string}!\idxcode{operator==}}%
\indexlibrary{\idxcode{operator==}!\idxcode{basic_string}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  bool operator==(const basic_string<charT,traits,Allocator>& lhs,
                  const basic_string<charT,traits,Allocator>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{lhs.compare(rhs) == 0}.
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{operator==}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  bool operator==(const charT* lhs,
                  const basic_string<charT,traits,Allocator>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{basic_string<charT,traits,Allocator>(lhs) == rhs}.
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{operator==}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  bool operator==(const basic_string<charT,traits,Allocator>& lhs,
                  const charT* rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{lhs == basic_string<charT,traits,Allocator>(rhs)}.

\pnum
\notes
Uses \tcode{traits::length()}.
\end{itemdescr}

\indexlibrary{\idxcode{length}!\tcode{char_traits}}%
\rSec3[string::op!=]{\tcode{operator!=}}

\indexlibrary{\idxcode{basic_string}!\idxcode{operator"!=}}%
\indexlibrary{\idxcode{operator"!=}!\idxcode{basic_string}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  bool operator!=(const basic_string<charT,traits,Allocator>& lhs,
                  const basic_string<charT,traits,Allocator>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{!(lhs == rhs)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{operator"!=}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  bool operator!=(const charT* lhs,
                  const basic_string<charT,traits,Allocator>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{basic_string<charT,traits,Allocator>(lhs) != rhs}.
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{operator"!=}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  bool operator!=(const basic_string<charT,traits,Allocator>& lhs,
                  const charT* rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{lhs != basic_string<charT,traits,Allocator>(rhs)}.

\pnum
\notes
Uses \tcode{traits::length()}.
\end{itemdescr}

\rSec3[lib.string::op<]{\tcode{operator<}}

\indexlibrary{\idxcode{basic_string}!\idxcode{operator<}}%
\indexlibrary{\idxcode{operator<}!\idxcode{basic_string}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  bool operator< (const basic_string<charT,traits,Allocator>& lhs,
                  const basic_string<charT,traits,Allocator>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{lhs.compare(rhs) < 0}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{operator<}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  bool operator< (const charT* lhs,
                  const basic_string<charT,traits,Allocator>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{basic_string<charT,traits,Allocator>(lhs) < rhs}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{operator<}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  bool operator< (const basic_string<charT,traits,Allocator>& lhs,
                  const charT* rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{lhs < basic_string<charT,traits,Allocator>(rhs)}.
\end{itemdescr}

\rSec3[lib.string::op>]{\tcode{operator>}}

\indexlibrary{\idxcode{operator>}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{operator>}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  bool operator> (const basic_string<charT,traits,Allocator>& lhs,
                  const basic_string<charT,traits,Allocator>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{lhs.compare(rhs) > 0}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{operator>}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  bool operator> (const charT* lhs,
                  const basic_string<charT,traits,Allocator>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{basic_string<charT,traits,Allocator>(lhs) > rhs}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{operator>}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  bool operator> (const basic_string<charT,traits,Allocator>& lhs,
                  const charT* rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{lhs > basic_string<charT,traits,Allocator>(rhs)}.
\end{itemdescr}

\rSec3[lib.string::op<=]{\tcode{operator<=}}

\indexlibrary{\idxcode{operator<=}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{operator<=}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  bool operator<=(const basic_string<charT,traits,Allocator>& lhs,
                  const basic_string<charT,traits,Allocator>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{lhs.compare(rhs) <= 0}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{operator<=}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  bool operator<=(const charT* lhs,
                  const basic_string<charT,traits,Allocator>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{basic_string<charT,traits,Allocator>(lhs) <= rhs}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{operator<=}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  bool operator<=(const basic_string<charT,traits,Allocator>& lhs,
                  const charT* rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{lhs <= basic_string<charT,traits,Allocator>(rhs)}.
\end{itemdescr}

\rSec3[lib.string::op>=]{\tcode{operator>=}}

\indexlibrary{\idxcode{operator>=}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{operator>=}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  bool operator>=(const basic_string<charT,traits,Allocator>& lhs,
                  const basic_string<charT,traits,Allocator>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{lhs.compare(rhs) >= 0}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{operator>=}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  bool operator>=(const charT* lhs,
                  const basic_string<charT,traits,Allocator>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{basic_string<charT,traits,Allocator>(lhs) >= rhs}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{operator>=}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  bool operator>=(const basic_string<charT,traits,Allocator>& lhs,
                  const charT* rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{lhs >= basic_string<charT,traits,Allocator>(rhs)}.
\end{itemdescr}

\rSec3[lib.string.special]{\tcode{swap}}

\indexlibrary{\idxcode{basic_string}!\idxcode{swap}}%
\indexlibrary{\idxcode{swap}!\idxcode{basic_string}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  void swap(basic_string<charT,traits,Allocator>& lhs,
            basic_string<charT,traits,Allocator>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\tcode{lhs.swap(rhs);}
\end{itemdescr}

\rSec3[lib.string.io]{Inserters and extractors}

\indexlibrary{\idxcode{operator\shr}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{operator\shr}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  basic_istream<charT,traits>&
    operator>>(basic_istream<charT,traits>& is,
               basic_string<charT,traits,Allocator>& str);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Begins by constructing a
\tcode{sentry}
object \tcode{k} as if \tcode{k} were constructed by
\tcode{typename basic_istream\brk<charT,traits>::sentry  k(is)}.
If \tcode{bool(k)} is true, it calls
\tcode{str.erase()}
and then extracts characters from \tcode{is} and appends them
to \tcode{str} as if by calling
\tcode{str.append(1,c)}.
If
\tcode{is.width()}
is greater than zero, the maximum
number \tcode{n} of characters appended is
\tcode{is.width()};
otherwise \tcode{n} is
\tcode{str.max_size()}.
Characters are extracted and appended until any of the following
occurs:

\begin{itemize}
\item
\textit{n}
characters are stored;
\item
end-of-file occurs on the input sequence;
\item
\tcode{isspace(c,is.getloc())}
is true for the next available input character
\textit{c}.
\end{itemize}

\pnum
After the last character (if any) is extracted,
\tcode{is.width(0)}
is called and the
\tcode{sentry}
object \tcode{k} is destroyed.

\pnumalt
If the function extracts no characters, it calls
\tcode{is.setstate(ios::failbit)},
which may throw
\tcode{ios_base\colcol{}fail\-ure}~(\ref{lib.iostate.flags}).

\pnum
\returns
\tcode{is}
\end{itemdescr}

\indexlibrary{\idxcode{operator\shl}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{operator\shl}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os,
               const basic_string<charT,traits,Allocator>& str);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Begins by constructing a \tcode{sentry} object \tcode{k} as if \tcode{k}
were constructed by \tcode{typename basic_ostream\brk<charT,traits>::sentry k(os)}.
If \tcode{bool(k)} is true, inserts characters as if by calling
\tcode{os.rdbuf()->sputn(\brk{}str.data(), n)}, padding as described in stage 3
of \ref{lib.facet.num.put.virtuals}, where \tcode{n} is the larger of
\tcode{os.width()} and \tcode{str.size()};
then calls
\tcode{os.\brk{}width(0)}.
If the call to \tcode{sputn} fails,
calls \tcode{os.setstate(ios_base::failbit)}.

\pnum
\returns
\tcode{os}
\end{itemdescr}

\indexlibrary{\idxcode{getline}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{getline}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  basic_istream<charT,traits>&
    getline(basic_istream<charT,traits>& is,
            basic_string<charT,traits,Allocator>& str,
            charT delim);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Begins by constructing a \tcode{sentry} object \tcode{k} as if by
\tcode{typename basic_istream<charT,traits>::\brk{}sentry k(is, true)}.
If \tcode{bool(k)} is true, it calls \tcode{str.erase()}
and then extracts characters from \tcode{is} and appends them
to \tcode{str} as if by calling
\tcode{str.append(1,c)}
until any of the following occurs:

\begin{itemize}
\item
end-of-file occurs on the input sequence (in which case, the \tcode{getline}
function calls \tcode{is.setstate(\brk{}ios_base\colcol{}eofbit)}).
\item
\tcode{c == delim} for the next available input character \textit{c}
(in which case, \textit{c}
is extracted but not appended)~(\ref{lib.iostate.flags})
\item
\tcode{str.max_size()} characters are stored (in which case, the function calls
\tcode{is.setstate(ios_base\colcol{}fail\-bit))}~(\ref{lib.iostate.flags})
\end{itemize}

\pnum
The conditions are tested in the order shown. In any case,
after the last character is extracted, the \tcode{sentry} object \tcode{k}
is destroyed.

\pnum
If the function extracts no characters, it calls
\tcode{is.setstate(ios_base\colcol{}fail\-bit)}
which may throw
\tcode{ios_base\colcol{}fail\-ure}~(\ref{lib.iostate.flags}).

\pnum
\returns
\tcode{is}.
\end{itemdescr}

\indexlibrary{\idxcode{getline}!\idxcode{basic_string}}%
\indexlibrary{\idxcode{basic_string}!\idxcode{getline}}%
\begin{itemdecl}
template<class charT, class traits, class Allocator>
  basic_istream<charT,traits>&
    getline(basic_istream<charT,traits>& is,
            basic_string<charT,traits,Allocator>& str);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{getline(is,str,is.widen('\textbackslash n'))}
\end{itemdescr}


\rSec1[lib.c.strings]{Null-terminated sequence utilities}

\pnum
Tables~\ref{tab:strings.hdr.cctype},
\ref{tab:strings.hdr.cwctype}, \ref{tab:strings.hdr.cstring},
\ref{tab:strings.hdr.cwchar},
and \ref{tab:strings.hdr.cstdlib},
describe headers
\tcode{<cctype>},
\tcode{<cwctype>},
\tcode{<cstring>},
\tcode{<cwchar>}, and
\tcode{<cstdlib>}
(character conversions),
respectively.

\begin{libsyntab5}{cctype}{tab:strings.hdr.cctype}

\cspan{\functions}  \\
\tcode{isalnum}     &
 \tcode{isdigit}    &
 \tcode{isprint}    &
 \tcode{isupper}    &
 \tcode{tolower}    \\
\tcode{isalpha}     &
 \tcode{isgraph}    &
 \tcode{ispunct}    &
 \tcode{isxdigit}   &
 \tcode{toupper}    \\
\tcode{iscntrl}     &
 \tcode{islower}    &
 \tcode{isspace}    &
                    & \\
\end{libsyntab5}

\begin{libsyntab6}{cwctype}{tab:strings.hdr.cwctype}
\macro              &   \multicolumn{5}{l|}{\tcode{WEOF <cwctype>}} \\ \rowsep
\types              &
 \tcode{wctrans_t}  &
 \tcode{wctype_t}   &
 \multicolumn{3}{l|}{\tcode{wint_t <cwctype>}}  \\ \rowsep
\cspan{\functions}  \\

\tcode{iswalnum}    &
\tcode{iswctype}    &
\tcode{iswlower}    &
\tcode{iswspace}    &
\tcode{towctrans}   &
\tcode{wctrans}     \\

\tcode{iswalpha}    &
\tcode{iswdigit}    &
\tcode{iswprint}    &
\tcode{iswupper}    &
\tcode{towlower}    &
\tcode{wctype}      \\

\tcode{iswcntrl}    &
\tcode{iswgraph}    &
\tcode{iswpunct}    &
\tcode{iswxdigit}   &
\tcode{towupper}    & \\


\end{libsyntab6}

\begin{libsyntab5}{cstring}{tab:strings.hdr.cstring}
\macro              &
 \multicolumn{4}{l|}{\tcode{NULL <cstring>}}    \\ \rowsep
\type               &
 \multicolumn{4}{l|}{\tcode{size_t <cstring>}}  \\ \rowsep
\cspan{\functions}  \\
\tcode{memchr}      &
 \tcode{strcat}     &
 \tcode{strcspn}    &
 \tcode{strncpy}    &
 \tcode{strtok}     \\
\tcode{memcmp}      &
 \tcode{strchr}     &
 \tcode{strerror}   &
 \tcode{strpbrk}    &
 \tcode{strxfrm}    \\
\tcode{memcpy}      &
 \tcode{strcmp}     &
 \tcode{strlen}     &
 \tcode{strrchr}    &
                    \\
\tcode{memmove}     &
 \tcode{strcoll}    &
 \tcode{strncat}    &
 \tcode{strspn}     &
                    \\
\tcode{memset}      &
 \tcode{strcpy}     &
 \tcode{strncmp}    &
 \tcode{strstr}     &
                    \\
\end{libsyntab5}

\begin{libsyntab6}{cwchar}{tab:strings.hdr.cwchar}
\macros                 &
 \tcode{NULL <cwchar>}  &
 \tcode{WCHAR_MAX}      &
 \tcode{WCHAR_MIN}      &
 \tcode{WEOF <cwchar>}  & \\ \rowsep

\types                  &
 \tcode{mbstate_t}      &
 \tcode{wint_t <cwchar>}&
 \tcode{size_t}         & & \\ \rowsep

\cspan{\functions}      \\

\tcode{btowc}           &
\tcode{getwchar}        &
\tcode{ungetwc}         &
\tcode{wcscpy}          &
\tcode{wcsrtombs}       &
\tcode{wmemchr}         \\

\tcode{fgetwc}          &
\tcode{mbrlen}          &
\tcode{vfwprintf}       &
\tcode{wcscspn}         &
\tcode{wcsspn}          &
\tcode{wmemcmp}         \\

\tcode{fgetws}          &
\tcode{mbrtowc}         &
\tcode{vswprintf}       &
\tcode{wcsftime}        &
\tcode{wcsstr}          &
\tcode{wmemcpy}         \\

\tcode{fputwc}          &
\tcode{mbsinit}         &
\tcode{vwprintf}        &
\tcode{wcslen}          &
\tcode{wcstod}          &
\tcode{wmemmove}        \\

\tcode{fputws}          &
\tcode{mbsrtowcs}       &
\tcode{wcrtomb}         &
\tcode{wcsncat}         &
\tcode{wcstok}          &
\tcode{wmemset}         \\

\tcode{fwide}           &
\tcode{putwc}           &
\tcode{wcscat}          &
\tcode{wcsncmp}         &
\tcode{wcstol}          &
\tcode{wprintf}         \\

\tcode{fwprintf}        &
\tcode{putwchar}        &
\tcode{wcschr}          &
\tcode{wcsncpy}         &
\tcode{wcstoul}         &
\tcode{wscanf}          \\

\tcode{fwscanf}         &
\tcode{swprintf}        &
\tcode{wcscmp}          &
\tcode{wcspbrk}         &
\tcode{wcsxfrm}         & \\

\tcode{getwc}           &
\tcode{swscanf}         &
\tcode{wcscoll}         &
\tcode{wcsrchr}         &
\tcode{wctob}           & \\

\end{libsyntab6}

\begin{libsyntab4}{cstdlib}{tab:strings.hdr.cstdlib}
\macros             &
 \tcode{MB_CUR_MAX} &
                    &
                    \\ \rowsep
\cspan{\functions}  \\
\tcode{atol}        & \tcode{mblen}     & \tcode{strtod}    & \tcode{wctomb}  \\
\tcode{atof}        & \tcode{mbstowcs}  & \tcode{strtol}    & \tcode{wcstombs}\\
\tcode{atoi}        & \tcode{mbtowc}    & \tcode{strtoul}   & \\
\end{libsyntab4}

\pnum
The contents of these headers are the same as the Standard C Library headers
\tcode{<ctype.h>},
\tcode{<wctype.h>},
\tcode{<string.h>},
\tcode{<wchar.h>}
and
\tcode{<stdlib.h>}
respectively, with the following modifications:

\pnum
\indextext{\idxcode{wchar_t}}%
None of the headers shall define the type
\tcode{wchar_t}~(\ref{lex.key}).

\pnum
\indexlibrary{\idxcode{strchr}}%
The function signature
\tcode{strchr(const char*, int)}
is replaced by the two declarations:

\begin{codeblock}
const char* strchr(const char* s, int c);
      char* strchr(      char* s, int c);
\end{codeblock}

\pnum
both of which have the same behavior as the original declaration.

\pnum
\indexlibrary{\idxcode{strpbrk}}%
The function signature
\tcode{strpbrk(const char*, const char*)}
is replaced by the two declarations:

\begin{codeblock}
const char* strpbrk(const char* s1, const char* s2);
      char* strpbrk(      char* s1, const char* s2);
\end{codeblock}

\pnum
both of which have the same behavior as the original declaration.

\pnum
\indexlibrary{\idxcode{strrchr}}%
The function signature
\tcode{strrchr(const char*, int)}
is replaced by the two declarations:

\begin{codeblock}
const char* strrchr(const char* s, int c);
      char* strrchr(      char* s, int c);
\end{codeblock}

\pnum
both of which have the same behavior as the original declaration.

\pnum
\indexlibrary{\idxcode{strstr}}%
The function signature
\tcode{strstr(const char*, const char*)}
is replaced by the two declarations:

\begin{codeblock}
const char* strstr(const char* s1, const char* s2);
      char* strstr(      char* s1, const char* s2);
\end{codeblock}

\pnum
both of which have the same behavior as the original declaration.

\pnum
\indexlibrary{\idxcode{memchr}}%
The function signature
\tcode{memchr(const void*, int, size_t)}
is replaced by the two declarations:

\begin{codeblock}
const void* memchr(const void* s, int c, size_t n);
      void* memchr(      void* s, int c, size_t n);
\end{codeblock}

\pnum
both of which have the same behavior as the original declaration.

\pnum
\indexlibrary{\idxcode{wcschr}}%
The function signature
\tcode{wcschr(const wchar_t*, wchar_t)}
is replaced by the two declarations:

\begin{codeblock}
const wchar_t* wcschr(const wchar_t* s, wchar_t c);
      wchar_t* wcschr(      wchar_t* s, wchar_t c);
\end{codeblock}

\pnum
both of which have the same behavior as the original declaration.

\pnum
\indexlibrary{\idxcode{wcspbrk}}%
The function signature
\tcode{wcspbrk(const wchar_t*, const wchar_t*)}
is replaced by the two declarations:

\begin{codeblock}
const wchar_t* wcspbrk(const wchar_t* s1, const wchar_t* s2);
      wchar_t* wcspbrk(      wchar_t* s1, const wchar_t* s2);
\end{codeblock}

\pnum
both of which have the same behavior as the original declaration.

\pnum
\indexlibrary{\idxcode{wcsrchr}}%
The function signature
\tcode{wcsrchr(const wchar_t*, wchar_t)}
is replaced by the two declarations:

\begin{codeblock}
const wchar_t* wcsrchr(const wchar_t* s, wchar_t c);
      wchar_t* wcsrchr(      wchar_t* s, wchar_t c);
\end{codeblock}

\pnum
both of which have the same behavior as the original declaration.

\pnum
\indexlibrary{\idxcode{wcsstr}}%
The function signature
\tcode{wcsstr(const wchar_t*, const wchar_t*)}
is replaced by the two declarations:

\begin{codeblock}
const wchar_t* wcsstr(const wchar_t* s1, const wchar_t* s2);
      wchar_t* wcsstr(      wchar_t* s1, const wchar_t* s2);
\end{codeblock}

\pnum
both of which have the same behavior as the original declaration.

\pnum
\indexlibrary{\idxcode{wmemchr}}%
The function signature
\tcode{wmemchr(const wwchar_t*, int, size_t)}
is replaced by the two declarations:

\begin{codeblock}
const wchar_t* wmemchr(const wchar_t* s, wchar_t c, size_t n);
      wchar_t* wmemchr(      wchar_t* s, wchar_t c, size_t n);
\end{codeblock}

\pnum
both of which have the same behavior as the original declaration.

\xref
ISO C subclauses 7.3, 7.10.7, 7.10.8, and  7.11.
Amendment 1 subclauses 4.4, 4.5, and 4.6.
