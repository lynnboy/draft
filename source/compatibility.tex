\infannex{diff}{Compatibility}

\rSec1[diff.iso]{\Cpp and ISO C}

\pnum
\indextext{summary!compatibility~with ISO C}%
The subclauses of this subclause lists the differences between \Cpp and
ISO C, by the chapters of this document.

\rSec2[diff.lex]{Clause~\ref{lex}: lexical conventions}

\ref{lex.comment}
\change \Cpp style comments (\tcode{//}) are added\\
A pair of slashes now introduce a one-line comment.
\rationale
This style of comments is a useful addition to the language.
\effect
Change to semantics of well-defined feature.
A valid ISO C expression containing a division operator followed
immediately by a C-style comment will now be treated as a \Cpp style
comment.
For example

\begin{codeblock}
{
    int a = 4;
    int b = 8                   //* divide by a*/ a;
    +a;
}
\end{codeblock}

\difficulty
Syntactic transformation.
Just add white space after the division operator.
\howwide
The token sequence \tcode{//*} probably occurs very seldom.

\ref{lex.key}
\change New Keywords\\
New keywords are added to \Cpp;
see \ref{lex.key}.
\rationale
These keywords were added in order to implement the new
semantics of \Cpp.
\effect
Change to semantics of well-defined feature.
Any ISO C programs that used any of these keywords as identifiers
are not valid \Cpp programs.
\difficulty
Syntactic transformation.
Converting one specific program is easy.
Converting a large collection
of related programs takes more work.
\howwide
Common.

\ref{lex.ccon}
\change Type of character literal is changed from \tcode{int} to \tcode{char}
\rationale
This is needed for improved overloaded function argument type
matching.
For example:

\begin{codeblock}
int function( int i );
int function( char c );

function( 'x' );
\end{codeblock}

It is preferable that this call match the second version of
function rather than the first.
\effect
Change to semantics of well-defined feature.
ISO C programs which depend on

\begin{codeblock}
sizeof('x') == sizeof(int)
\end{codeblock}

will not work the same as \Cpp programs.
\difficulty
Simple.
\howwide
Programs which depend upon \tcode{sizeof('x')} are probably rare.

Subclause _{lex.string}:
\change String literals made const\\
The type of a string literal is changed
from ``array of \tcode{char}''
to ``array of \tcode{const char}.''
The type of a wide string literal is changed
from ``array of \tcode{wchar_t}''
to ``array of \tcode{const wchar_t}.''
\rationale
This avoids calling an inappropriate overloaded function,
which might expect to be able to modify its argument.
\effect
Change to semantics of well-defined feature.
\difficulty
Simple syntactic transformation, because string literals can be
converted to \tcode{char*}; (\ref{conv.array}).
The most common cases are handled by a new but deprecated
standard conversion:

\begin{codeblock}
char* p = "abc";                // valid in C, deprecated in \Cpp
char* q = expr ? "abc" : "de";  // valid in C, invalid in \Cpp
\end{codeblock}

\howwide
Programs that have a legitimate reason to treat string literals
as pointers to potentially modifiable memory are probably rare.

\rSec2[diff.basic]{Clause \ref{basic}: basic concepts}

\ref{basic.def}
\change \Cpp does not have ``tentative definitions'' as in C\\
E.g., at file scope,

\begin{codeblock}
int i;
int i;
\end{codeblock}

is valid in C, invalid in \Cpp.
This makes it impossible to define
mutually referential file-local static objects, if initializers are
restricted to the syntactic forms of C.
For example,

\begin{codeblock}
struct X { int i; struct X *next; };

static struct X a;
static struct X b = { 0, &a };
static struct X a = { 1, &b };
\end{codeblock}

\rationale
This avoids having different initialization rules for
built-in types and user-defined types.
\effect
Deletion of semantically well-defined feature.
\difficulty
Semantic transformation.
In \Cpp, the initializer for one of a set of
mutually-referential file-local static objects must invoke a function
call to achieve the initialization.
\howwide
Seldom.

\ref{basic.scope}
\change A \tcode{struct} is a scope in \Cpp, not in C
\rationale
Class scope is crucial to \Cpp, and a struct is a class.
\effect
Change to semantics of well-defined feature.
\difficulty
Semantic transformation.
\howwide
C programs use \tcode{struct} extremely frequently, but the
change is only noticeable when \tcode{struct}, enumeration, or enumerator
names are referred to outside the \tcode{struct}.
The latter is probably rare.

\ref{basic.link} [also \ref{dcl.type}] 
\change A name of file scope that is explicitly declared \tcode{const}, and not explicitly
declared \tcode{extern}, has internal linkage, while in C it would have external linkage
\rationale
Because \tcode{const} objects can be used as compile-time values in
\Cpp, this feature urges programmers to provide explicit initializer
values for each \tcode{const}.
This feature allows the user to put \tcode{const}objects in header files that are included
in many compilation units.
\effect
Change to semantics of well-defined feature.
\difficulty
Semantic transformation
\howwide
Seldom

\ref{basic.start}
\change Main cannot be called recursively and cannot have its address taken
\rationale
The  main  function may require special actions.
\effect
Deletion of semantically well-defined feature
\difficulty
Trivial: create an intermediary function such as
\tcode{mymain(argc, argv)}.
\howwide
Seldom

\ref{basic.types}
\change C allows ``compatible types'' in several places, \Cpp does not\\
For example,
otherwise-identical \tcode{struct} types with different tag names
are ``compatible'' in C but are distinctly different types
in \Cpp.
\rationale
Stricter type checking is essential for \Cpp.
\effect
Deletion of semantically well-defined feature.
\difficulty
Semantic transformation.
The ``typesafe linkage'' mechanism will find many, but not all,
of such problems.
Those problems not found by typesafe linkage will continue to
function properly,
according to the ``layout compatibility rules'' of this
International Standard.
\howwide
Common.

\ref{conv.ptr}
\change Converting \tcode{void*} to a pointer-to-object type requires casting

\begin{codeblock}
char a[10];
void *b=a;
void foo() {
char *c=b;
}
\end{codeblock}

ISO C will accept this usage of pointer to void being assigned
to a pointer to object type.
\Cpp will not.
\rationale
\Cpp tries harder than C to enforce compile-time type safety.
\effect
Deletion of semantically well-defined feature.
\difficulty
Could be automated.
Violations will be diagnosed by the \Cpp translator.
The
fix is to add a  cast.
For example:

\begin{codeblock}
char *c = (char *) b;
\end{codeblock}

\howwide
This is fairly widely used but it is good
programming practice to add the cast when assigning pointer-to-void to pointer-to-object.
Some ISO C translators will give a warning
if the cast is not used.

\ref{conv.ptr}
\change Only pointers to non-const and non-volatile objects may be implicitly converted to \tcode{void*}
\rationale
This improves type safety.
\effect
Deletion of semantically well-defined feature.
\difficulty
Could be automated.
A C program containing such an implicit conversion from (e.g.)
pointer-to-const-object to void* will receive a diagnostic message.
The correction is to add an explicit cast.
\howwide
Seldom.

\rSec2[diff.expr]{Clause \ref{expr}: expressions}

\ref{expr.call}
\change Implicit declaration of functions is not allowed
\rationale
The type-safe nature of \Cpp.
\effect
Deletion of semantically well-defined feature.
Note: the original feature was labeled as ``obsolescent'' in ISO C.
\difficulty
Syntactic transformation.
Facilities for producing explicit function declarations are fairly
widespread commercially.
\howwide
Common.

\ref{expr.sizeof}, \ref{expr.cast}
\change Types must be declared in declarations, not in expressions\\
In C, a sizeof expression or cast expression may create a new type.
For example,
\begin{codeblock}
p = (void*)(struct x {int i;} *)0;
\end{codeblock}
declares a new type, struct x .
\rationale
This prohibition helps to clarify the location of
declarations in the source code.
\effect
Deletion of a semantically well-defined feature.
\difficulty
Syntactic transformation.
\howwide
Seldom.

\ref{expr.cond}, \ref{expr.ass}, \ref{expr.comma}

\indextext{conversion!lvalue-to-rvalue}%
\indextext{rvalue!lvalue conversion~to}%
\indextext{lvalue}%
\change The result of a conditional expression, an assignment expression, or a comma expression may be an lvalue
\rationale
\Cpp is an object-oriented language, placing relatively
more emphasis on lvalues.  For example, functions may
return lvalues.
\effect
Change to semantics of well-defined feature.  Some C
expressions that implicitly rely on lvalue-to-rvalue
conversions will yield different results.  For example,

\begin{codeblock}
char arr[100];
sizeof(0, arr)
\end{codeblock}

yields
\tcode{100}
in \Cpp and
\tcode{sizeof(char*)}
in C.
\difficulty
Programs must add explicit casts to the appropriate rvalue.
\howwide
Rare.

\rSec2[diff.stat]{Clause \ref{stmt.stmt}: statements}

\ref{stmt.switch}, \ref{stmt.goto} (\tcode{switch} and \tcode{goto} statements)
\change It is now invalid to jump past a declaration with explicit or implicit initializer (except across entire block not entered)
\rationale
Constructors used in initializers may allocate
resources which need to be de-allocated upon leaving the
block.
Allowing jump past initializers would require
complicated run-time determination of allocation.
Furthermore, any use of the uninitialized object could be a
disaster.
With this simple compile-time rule, \Cpp assures that
if an initialized variable is in scope, then it has assuredly been
initialized.
\effect
Deletion of semantically well-defined feature.
\difficulty
Semantic transformation.
\howwide
Seldom.

\ref{stmt.return}
\change It is now invalid to return (explicitly or implicitly) from a function which is
declared to return a value without actually returning a value
\rationale
The caller and callee may assume fairly elaborate
return-value mechanisms for the return of class objects.
If
some flow paths execute a return without specifying any value,
the implementation must embody many more complications.
Besides,
promising to return a value of a given type, and then not returning
such a value, has always been recognized to be a questionable
practice, tolerated only because very-old C had no distinction between
void  functions and  int  functions.
\effect
Deletion of semantically well-defined feature.
\difficulty
Semantic transformation.
Add an appropriate return value to the source code, e.g. zero.
\howwide
Seldom.
For several years, many existing C implementations have produced warnings in
this case.

\rSec2[diff.dcl]{Clause \ref{dcl.dcl}: declarations}

\ref{dcl.stc}
\change In \Cpp, the \tcode{static} or \tcode{extern} specifiers can only be applied to names of objects or functions
Using these specifiers with type declarations is illegal in \Cpp.
In C, these specifiers are ignored when used on type declarations.
Example:

\begin{codeblock}
static struct S {               // valid C, invalid in \Cpp
int i;
// ...
};
\end{codeblock}

\rationale
Storage class specifiers don't have any meaning when associated
with a type.
In \Cpp, class members can be declared with the \tcode{static} storage
class specifier.
Allowing storage class specifiers on type
declarations could render the code confusing for users.
\effect
Deletion of semantically well-defined feature.
\difficulty
Syntactic transformation.
\howwide
Seldom.

\ref{dcl.typedef}
\change A \Cpp typedef name must be different from any class type name declared
in the same scope (except if the typedef is a synonym of the class name with the
same name). In C, a typedef name and a struct tag name declared in the same scope
can have the same name (because they have different name spaces)

Example:
\begin{codeblock}
typedef struct name1 { /*...*/ } name1;         // valid C and \Cpp
struct name { /*...*/ };
typedef int name;               // valid C, invalid \Cpp
\end{codeblock}

\rationale
For ease of use, \Cpp doesn't require that a type name be prefixed
with the keywords \tcode{class}, \tcode{struct} or \tcode{union} when used in object
declarations or type casts.
Example:
\begin{codeblock}
class name { /*...*/ };
name i;                         // \tcode{i} has type \tcode{class name}
\end{codeblock}

\effect
Deletion of semantically well-defined feature.
\difficulty
Semantic transformation.
One of the 2 types has to be renamed.
\howwide
Seldom.

\ref{dcl.type} [see also \ref{basic.link}]
\change const objects must be initialized in \Cpp but can be left uninitialized in C
\rationale
A const object cannot be assigned to so it must be initialized
to hold a useful value.
\effect
Deletion of semantically well-defined feature.
\difficulty
Semantic transformation.
\howwide
Seldom.

\ref{dcl.type} (type specifiers)
\change Banning implicit int

In \Cpp a
\grammarterm{decl-specifier-seq}
must contain a
\grammarterm{type-specifier}{}.
In the following example, the
left-hand column presents valid C;
the right-hand column presents
equivalent \Cpp :

\begin{codeblock}
void f(const parm);            void f(const int parm);
const n = 3;                   const int n = 3;
main()                         int main()
    /* ... */                      /* ... */
\end{codeblock}

\rationale
In \Cpp, implicit int creates several opportunities for
ambiguity between expressions involving function-like
casts and declarations.
Explicit declaration is increasingly considered
to be proper style.
Liaison with WG14 (C) indicated support for (at least)
deprecating implicit int in the next revision of C.
\effect
Deletion of semantically well-defined feature.
\difficulty
Syntactic transformation.
Could be automated.
\howwide
Common.

\ref{dcl.enum}
\change \Cpp objects of enumeration type can only be assigned values of the same enumeration type.
In C, objects of enumeration type can be assigned values of any integral type

Example:
\begin{codeblock}
enum color { red, blue, green };
color c = 1;                    // valid C, invalid \Cpp
\end{codeblock}

\rationale
The type-safe nature of \Cpp.
\effect
Deletion of semantically well-defined feature.
\difficulty
Syntactic transformation.
(The type error produced by the assignment can be automatically
corrected by applying an explicit cast.)
\howwide
Common.

\ref{dcl.enum}
\change In \Cpp, the type of an enumerator is its enumeration. In C, the type of an enumerator is \tcode{int}.

Example:

\begin{codeblock}
enum e { A };
sizeof(A) == sizeof(int)        // in C
sizeof(A) == sizeof(e)          // in \Cpp
/* @\textit{\textrm{and \tcode{sizeof(int)} is not necessarily equal to \tcode{sizeof(e)}}}@ */
\end{codeblock}

\rationale
In \Cpp, an enumeration is a distinct type.
\effect
Change to semantics of well-defined feature.
\difficulty
Semantic transformation.
\howwide
Seldom.
The only time this affects existing C code is when the size of an
enumerator is taken.
Taking the size of an enumerator is not a
common C coding practice.

\rSec2[diff.decl]{Clause \ref{dcl.decl}: declarators}

\ref{dcl.fct}
\change In \Cpp, a function declared with an empty parameter list takes no arguments.\\
In C, an empty parameter list means that the number and type of the function arguments are unknown"

Example:

\begin{codeblock}
int f();                        // means   \tcode{int f(void)} in \Cpp
                                // \tcode{int f(} unknown \tcode{)} in C
\end{codeblock}

\rationale
This is to avoid erroneous function calls (i.e. function calls
with the wrong number or type of arguments).
\effect
Change to semantics of well-defined feature.
This feature was marked as ``obsolescent'' in C.
\difficulty
Syntactic transformation.
The function declarations using C incomplete declaration style must
be completed to become full prototype declarations.
A program may need to be updated further if different calls to the
same (non-prototype) function have different numbers of arguments or
if the type of corresponding arguments differed.
\howwide
Common.

\ref{dcl.fct} [see \ref{expr.sizeof}]
\change In \Cpp, types may not be defined in return or parameter types. In C, these type definitions are allowed

Example:

\begin{codeblock}
void f( struct S { int a; } arg ) {}    // valid C, invalid \Cpp
enum E { A, B, C } f() {}               // valid C, invalid \Cpp
\end{codeblock}

\rationale
When comparing types in different compilation units, \Cpp relies
on name equivalence when C relies on structural equivalence.
Regarding parameter types: since the type defined in an parameter list
would be in the scope of the function, the only legal calls in \Cpp
would be from within the function itself.
\effect
Deletion of semantically well-defined feature.
\difficulty
Semantic transformation.
The type definitions must be moved to file scope, or in header files.
\howwide
Seldom.
This style of type definitions is seen as poor coding style.

\ref{dcl.fct.def}
\change In \Cpp, the syntax for function definition excludes the ``old-style'' C function.
In C, ``old-style'' syntax is allowed, but deprecated as ``obsolescent.''
\rationale
Prototypes are essential to type safety.
\effect
Deletion of semantically well-defined feature.
\difficulty
Syntactic transformation.
\howwide
Common in old programs, but already known to be obsolescent.

\ref{dcl.init.string}
\change In \Cpp, when initializing an array of character with a string, the number of
characters in the string (including the terminating \tcode{'\textbackslash 0'}) must not exceed the
number of elements in the array. In C, an array can be initialized with a string even if
the array is not large enough to contain the string-terminating \tcode{'\textbackslash 0'}

Example:

\begin{codeblock}
char array[4] = "abcd";         // valid C, invalid \Cpp
\end{codeblock}
\rationale
When these non-terminated arrays are manipulated by standard
string routines, there is potential for major catastrophe.
\effect
Deletion of semantically well-defined feature.
\difficulty
Semantic transformation.
The arrays must be declared one element bigger to contain the
string terminating \tcode{'\textbackslash 0'}.
\howwide
Seldom.
This style of array initialization is seen as poor coding style.

\rSec2[diff.class]{Clause \ref{class}: classes}

\ref{class.name} [see also \ref{dcl.typedef}]
\change In \Cpp, a class declaration introduces the class name into the scope where it is
declared and hides any object, function or other declaration of that name in an enclosing
scope. In C, an inner scope declaration of a struct tag name never hides the name of an
object or function in an outer scope

Example:

\begin{codeblock}
int x[99];
void f()
{
        struct x { int a; };
        sizeof(x);  /* @\textit{\textrm{size of the array in C}}@ */
        /* @\textit{\textrm{size of the struct in \Cpp}}@ */
}
\end{codeblock}
\rationale
This is one of the few incompatibilities between C and \Cpp that
can be attributed to the new \Cpp name space definition where a
name can be declared as a type and as a nontype in a single scope
causing the nontype name to hide the type name and requiring that
the keywords \tcode{class}, \tcode{struct}, \tcode{union} or \tcode{enum} be used to refer to the type name.
This new name space definition provides important notational
conveniences to \Cpp programmers and helps making the use of the
user-defined types as similar as possible to the use of built-in types.
The advantages of the new name space definition were judged to
outweigh by far the incompatibility with C described above.
\effect
Change to semantics of well-defined feature.
\difficulty
Semantic transformation.
If the hidden name that needs to be accessed is at global scope,
the \tcode{::} \Cpp operator can be used.
If the hidden name is at block scope, either the type or the struct
tag has to be renamed.
\howwide
Seldom.

\ref{class.nest}
\change In \Cpp, the name of a nested class is local to its enclosing class. In C
the name of the nested class belongs to the same scope as the name of the outermost enclosing class.

Example:

\begin{codeblock}
struct X {
        struct Y { /* ... */ } y;
};
struct Y yy;                    // valid C, invalid \Cpp
\end{codeblock}
\rationale
\Cpp classes have member functions which require that classes
establish scopes.
The C rule would leave classes as an incomplete scope mechanism
which would prevent \Cpp programmers from maintaining locality
within a class.
A coherent set of scope rules for \Cpp based on the C rule would
be very complicated and \Cpp programmers would be unable to predict
reliably the meanings of nontrivial examples involving nested or
local functions.
\effect
Change of semantics of well-defined feature.
\difficulty
Semantic transformation.
To make the struct type name visible in the scope of the enclosing
struct, the struct tag could be declared in the scope of the
enclosing struct, before the enclosing struct is defined.
Example:

\begin{codeblock}
struct Y;                       // \tcode{struct Y} and \tcode{struct X} are at the same scope
struct X {
        struct Y { /* ... */ } y;
};
\end{codeblock}

All the definitions of C struct types enclosed in other struct
definitions and accessed outside the scope of the enclosing
struct could be exported to the scope of the enclosing struct.
Note: this is a consequence of the difference in scope rules,
which is documented in \ref{basic.scope}.
\howwide
Seldom.

\ref{class.nested.type}
\change In \Cpp, a typedef name may not be redeclared in a class definition after being used in the declaration

Example:

\begin{codeblock}
typedef int I;
struct S {
        I i;
        int I;                  // valid C, invalid \Cpp
};
\end{codeblock}
\rationale
When classes become complicated, allowing such a redefinition
after the type has been used can create confusion for \Cpp
programmers as to what the meaning of 'I' really is.
\effect
Deletion of semantically well-defined feature.
\difficulty
Semantic transformation.
Either the type or the struct member has to be renamed.
\howwide
Seldom.

\rSec2[diff.special]{Clause \ref{special}: special member functions}

\ref{class.copy} (copying class objects)
\change Copying volatile objects

The implicitly-declared copy constructor and
implicitly-declared copy assignment operator
cannot make a copy of a volatile lvalue.
For example, the following is valid in ISO C:

\begin{codeblock}
struct X { int i; };
struct X x1, x2;
volatile struct X x1 = {0};
x1 = x3;                        // invalid \Cpp
x3 = x1;                        // also invalid \Cpp
\end{codeblock}

\rationale
Several alternatives were debated at length.
Changing the parameter to
\tcode{volatile}
\tcode{const}
\tcode{X\&}
would greatly complicate the generation of
efficient code for class objects.
Discussion of
providing two alternative signatures for these
implicitly-defined operations raised
unanswered concerns about creating
ambiguities and complicating
the rules that specify the formation of
these operators according to the bases and
members.
\effect
Deletion of semantically well-defined feature.
\difficulty
Semantic transformation.
If volatile semantics are required for the copy,
a user-declared constructor or assignment must
be provided.
If non-volatile semantics are required,
an explicit
\tcode{const_cast}
can be used.
\howwide
Seldom.

\rSec2[diff.cpp]{Clause \ref{cpp}: preprocessing directives}

\ref{cpp.predefined} (predefined names)
\change Whether \mname{STDC} is defined and if so, what its value is, are
implementation-defined
\rationale
\Cpp is not identical to ISO C.
Mandating that \mname{STDC}
be defined would require that translators make an incorrect claim.
Each implementation must choose the behavior that will be most
useful to its marketplace.
\effect
Change to semantics of well-defined feature.
\difficulty
Semantic transformation.
\howwide
Programs and headers that reference \mname{STDC} are
quite common.

\rSec1[diff.library]{Standard C library}
\indextext{library!C standard}%

\pnum
This subclause summarizes the contents of the \Cpp Standard library
included from the Standard C library.
It also summarizes the explicit changes in definitions,
declarations, or behavior from the ISO/IEC 9899:1990 and
ISO/IEC 9899:1990/DAM 1
noted in other subclauses (\ref{lib.headers}, \ref{lib.support.types}, \ref{lib.c.strings}).

\pnum
The \Cpp Standard library provides 54 standard macros from the C library,
as shown in Table~\ref{tab:diff.standard.macros}.

\pnum
The header names (enclosed in
\tcode{<}
and
\tcode{>})
indicate that the macro may be defined in more than one header.
All such definitions are equivalent (\ref{basic.def.odr}).

\begin{floattable}{Standard Macros}{tab:diff.standard.macros}
{lllll}
\hline

\tcode{assert}    &
\tcode{HUGE_VAL}  &
\tcode{NULL <cstring>}  &
\tcode{SIGILL}    &
\tcode{va_arg}    \\

\tcode{BUFSIZ}    &
\tcode{LC_ALL}    &
\tcode{NULL <ctime>}  &
\tcode{SIGINT}    &
\tcode{va_end}    \\

\tcode{CLOCKS_PER_SEC}  &
\tcode{LC_COLLATE}  &
\tcode{NULL <cwchar>} &
\tcode{SIGSEGV} &
\tcode{va_start}  \\

\tcode{EDOM}    &
\tcode{LC_CTYPE}  &
\tcode{offsetof}  &
\tcode{SIGTERM} &
\tcode{WCHAR_MAX} \\

\tcode{EOF}     &
\tcode{LC_MONETARY} &
\tcode{RAND_MAX}  &
\tcode{SIG_DFL} &
\tcode{WCHAR_MIN} \\

\tcode{ERANGE}    &
\tcode{LC_NUMERIC}  &
\tcode{SEEK_CUR}  &
\tcode{SIG_ERR} &
\tcode{WEOF <cwchar>} \\

\tcode{errno}   &
\tcode{LC_TIME} &
\tcode{SEEK_END}  &
\tcode{SIG_IGN} &
\tcode{WEOF <cwctype>}  \\

\tcode{EXIT_FAILURE}  &
\tcode{L_tmpnam}  &
\tcode{SEEK_SET}  &
\tcode{stderr}    &
\tcode{_IOFBF}    \\

\tcode{EXIT_SUCCESS}  &
\tcode{MB_CUR_MAX}  &
\tcode{setjmp}    &
\tcode{stdin}   &
\tcode{_IOLBF}    \\

\tcode{FILENAME_MAX}  &
\tcode{NULL <cstddef>}  &
\tcode{SIGABRT} &
\tcode{stdout}    &
\tcode{_IONBF}    \\

\tcode{FOPEN_MAX} &
\tcode{NULL <cstdio>}  &
\tcode{SIGFPE}    &
\tcode{TMP_MAX} & \\

\end{floattable}

\pnum
The \Cpp Standard library provides 45 standard values from the C library,
as shown in Table~\ref{tab:diff.standard.values}.

\begin{floattable}{Standard Values}{tab:diff.standard.values}
{llll}
\hline
\tcode{CHAR_BIT}  &
 \tcode{FLT_DIG}  &
 \tcode{INT_MIN}  &
 \tcode{MB_LEN_MAX} \\
\tcode{CHAR_MAX}  &
 \tcode{FLT_EPSILON}  &
 \tcode{LDBL_DIG} &
 \tcode{SCHAR_MAX}  \\
\tcode{CHAR_MIN}  &
 \tcode{FLT_MANT_DIG} &
 \tcode{LDBL_EPSILON} &
 \tcode{SCHAR_MIN}  \\
\tcode{DBL_DIG}   &
 \tcode{FLT_MAX}  &
 \tcode{LDBL_MANT_DIG}  &
 \tcode{SHRT_MAX} \\
\tcode{DBL_EPSILON} &
 \tcode{FLT_MAX_10_EXP} &
 \tcode{LDBL_MAX} &
 \tcode{SHRT_MIN} \\
\tcode{DBL_MANT_DIG}  &
 \tcode{FLT_MAX_EXP}  &
 \tcode{LDBL_MAX_10_EXP}  &
 \tcode{UCHAR_MAX}  \\
\tcode{DBL_MAX}   &
 \tcode{FLT_MIN}  &
 \tcode{LDBL_MAX_EXP} &
 \tcode{UINT_MAX} \\
\tcode{DBL_MAX_10_EXP}  &
 \tcode{FLT_MIN_10_EXP} &
 \tcode{LDBL_MIN} &
 \tcode{ULONG_MAX}  \\
\tcode{DBL_MAX_EXP} &
 \tcode{FLT_MIN_EXP}  &
 \tcode{LDBL_MIN_10_EXP}&
 \tcode{USRT_MAX} \\
\tcode{DBL_MIN}   &
 \tcode{FLT_RADIX}  &
 \tcode{LDBL_MIN_EXP} & \\
\tcode{DBL_MIN_10_EXP}  &
 \tcode{FLT_ROUNDS} &
 \tcode{LONG_MAX} & \\
\tcode{DBL_MIN_EXP} &
 \tcode{INT_MAX}  &
 \tcode{LONG_MIN} & \\ \hline
\end{floattable}

\pnum
The \Cpp Standard library provides 19 standard types from the C library,
as shown in Table~\ref{tab:diff.standard.types}.

\begin{floattable}{Standard Types}{tab:diff.standard.types}
{llll}
\hline
\tcode{clock_t}   &
 \tcode{ldiv_t}   &
 \tcode{size_t <cstdio>}  &
 \tcode{wctrans_t}  \\
\tcode{div_t}   &
 \tcode{mbstate_t}  &
 \tcode{size_t <cstring>} &
 \tcode{wctype_t} \\
\tcode{FILE}    &
 \tcode{ptrdiff_t}  &
 \tcode{size_t <ctime>} &
 \tcode{wint_t <cwchar>}  \\
\tcode{fpos_t}    &
 \tcode{sig_atomic_t} &
 \tcode{time_t}   &
 \tcode{wint_t <cwctype>} \\
\tcode{jmp_buf}   &
 \tcode{size_t <cstddef>} &
 \tcode{va_list}  & \\ \hline
\end{floattable}


\pnum
The \Cpp Standard library provides 2 standard structures
from the C library,
as shown in Table~\ref{tab:diff.standard.structs}.

\begin{floattable}{Standard Structs}{tab:diff.standard.structs}
{ll}
\hline
\tcode{lconv} & \tcode{tm}  \\ \hline
\end{floattable}

\pnum
The \Cpp standard library provides 209 standard functions from the C library,
as shown in Table~\ref{tab:diff.standard.functions}.

\begin{floattable}{Standard functions}{tab:diff.standard.functions}
{llllll}
\hline
\tcode{abort} &
\tcode{fmod}  &
\tcode{isupper} &
\tcode{mktime}  &
\tcode{strftime}  &
\tcode{wcrtomb} \\
\tcode{abs} &
\tcode{fopen} &
\tcode{iswalnum}  &
\tcode{modf}  &
\tcode{strlen}  &
\tcode{wcscat}  \\
\tcode{acos}  &
\tcode{fprintf} &
\tcode{iswalpha}  &
\tcode{perror}  &
\tcode{strncat} &
\tcode{wcschr}  \\
\tcode{asctime} &
\tcode{fputc} &
\tcode{iswcntrl}  &
\tcode{pow} &
\tcode{strncmp} &
\tcode{wcscmp}  \\
\tcode{asin}  &
\tcode{fputs} &
\tcode{iswctype}  &
\tcode{printf}  &
\tcode{strncpy} &
\tcode{wcscoll} \\
\tcode{atan}  &
\tcode{fputwc}  &
\tcode{iswdigit}  &
\tcode{putc}  &
\tcode{strpbrk} &
\tcode{wcscpy}  \\
\tcode{atan2} &
\tcode{fputws}  &
\tcode{iswgraph}  &
\tcode{putchar} &
\tcode{strrchr} &
\tcode{wcscspn} \\
\tcode{atexit}  &
\tcode{fread} &
\tcode{iswlower}  &
\tcode{puts}  &
\tcode{strspn}  &
\tcode{wcsftime}  \\
\tcode{atof}  &
\tcode{free}  &
\tcode{iswprint}  &
\tcode{putwc} &
\tcode{strstr}  &
\tcode{wcslen}  \\
\tcode{atoi}  &
\tcode{freopen} &
\tcode{iswpunct}  &
\tcode{putwchar}  &
\tcode{strtod}  &
\tcode{wcsncat} \\
\tcode{atol}  &
\tcode{frexp} &
\tcode{iswspace}  &
\tcode{qsort} &
\tcode{strtok}  &
\tcode{wcsncmp} \\
\tcode{bsearch} &
\tcode{fscanf}  &
\tcode{iswupper}  &
\tcode{raise} &
\tcode{strtol}  &
\tcode{wcsncpy} \\
\tcode{btowc} &
\tcode{fseek} &
\tcode{iswxdigit} &
\tcode{rand}  &
\tcode{strtoul} &
\tcode{wcspbrk} \\
\tcode{calloc}  &
\tcode{fsetpos} &
\tcode{isxdigit}  &
\tcode{realloc} &
\tcode{strxfrm} &
\tcode{wcsrchr} \\
\tcode{ceil}  &
\tcode{ftell} &
\tcode{labs}  &
\tcode{remove}  &
\tcode{swprintf}  &
\tcode{wcsrtombs} \\
\tcode{clearerr}  &
\tcode{fwide} &
\tcode{ldexp} &
\tcode{rename}  &
\tcode{swscanf} &
\tcode{wcsspn}  \\
\tcode{clock} &
\tcode{fwprintf}  &
\tcode{ldiv}  &
\tcode{rewind}  &
\tcode{system}  &
\tcode{wcsstr}  \\
\tcode{cos} &
\tcode{fwrite}  &
\tcode{localeconv}  &
\tcode{scanf} &
\tcode{tan} &
\tcode{wcstod}  \\
\tcode{cosh}  &
\tcode{fwscanf} &
\tcode{localtime} &
\tcode{setbuf}  &
\tcode{tanh}  &
\tcode{wcstok}  \\
\tcode{ctime} &
\tcode{getc}  &
\tcode{log} &
\tcode{setlocale} &
\tcode{time}  &
\tcode{wcstol}  \\
\tcode{difftime}  &
\tcode{getchar} &
\tcode{log10} &
\tcode{setvbuf} &
\tcode{tmpfile} &
\tcode{wcstombs}  \\
\tcode{div} &
\tcode{getenv}  &
\tcode{longjmp} &
\tcode{signal}  &
\tcode{tmpnam}  &
\tcode{wcstoul} \\
\tcode{exit}  &
\tcode{gets}  &
\tcode{malloc}  &
\tcode{sin} &
\tcode{tolower} &
\tcode{wcsxfrm} \\
\tcode{exp} &
\tcode{getwc} &
\tcode{mblen} &
\tcode{sinh}  &
\tcode{toupper} &
\tcode{wctob} \\
\tcode{fabs}  &
\tcode{getwchar}  &
\tcode{mbrlen}  &
\tcode{sprintf} &
\tcode{towctrans} &
\tcode{wctomb}  \\
\tcode{fclose}  &
\tcode{gmtime}  &
\tcode{mbrtowc} &
\tcode{sqrt}  &
\tcode{towlower}  &
\tcode{wctrans} \\
\tcode{feof}  &
\tcode{isalnum} &
\tcode{mbsinit} &
\tcode{srand} &
\tcode{towupper}  &
\tcode{wctype}  \\
\tcode{ferror}  &
\tcode{isalpha} &
\tcode{mbsrtowcs} &
\tcode{sscanf}  &
\tcode{ungetc}  &
\tcode{wmemchr} \\
\tcode{fflush}  &
\tcode{iscntrl} &
\tcode{mbstowcs}  &
\tcode{strcat}  &
\tcode{ungetwc} &
\tcode{wmemcmp} \\
\tcode{fgetc} &
\tcode{isdigit} &
\tcode{mbtowc}  &
\tcode{strchr}  &
\tcode{vfprintf}  &
\tcode{wmemcpy} \\
\tcode{fgetpos} &
\tcode{isgraph} &
\tcode{memchr}  &
\tcode{strcmp}  &
\tcode{vfwprintf} &
\tcode{wmemmove}  \\
\tcode{fgets} &
\tcode{islower} &
\tcode{memcmp}  &
\tcode{strcoll} &
\tcode{vprintf} &
\tcode{wmemset} \\
\tcode{fgetwc}  &
\tcode{isprint} &
\tcode{memcpy}  &
\tcode{strcpy}  &
\tcode{vsprintf}  &
\tcode{wprintf} \\
\tcode{fgetws}  &
\tcode{ispunct} &
\tcode{memmove} &
\tcode{strcspn} &
\tcode{vswprintf} &
\tcode{wscanf}  \\
\tcode{floor} &
\tcode{isspace} &
\tcode{memset}  &
\tcode{strerror}  &
\tcode{vwprintf}  & \\ \hline
\end{floattable}

\rSec2[diff.mods.to.headers]{Modifications to headers}

\pnum
For compatibility with the Standard C library,
\indextext{library!C standard}%
the \Cpp Standard library provides the 18
\textit{C headers}
(\ref{depr.c.headers}), but their use is deprecated in \Cpp.

\rSec2[diff.mods.to.definitions]{Modifications to definitions}

\rSec3[diff.wchar.t]{Type \tcode{wchar_t}}

\pnum
\tcode{wchar_t}
is a keyword in this International Standard (\ref{lex.key}).
It does not appear as a type name defined in any of
\tcode{<cstddef>},
\indexlibrary{\idxhdr{cstddef}}%
\tcode{<cstdlib>},
\indexlibrary{\idxhdr{cstdlib}}%
or
\tcode{<cwchar>}
\indexlibrary{\idxhdr{cwchar}}%
(\ref{lib.c.strings}).

\rSec3[diff.header.iso646.h]{Header \tcode{<iso646.h>}}
\indexlibrary{\idxhdr{iso646.h}}%

\pnum
The tokens
\tcode{and},
\tcode{and_eq},
\tcode{bitand},
\tcode{bitor},
\tcode{compl},
\tcode{not_eq},
\tcode{not},
\tcode{or},
\tcode{or_eq},
\tcode{xor},
and
\tcode{xor_eq}
are keywords in this International
Standard (\ref{lex.key}).
They do not appear as macro names defined in
\tcode{<ciso646>}.
\indexlibrary{\idxhdr{ciso646}}%

\rSec3[diff.null]{Macro \tcode{NULL}}

\pnum
The macro
\tcode{NULL},
defined in any of
\indexlibrary{\idxhdr{clocale}}%
\tcode{<clocale>},
\indexlibrary{\idxhdr{cstddef}}%
\tcode{<cstddef>},
\indexlibrary{\idxhdr{cstdio}}%
\tcode{<cstdio>},
\indexlibrary{\idxhdr{cstdlib}}%
\tcode{<cstdlib>},
\indexlibrary{\idxhdr{cstring}}%
\tcode{<cstring>},
\indexlibrary{\idxhdr{ctime}}%
\tcode{<ctime>},
or
\tcode{<cw\-char>},
\indexlibrary{\idxhdr{cwchar}}%
is an implementation-defined \Cpp null pointer constant in
\indextext{implementation-defined}%
this International Standard (\ref{lib.support.types}).

\rSec2[diff.mods.to.declarations]{Modifications to declarations}

\pnum
Header
\tcode{<cstring>}:
\indexlibrary{\idxhdr{cstring}}%
The following functions have different declarations:
\begin{itemize}
\item
\tcode{strchr}
\item
\tcode{strpbrk}
\item
\tcode{strrchr}
\item
\tcode{strstr}
\item
\tcode{memchr}
\end{itemize}

\pnum
\ref{lib.c.strings} describes the changes.

\rSec2[diff.mods.to.behavior]{Modifications to behavior}

\pnum
Header
\tcode{<cstdlib>}:
The following functions have different behavior:
\begin{itemize}
\item
\tcode{atexit}
\item
\tcode{exit}
\item
\tcode{abort}
\end{itemize}

\ref{lib.support.start.term} describes the changes.

\pnum
Header
\tcode{<csetjmp>}:
The following functions have different behavior:
\begin{itemize}
\item
\tcode{longjmp}
\end{itemize}

\ref{lib.support.runtime} describes the changes.

\rSec3[diff.offsetof]{Macro \tcode{offsetof(type, member-designator)}}
\indexlibrary{\idxcode{offsetof}}%

\pnum
The macro
\tcode{offsetof},
defined in
\indexlibrary{\idxhdr{cstddef}}%
\tcode{<cstddef>},
accepts a restricted set of \tcode{type} arguments in this International Standard.
\ref{lib.support.types} describes the change.

\rSec3[diff.malloc]{Memory allocation functions}

\pnum
The functions
\indexlibrary{\idxcode{calloc}}%
\tcode{calloc},
\indexlibrary{\idxcode{malloc}}%
\tcode{malloc},
and
\indexlibrary{\idxcode{realloc}}%
\tcode{realloc}
are restricted in this International Standard.
\ref{lib.c.malloc} describes the changes.
