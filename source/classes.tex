\rSec0[class]{Classes}%
\indextext{class|(}

%gram: \rSec1[gram.class]{Classes}
%gram:

\indextext{class!member function|see{member function, class}}

\pnum
\indextext{\idxcode{\{\}}!class declaration}%
\indextext{\idxcode{\{\}}!class definition}%
\indextext{type!class~and}%
\indextext{object~class|see{also~class~object}}%
A class is a type.
\indextext{name~class|see{class~name}}%
Its name becomes a \grammarterm{class-name}~(\ref{class.name}) within its
scope.

\begin{bnf}
\nontermdef{class-name}\br
    identifier\br
    template-id
\end{bnf}

\grammarterm{Class-specifier}{s} and
\grammarterm{elaborated-type-specifier}{s}~(\ref{dcl.type.elab}) are used to
make \grammarterm{class-name}{s}. An object of a class consists of a
(possibly empty) sequence of members and base class objects.

\begin{bnf}
\nontermdef{class-specifier}\br
    class-head \terminal{\{} member-specification\opt \terminal{\}}
\end{bnf}

\begin{bnf}
\nontermdef{class-head}\br
    class-key identifier\opt base-clause\opt\br
    class-key nested-name-specifier identifier base-clause\opt\br
    class-key nested-name-specifier\opt template-id base-clause\opt
\end{bnf}

\begin{bnf}
\nontermdef{class-key}\br
    \terminal{class}\br
    \terminal{struct}\br
    \terminal{union}
\end{bnf}

\pnum
A \grammarterm{class-name} is inserted into the scope in which it is
declared immediately after the \grammarterm{class-name} is seen. The
\grammarterm{class-name} is also inserted into the scope of the class
itself; this is known as the \grammarterm{injected-class-name}.
\indextext{\idxgram{injected-class-name}}%
For purposes of access checking, the injected-class-name is treated as
if it were a public member name.
\indextext{definition!class}%
A \grammarterm{class-specifier} is commonly referred to as a class
definition.
\indextext{definition!class}%
A class is considered defined after the closing brace of its
\grammarterm{class-specifier} has been seen even though its member
functions are in general not yet defined.

\pnum
\indextext{definition!empty class}%
Complete objects and member subobjects of class type shall have nonzero
size.\footnote{Base class subobjects are not so constrained.}
\indextext{\idxcode{sizeof}!empty class}%
\enternote
class objects can be assigned, passed as arguments to functions, and
returned by functions (except objects of classes for which copying has
been restricted; see~\ref{class.copy}). Other plausible operators, such
as equality comparison, can be defined by the user; see~\ref{over.oper}.
\exitnote

\pnum
\indextext{\idxcode{struct}!\tcode{class}~versus}%
\indextext{structure}%
\indextext{\idxcode{union}!\tcode{class}~versus}%
A \term{structure} is a class defined with the \grammarterm{class-key}
\tcode{struct}; its members and base classes (clause~\ref{class.derived})
are public by default (clause~\ref{class.access}).
A \term{union} is a class defined with the \grammarterm{class-key}
\tcode{union}; its members are public by default and
\indextext{access control!\idxcode{union} default member}%
it holds only one data member at a time~(\ref{class.union}).
\enternote
aggregates of class type are described in~\ref{dcl.init.aggr}.
\exitnote
A \defn{POD-struct} is an aggregate class that has no non-static data
members of type non-POD-struct, non-POD-union (or array of such types)
or reference, and has no user-defined copy assignment operator and no
user-defined destructor. Similarly, a \defn{POD-union} is an aggregate
union that has no non-static data members of type non-POD-struct,
non-POD-union (or array of such types) or reference, and has no
user-defined copy assignment operator and no user-defined destructor.
A \defn{POD class} is a class that is either a POD-struct or a POD-union.

\rSec1[class.name]{Class names}
\indextext{definition!class~name~as type}%
\indextext{structure~tag|see{class~name}}%
\indextext{equivalence!type}%

\pnum
A class definition introduces a new type.
\enterexample

\begin{codeblock}
struct X { int a; };
struct Y { int a; };
X a1;
Y a2;
int a3;
\end{codeblock}

declares three variables of three different types. This implies that

\begin{codeblock}
a1 = a2;                        // error: \tcode{Y} assigned to \tcode{X}
a1 = a3;                        // error: \tcode{int} assigned to \tcode{X}
\end{codeblock}

are type mismatches, and that

\begin{codeblock}
int f(X);
int f(Y);
\end{codeblock}

\indextext{overloading}%
declare an overloaded (clause~\ref{over}) function \tcode{f()} and not
simply a single function \tcode{f()} twice. For the same reason,

\begin{codeblock}
struct S { int a; };
struct S { int a; };            // error, double definition
\end{codeblock}

is ill-formed because it defines \tcode{S} twice.
\exitexample

\pnum
\indextext{definition!scope~of class}%
\indextext{class~name!scope~of}%
A class declaration introduces the class name into the scope where
\indextext{name~hiding!class definition}%
it is declared and hides any
class, object, function, or other declaration of that name in an
enclosing scope~(\ref{basic.scope}). If a class name is declared in a
scope where an object, function, or enumerator of the same name is also
declared, then when both declarations are in scope, the class can be
referred to only using an
\grammarterm{elaborated-type-specifier}~(\ref{basic.lookup.elab}).
\enterexample

\begin{codeblock}
struct stat {
	// ...
};

stat gstat;                     // use plain \tcode{stat} to
                                // define variable

int stat(struct stat*);         // redeclare \tcode{stat} as function

void f()
{
    struct stat* ps;            // \tcode{struct} prefix needed
                                // to name \tcode{struct stat}
				// ...
    stat(ps);                   // call \tcode{stat()}
				// ...
}
\end{codeblock}
\exitexampleb
\indextext{class~name!elaborated}%
\indextext{declaration!forward class}%
A \grammarterm{declaration} consisting solely of \grammarterm{class-key
identifier;} is either a redeclaration of the name in the current scope
or a forward declaration of the identifier as a class name. It
introduces the class name into the current scope.
\enterexample

\begin{codeblock}
struct s { int a; };

void g()
{
    struct s;                   // hide global \tcode{struct s}
                                // with a local declaration
    s* p;                       // refer to local \tcode{struct s}
    struct s { char* p; };      // define local \tcode{struct s}
    struct s;                   // redeclaration, has no effect
}
\end{codeblock}
\exitexampleb
\enternote
Such declarations allow definition of classes that refer to each other.
\indextext{example!friend}%
\enterexample

\begin{codeblock}
class Vector;

class Matrix {
	// ...
	friend Vector operator*(Matrix&, Vector&);
};

class Vector {
	// ...
	friend Vector operator*(Matrix&, Vector&);
};
\end{codeblock}

Declaration of \tcode{friend}s is described in~\ref{class.friend},
operator functions in~\ref{over.oper}.
\exitexample
\exitnote

\pnum
\indextext{class~name!elaborated}%
\indextext{elaborated~type~specifier|see{class name, elaborated}}%
An \grammarterm{elaborated-type-specifier}~(\ref{dcl.type.elab}) can also
be used as a \grammarterm{type-specifier} as part of a declaration. It
differs from a class declaration in that if a class of the elaborated
name is in scope the elaborated name will refer to it.
\enterexample

\begin{codeblock}
struct s { int a; };

void g(int s)
{
	struct s* p = new struct s;	// global \tcode{s}
	p->a = s;			// local \tcode{s}
}
\end{codeblock}
\exitexampleb

\pnum
\indextext{class~name!point~of declaration}%
\enternote
The declaration of a class name takes effect immediately after the
\grammarterm{identifier} is seen in the class definition or
\grammarterm{elaborated-type-specifier}. For example,

\begin{codeblock}
class A * A;
\end{codeblock}

first specifies \tcode{A} to be the name of a class and then redefines
it as the name of a pointer to an object of that class. This means that
the elaborated form \tcode{class} \tcode{A} must be used to refer to the
class. Such artistry with names can be confusing and is best avoided.
\exitnote

\pnum
\indextext{class~name!\idxcode{typedef}}%
A \grammarterm{typedef-name}~(\ref{dcl.typedef}) that names a class is
a \grammarterm{class-name}, but shall not be used in an
\grammarterm{elaborated-type-specifier}; see also~\ref{dcl.typedef}.

\rSec1[class.mem]{Class members}%
\indextext{declaration!member}%
\indextext{data~member|see{member}}

\begin{bnf}
\nontermdef{member-specification}\br
    member-declaration member-specification\opt\br
    access-specifier \terminal{:} member-specification\opt
\end{bnf}

\begin{bnf}
\nontermdef{member-declaration}\br
    decl-specifier-seq\opt member-declarator-list\opt \terminal{;}\br
    function-definition \terminal{;\opt}\br
    \terminal{::}\opt nested-name-specifier \terminal{template}\opt unqualified-id \terminal{;}\br
    using-declaration\br
    template-declaration
\end{bnf}

\begin{bnf}
\nontermdef{member-declarator-list}\br
    member-declarator\br
    member-declarator-list \terminal{,} member-declarator
\end{bnf}

\begin{bnf}
\nontermdef{member-declarator}\br
    declarator pure-specifier\opt\br
    declarator constant-initializer\opt\br
    identifier\opt \terminal{:} constant-expression
\end{bnf}

\begin{bnf}
\nontermdef{pure-specifier}\br
    \terminal{= 0}
\end{bnf}

\begin{bnf}
\nontermdef{constant-initializer}\br
    \terminal{=} constant-expression
\end{bnf}

\pnum
\indextext{definition!class}%
The \grammarterm{member-specification} in a class definition declares the
full set of members of the class; no member can be added elsewhere.
Members of a class are data members, member
functions~(\ref{class.mfct}), nested types, and enumerators. Data
members and member functions are static or nonstatic;
see~\ref{class.static}. Nested types are
classes~(\ref{class.name},~\ref{class.nest}) and
enumerations~(\ref{dcl.enum}) defined in the class, and arbitrary types
declared as members by use of a typedef declaration~(\ref{dcl.typedef}).
The enumerators of an enumeration~(\ref{dcl.enum}) defined in the class
are members of the class. Except when used to declare
friends~(\ref{class.friend}) or to introduce the name of a member of a
base class into a derived
class~(\ref{namespace.udecl},\ref{class.access.dcl}),
\grammarterm{member-declaration}{s} declare members of the class, and each
such \grammarterm{member-declaration} shall declare at least one member
name of the class. A member shall not be declared twice in the
\grammarterm{member-specification}, except that a nested class or member
class template can be declared and then later defined.

\pnum
\indextext{completely~defined}%
A class is considered a completely-defined object
type~(\ref{basic.types}) (or complete type) at the closing \tcode{\}} of
the \grammarterm{class-specifier}.
Within the class
\grammarterm{member-specification}, the class is regarded as complete
within function bodies, default arguments and constructor
\grammarterm{ctor-initializer}{s}
(including such things in nested classes).
Otherwise it is regarded as incomplete within its own class
\grammarterm{member-specification}.

\pnum
\enternote
a single name can denote several function members provided their types
are sufficiently different (clause~\ref{over}).
\exitnote

\pnum
A \grammarterm{member-declarator} can contain a
\grammarterm{constant-initializer} only if it declares a \tcode{static}
member~(\ref{class.static}) of \tcode{const} integral or \tcode{const}
enumeration type, see~\ref{class.static.data}.

\pnum
A member can be initialized using a constructor; see~\ref{class.ctor}.
\enternote
see clause~\ref{special} for a description of constructors and other
special member functions.
\exitnote

\pnum
A member shall not be \tcode{auto}, \tcode{extern}
or \tcode{register}.

\pnum
The \grammarterm{decl-specifier-seq} is omitted in constructor, destructor,
and conversion function declarations only.
The
\grammarterm{member-declarator-list} can be omitted only after a
\grammarterm{class-specifier}, an \grammarterm{enum-specifier}, or a
\grammarterm{decl-specifier-seq} of the form \tcode{friend}
\grammarterm{elaborated-type-specifier}. A
\grammarterm{pure-specifier} shall be used only in the declaration of a
virtual function~(\ref{class.virtual}).

\pnum
\indextext{class~object!member}%
Non-\tcode{static}~(\ref{class.static}) members that are class objects
shall be objects of previously defined classes.
In particular, a class \tcode{cl} shall not contain an object
of class \tcode{cl}, but it can contain a pointer or
reference to an object of class \tcode{cl}.
When an array is used as the type of a nonstatic member all dimensions
shall be specified.

\pnum
Except when used to form a pointer to member~(\ref{expr.unary.op}),
when used in the body of a nonstatic member function of its class or of
a class derived from its class~(\ref{class.mfct.nonstatic}), or when
used in a \grammarterm{mem-initializer} for a constructor for its
class or for a class derived from its class~(\ref{class.base.init}),
a nonstatic data or function member of a class shall only be referred
to with the class member access syntax~(\ref{expr.ref}).

\pnum
\enternote
the type of a nonstatic member function is an ordinary function type,
and the type of a nonstatic data member is an ordinary object type.
There are no special member function types or data member types.
\exitnote

\pnum
\indextext{example!class~definition}%
\enterexample
A simple example of a class definition is

\begin{codeblock}
struct tnode {
    char tword[20];
    int count;
    tnode *left;
    tnode *right;
};
\end{codeblock}

which contains an array of twenty characters, an integer, and two
pointers to similar structures. Once this definition has been
given, the declaration

\begin{codeblock}
tnode s, *sp;
\end{codeblock}

declares \tcode{s} to be a \tcode{tnode} and \tcode{sp} to be a pointer
to a \tcode{tnode}. With these declarations, \tcode{sp->count} refers to
the \tcode{count} member of the structure to which \tcode{sp} points;
\tcode{s.left} refers to the \tcode{left} subtree pointer of the structure
\tcode{s}; and \tcode{s.right->tword[0]} refers to the initial character
of the \tcode{tword} member of the \tcode{right} subtree of \tcode{s}.
\exitexample

\pnum
\indextext{layout!class~object}%
Nonstatic data members of a (non-union) class
declared without an intervening \grammarterm{access-specifier}
are allocated so that later
members have higher addresses within a class object.
\indextext{allocation!unspecified}%
The order of allocation of nonstatic data members separated by an
\grammarterm{access-specifier}
is unspecified~(\ref{class.access.spec}).
Implementation alignment requirements might cause two adjacent members
not to be allocated immediately after each other; so might requirements
for space for managing virtual functions~(\ref{class.virtual}) and
virtual base classes~(\ref{class.mi}).

\pnum
If \tcode{T} is the name of a class, then each of the following shall
have a name different from \tcode{T}:

\begin{itemize}
\item every static data member of class \tcode{T};

\item every member function of class \tcode{T}
\enternote
this restriction does not apply to constructors, which do not have
names~(\ref{class.ctor})
\exitnote;

\item every member of class \tcode{T} that is itself a type;

\item every enumerator of every member of class \tcode{T} that is an
enumerated type; and

\item every member of every anonymous union that is a member of class
\tcode{T}.
\end{itemize}

\pnumalt
In addition, if class \tcode{T} has a user-declared
constructor~(\ref{class.ctor}), every nonstatic data member of class
\tcode{T} shall have a name different from \tcode{T}.

\pnum
Two POD-struct (clause~\ref{class}) types are layout-compatible if they
have the same number of nonstatic data members and corresponding
nonstatic data members (in order) have layout-compatible
types~(\ref{basic.types}).

\pnum
Two POD-union (clause~\ref{class}) types are layout-compatible if they
have the same number of nonstatic data members and corresponding
nonstatic data members (in any order) have layout-compatible
types~(\ref{basic.types}).

\pnum
If a POD-union contains two or more POD-structs that share a common
initial sequence, and if the POD-union object currently contains one of
these POD-structs, it is permitted to inspect the common initial part of
any of them. Two POD-structs share a common initial sequence if
corresponding members have layout-compatible types (and, for bit-fields,
the same widths) for a sequence of one or more initial members.

\pnum
A pointer to a POD-struct object, suitably converted using a
\tcode{reinterpret_cast}, points to its initial member (or if that
member is a bit-field, then to the unit in which it resides) and vice
versa.
\enternote
There might therefore be unnamed padding within a POD-struct object, but
not at its beginning, as necessary to achieve appropriate alignment.
\exitnote

\rSec1[class.mfct]{Member functions}%
\indextext{member function!class}

\pnum
Functions declared in the definition of a class, excluding those
declared with a \tcode{friend} specifier~(\ref{class.friend}), are
called member functions of that class. A member function may be declared
\tcode{static} in which case it is a \term{static} member function
of its class~(\ref{class.static}); otherwise it is a
\grammarterm{nonstatic} member function of its
class~(\ref{class.mfct.nonstatic},~\ref{class.this}).

\pnum
\indextext{member function!inline}%
\indextext{definition!member~function}%
A member function may be defined~(\ref{dcl.fct.def}) in its class
definition, in which case it is an \term{inline} member
function~(\ref{dcl.fct.spec}), or it may be defined outside of its class
definition if it has already been declared but not defined in its class
definition. A member function definition that appears outside of the
class definition shall appear in a namespace scope enclosing the class
definition. Except for member function definitions that appear outside
of a class definition, and except for explicit specializations of member
functions of class templates and member function
templates~(\ref{temp.spec}) appearing outside of the class definition, a
member function shall not be redeclared.

\pnum
An \tcode{inline} member function (whether static or nonstatic) may
also be defined outside of its class definition provided either its
declaration in the class definition or its definition outside of the
class definition declares the function as \tcode{inline}.
\enternote
member functions of a class in namespace scope have external linkage.
Member functions of a local class~(\ref{class.local}) have no linkage.
See~\ref{basic.link}.
\exitnote

\pnum
There shall be at most one definition of a non-inline member function in
a program; no diagnostic is required. There may be more than one
\tcode{inline} member function definition in a program.
See~\ref{basic.def.odr} and~\ref{dcl.fct.spec}.

\pnum
\indextext{operator!scope~resolution}%
If the definition of a member function is lexically outside its class
definition, the member function name shall be qualified by its class
name using the \tcode{::} operator.
\enternote
a name used in a member function definition (that is, in the
\grammarterm{parameter-declaration-clause} including the default
arguments~(\ref{dcl.fct.default}), or in the member function body,
or, for a constructor function~(\ref{class.ctor}), in a
\grammarterm{mem-initializer} expression~(\ref{class.base.init}))
is looked up as described in~\ref{basic.lookup}.
\exitnote
\enterexample

\begin{codeblock}
struct X {
	typedef int T;
	static T count;
	void f(T);
};
void X::f(T t = count) { }
\end{codeblock}

The member function \tcode{f} of class \tcode{X} is defined in global
scope; the notation \tcode{X::f} specifies that the function \tcode{f}
is a member of class \tcode{X} and in the scope of class \tcode{X}. In
the function definition, the parameter type \tcode{T} refers to the
typedef member \tcode{T} declared in class \tcode{X} and the default
argument \tcode{count} refers to the static data member \tcode{count}
declared in class \tcode{X}.
\exitexample

\pnum
A \tcode{static} local variable in a member function always refers to
the same object, whether or not the member function is \tcode{inline}.

\pnum
Member functions may be mentioned in \tcode{friend} declarations
after their class has been defined.

\pnum
\indextext{local~class!member~function~in}%
Member functions of a local class shall be defined inline in their class
definition, if they are defined at all.

\pnum
\enternote
a member function can be declared (but not defined) using a typedef for
a function type. The resulting member function has exactly the same type
as it would have if the function declarator were provided explicitly,
see~\ref{dcl.fct}. For example,

\begin{codeblock}
typedef void fv(void);
typedef void fvc(void) const;
struct S {
	fv memfunc1;		// equivalent to: \tcode{void memfunc1(void);}
	void memfunc2();
	fvc memfunc3;		// equivalent to: \tcode{void memfunc3(void) const;}
};
fv  S::* pmfv1 = &S::memfunc1;
fv  S::* pmfv2 = &S::memfunc2;
fvc S::* pmfv3 = &S::memfunc3;
\end{codeblock}

Also see~\ref{temp.arg}.
\exitnote

\rSec2[class.mfct.nonstatic]{Nonstatic member functions}%
\indextext{member function!nonstatic}

\pnum
A \grammarterm{nonstatic} member function may be called for an object of
its class type, or for an object of a class derived
(clause~\ref{class.derived}) from its class type, using the class member
access syntax~(\ref{expr.ref},~\ref{over.match.call}). A nonstatic
member function may also be called directly using the function call
syntax~(\ref{expr.call},~\ref{over.match.call})

\begin{itemize}
\item from within
the body of a member function of its class or of a class derived from
its class, or
\item from a \grammarterm{mem-initializer}~(\ref{class.base.init}) for
a constructor for its class or for a class derived from its class.
\end{itemize}

\indextext{member function!call undefined}%
If a nonstatic member function of a class \tcode{X} is called for an
object that is not of type \tcode{X}, or of a type derived from
\tcode{X}, the behavior is undefined.

\pnum
When an \grammarterm{id-expression}~(\ref{expr.prim}) that is not part of a
class member access syntax~(\ref{expr.ref}) and not used to form a
pointer to member~(\ref{expr.unary.op}) is used in
the body of a nonstatic member function of class \tcode{X} or used in the
\grammarterm{mem-initializer} for a constructor of class \tcode{X},
if name
lookup~(\ref{basic.lookup.unqual}) resolves the name in the
\grammarterm{id-expression} to a nonstatic nontype member of class
\tcode{X} or of a base class of \tcode{X},
the \grammarterm{id-expression} is transformed into a class
member access expression~(\ref{expr.ref}) using
\tcode{(*this)}~(\ref{class.this}) as the \grammarterm{postfix-expression}
to the left of the \tcode{.} operator.
The member name then refers to the member of the object for which the
function is called.
Similarly during name lookup, when an
\grammarterm{unqualified-id}~(\ref{expr.prim}) used in the definition of a
member function for class \tcode{X} resolves to a \tcode{static} member,
an enumerator or a nested type of class \tcode{X} or of a base class of
\tcode{X}, the \grammarterm{unqualified-id} is transformed into a
\grammarterm{qualified-id}~(\ref{expr.prim}) in which the
\grammarterm{nested-name-specifier} names the class of the member function.
\indextext{example!member~function}%
\enterexample

\begin{codeblock}
struct tnode {
	char tword[20];
	int count;
	tnode *left;
	tnode *right;
	void set(const char*, tnode* l, tnode* r);
};

void tnode::set(const char* w, tnode* l, tnode* r)
{
	count = strlen(w)+1;
	if (sizeof(tword)<=count)
		perror("tnode string too long");
	strcpy(tword,w);
	left = l;
	right = r;
}

void f(tnode n1, tnode n2)
{
	n1.set("abc",&n2,0);
	n2.set("def",0,0);
}
\end{codeblock}

In the body of the member function \tcode{tnode::set}, the member names
\tcode{tword}, \tcode{count}, \tcode{left}, and \tcode{right} refer to
members of the object for which the function is called. Thus, in the
call \tcode{n1.set("abc",\&n2,0)}, \tcode{tword} refers to
\tcode{n1.tword}, and in the call \tcode{n2.set("def",0,0)}, it refers
to \tcode{n2.tword}. The functions \tcode{strlen}, \tcode{perror}, and
\tcode{strcpy} are not members of the class \tcode{tnode} and should be
declared elsewhere.\footnote{See, for example, \tcode{<cstring>}~(\ref{lib.c.strings}).}
\exitexample

\pnum
A nonstatic member function may be declared \tcode{const},
\tcode{volatile}, or \tcode{const} \tcode{volatile}. These
\grammarterm{cv-qualifiers} affect the type of the \tcode{this}
pointer~(\ref{class.this}). They also affect the function
type~(\ref{dcl.fct}) of the member function; a member function declared
\tcode{const} is a \term{const} member function, a member function
declared \tcode{volatile} is a \term{volatile} member function and a
member function declared \tcode{const} \tcode{volatile} is a
\term{const volatile} member function.
\enterexample

\begin{codeblock}
struct X {
	void g() const;
	void h() const volatile;
};
\end{codeblock}

\tcode{X::g} is a \tcode{const} member function and \tcode{X::h} is a
\tcode{const} \tcode{volatile} member function.
\exitexample

\pnum
A nonstatic member function may be declared
\term{virtual}~(\ref{class.virtual}) or \term{pure virtual}~(\ref{class.abstract}).

\rSec2[class.this]{The \tcode{this} pointer}%
\indextext{\idxcode{this}}
\indextext{member function!\idxcode{this}}

\pnum
\indextext{this pointer@\tcode{this}~pointer|see{\tcode{this}}}%
In the body of a nonstatic~(\ref{class.mfct}) member function, the
keyword \tcode{this} is a non-lvalue expression whose value is the
address of the object for which the function is called.
\indextext{\idxcode{this}!type~of}%
The type of \tcode{this} in a member function of a class \tcode{X} is
\tcode{X*}.
\indextext{member function!\idxcode{const}}%
If the member function is declared \tcode{const}, the type of
\tcode{this} is \tcode{const} \tcode{X*},
\indextext{member function!\idxcode{volatile}}%
if the member function is declared \tcode{volatile}, the type of
\tcode{this} is \tcode{volatile} \tcode{X*}, and if the member function
is declared \tcode{const} \tcode{volatile}, the type of \tcode{this} is
\tcode{const} \tcode{volatile} \tcode{X*}.

\pnum
\indextext{member function!\idxcode{const}}%
In a \tcode{const} member function, the object for which the function is
called is accessed through a \tcode{const} access path; therefore, a
\tcode{const} member function shall not modify the object and its
non-static data members.
\enterexample

\begin{codeblock}
struct s {
    int a;
    int f() const;
    int g() { return a++; }
    int h() const { return a++; }	// error
};

int s::f() const { return a; }
\end{codeblock}

The \tcode{a++} in the body of \tcode{s::h} is ill-formed because it
tries to modify (a part of) the object for which \tcode{s::h()} is
called. This is not allowed in a \tcode{const} member function because
\tcode{this} is a pointer to \tcode{const}; that is, \tcode{*this} has
\tcode{const} type.
\exitexample

\pnum
Similarly, \tcode{volatile} semantics~(\ref{dcl.type.cv}) apply in
\tcode{volatile} member functions when accessing the object and its
non-static data members.

\pnum
A \grammarterm{cv-qualified} member function can be called on an
object-expression~(\ref{expr.ref}) only if the object-expression is as
cv-qualified or less-cv-qualified than the member function.
\enterexample

\begin{codeblock}
void k(s& x, const s& y)
{
    x.f();
    x.g();
    y.f();
    y.g();                      // error
}
\end{codeblock}

The call \tcode{y.g()} is ill-formed because \tcode{y} is \tcode{const}
and \tcode{s::g()} is a non-\tcode{const} member function, that is,
\tcode{s::g()} is less-qualified than the object-expression \tcode{y}.
\exitexample

\pnum
\indextext{\idxcode{const}!constructor~and}%
\indextext{\idxcode{const}!destructor~and}%
\indextext{\idxcode{volatile}!constructor~and}%
\indextext{\idxcode{volatile}!destructor~and}%
Constructors~(\ref{class.ctor}) and destructors~(\ref{class.dtor}) shall
not be declared \tcode{const}, \tcode{volatile} or \tcode{const}
\tcode{volatile}. \enternote However, these functions can be invoked to
create and destroy objects with cv-qualified types,
see~(\ref{class.ctor}) and~(\ref{class.dtor}).
\exitnote

\rSec1[class.static]{Static members}%
\indextext{member!static}%
\indextext{member function!static}%

\pnum
A data or function member of a class may be declared \tcode{static} in a
class definition, in which case it is a \term{static member} of the class.

\pnum
A \tcode{static} member \tcode{s} of class \tcode{X} may be referred to
using the \grammarterm{qualified-id} expression \tcode{X::s}; it is not
necessary to use the class member access syntax~(\ref{expr.ref}) to
refer to a \tcode{static} member. A \tcode{static} member may be
referred to using the class member access syntax, in which case the
\grammarterm{object-expression} is evaluated.
\enterexample

\begin{codeblock}
class process {
public:
	static void reschedule();
};
process& g();

void f()
{
	process::reschedule();		// OK: no object necessary
	g().reschedule();		// \tcode{g()} is called
}
\end{codeblock}
\exitexampleb
A \tcode{static} member may be referred to directly in the scope of its
class or in the scope of a class derived (clause~\ref{class.derived})
from its class; in this case, the \tcode{static} member is referred to
as if a \grammarterm{qualified-id} expression was used, with the
\grammarterm{nested-name-specifier} of the \grammarterm{qualified-id} naming
the class scope from which the static member is referenced.
\enterexample

\begin{codeblock}
int g();
struct X {
	static int g();
};
struct Y : X {
	static int i;
};
int Y::i = g();                 // equivalent to \tcode{Y::g();}
\end{codeblock}
\exitexampleb

\pnum
If an \grammarterm{unqualified-id}~(\ref{expr.prim}) is used in the
definition of a \tcode{static} member following the member's
\grammarterm{declarator-id}, and name lookup~(\ref{basic.lookup.unqual})
finds that the \grammarterm{unqualified-id} refers to a \tcode{static}
member, enumerator, or nested type of the member's class (or of a base
class of the member's class), the \grammarterm{unqualified-id} is
transformed into a \grammarterm{qualified-id} expression in which the
\grammarterm{nested-name-specifier} names the class scope from which the
member is referenced. The definition of a \tcode{static} member shall
not use directly the names of the nonstatic members of its class or of a
base class of its class (including as operands of the \tcode{sizeof}
operator). The definition of a \tcode{static} member may only refer to
these members to form pointer to members~(\ref{expr.unary.op}) or with
the class member access syntax~(\ref{expr.ref}).

\pnum
Static members obey the usual class member access rules
(clause~\ref{class.access}). When used in the declaration of a class
member, the \tcode{static} specifier shall only be used in the member
declarations that appear within the \grammarterm{member-specification} of
the class definition.
\enternote
it cannot be specified in member declarations that appear in namespace scope.
\exitnote

\rSec2[class.static.mfct]{Static member functions}
\indextext{member function!static}%

\pnum
\enternote
the rules described in~\ref{class.mfct} apply to \tcode{static} member
functions.
\exitnote

\pnum
\enternote
a \tcode{static} member function does not have a \tcode{this}
pointer~(\ref{class.this}).
\exitnote
A \tcode{static} member function shall not be \tcode{virtual}. There
shall not be a \tcode{static} and a nonstatic member function with the
same name and the same parameter types~(\ref{over.load}). A
\tcode{static} member function shall not be declared \tcode{const},
\tcode{volatile}, or \tcode{const volatile}.

\rSec2[class.static.data]{Static data members}
\indextext{member~data!static}%

\pnum
A \tcode{static} data member is not part of the subobjects of a class.
There is only one copy of a \tcode{static} data member shall by all
the objects of the class.

\pnum
\indextext{initialization!static member}%
\indextext{definition!static member}%
The declaration of a \tcode{static} data member in its class definition
is not a definition and may be of an incomplete type other than
cv-qualified \tcode{void}. The definition for a \tcode{static} data
member shall appear in a namespace scope enclosing the member's class
definition.
\indextext{operator~use!scope~resolution}%
In the definition at namespace scope, the name of the \tcode{static}
data member shall be qualified by its class name using the \tcode{::}
operator. The \grammarterm{initializer} expression in the definition of a
\tcode{static} data member is in the scope of its
class~(\ref{basic.scope.class}).
\indextext{example!static@\tcode{static} member}%
\enterexample

\begin{codeblock}
class process {
	static process* run_chain;
	static process* running;
};

process* process::running = get_main();
process* process::run_chain = running;
\end{codeblock}

The \tcode{static} data member \tcode{run_chain} of class
\tcode{process} is defined in global scope; the notation
\tcode{process\colcol{}run_chain} specifies that the member \tcode{run_chain}
is a member of class \tcode{process} and in the scope of class
\tcode{process}. In the \tcode{static} data member definition, the
\grammarterm{initializer} expression refers to the \tcode{static} data
member \tcode{running} of class \tcode{process}.
\exitexample

\pnum
\enternote
once the \tcode{static} data member has been defined, it exists even if
no objects of its class have been created.
\enterexample
in the example above, \tcode{run_chain} and \tcode{running} exist even
if no objects of class \tcode{process} are created by the program.
\exitexample
\exitnote

\pnum
If a \tcode{static} data member is of \tcode{const} integral or
\tcode{const} enumeration type,
its declaration in the class definition can specify a
\grammarterm{constant-initializer} which shall be an integral
constant expression~(\ref{expr.const}). In that case,
the member can appear in integral constant expressions. The
member shall still be defined in a namespace scope if
it is used in the program and the
namespace scope definition shall not contain an \grammarterm{initializer}.

\pnum
There shall be exactly one definition of a \tcode{static} data member
that is used in a program; no diagnostic is required;
see~\ref{basic.def.odr}.
Unnamed classes and classes contained directly
or indirectly within unnamed classes shall not contain \tcode{static}
data members.
\enternote
this is because there is no mechanism to provide the definitions for
such \tcode{static} data members.
\exitnote

\pnum
\indextext{restriction!static@\tcode{static} member local~class}%
\tcode{Static} data members of a class in namespace scope have external
linkage~(\ref{basic.link}). A local class shall not have \tcode{static}
data members.

\pnum
\tcode{Static} data members are initialized and destroyed exactly like
non-local objects~(\ref{basic.start.init},~\ref{basic.start.term}).

\pnum
A \tcode{static} data member shall not be
\tcode{mutable}~(\ref{dcl.stc}).

\rSec1[class.union]{Unions}%
\indextext{\idxcode{union}}

\pnum
In a union, at most one of the data members can be active at any
time, that is, the value of at most one of the data members can be
stored in a union at any time. \enternote one special guarantee is made in order to
simplify the use of unions: If a POD-union contains several POD-structs
that share a common initial sequence~(\ref{class.mem}), and if an object
of this POD-union type contains one of the POD-structs, it is permitted
to inspect the common initial sequence of any of POD-struct members;
see~\ref{class.mem}. \exitnote The size of a union is sufficient to contain the largest
of its data members. Each data member is allocated
as if it were the sole member of a struct. A union can have member
functions (including constructors and destructors), but not
virtual~(\ref{class.virtual}) functions. A union shall not have base
classes. A union shall not be used as a base class. An object of a class
with a non-trivial constructor~(\ref{class.ctor}), a non-trivial copy
constructor~(\ref{class.copy}), a non-trivial destructor~(\ref{class.dtor}),
or a non-trivial copy assignment operator~(\ref{over.ass},
\ref{class.copy}) cannot be a member of a union, nor can an array of
such objects. If a union contains a \tcode{static} data member, or a
member of reference type, the program is ill-formed.

\pnum
\indextext{\idxcode{union}!anonymous}%
A union of the form

\begin{ncbnftab}
\terminal{union} \terminal{\{} member-specification \terminal{\} ;}
\end{ncbnftab}

is called an anonymous union; it defines an unnamed object of unnamed
type. The \grammarterm{member-specification} of an anonymous union shall
only define non-static data members.
\enternote
nested types and functions cannot be declared within an anonymous union.
\exitnote
The names of the members of an anonymous union shall be distinct from
the names of any other entity in the scope in which the anonymous union
is declared. For the purpose of name lookup, after the anonymous union
definition, the members of the anonymous union are considered to have
been defined in the scope in which the anonymous union is declared.
\indextext{initialization!\idxcode{union}}%
\enterexample

\begin{codeblock}
void f()
{
    union { int a; char* p; };
    a = 1;
    // ...
    p = "Jennifer";
    // ...
}
\end{codeblock}

Here \tcode{a} and \tcode{p} are used like ordinary (nonmember)
variables, but since they are union members they have the same address.
\exitexample

\pnum
\indextext{\idxcode{union}!global anonymous}%
\indextext{scope!anonymous \tcode{union}~at namespace}%
Anonymous unions declared in a named namespace or in the global
namespace shall be declared \tcode{static}. Anonymous unions declared at
block scope shall be declared with any storage class allowed for a
block-scope variable, or with no storage class. A storage class is not
allowed in a declaration of an anonymous union in a class scope.
\indextext{access~control!anonymous \tcode{union}}%
\indextext{restriction!anonymous \tcode{union}}%
An anonymous union shall not have \tcode{private} or \tcode{protected}
members (clause~\ref{class.access}). An anonymous union shall not have
function members.

\pnum
A union for which objects or pointers are declared is not an anonymous union.
\enterexample

\begin{codeblock}
union { int aa; char* p; } obj, *ptr = &obj;
aa = 1;                         // error
ptr->aa = 1;                    // OK
\end{codeblock}

The assignment to plain \tcode{aa} is ill-formed since the member name
is not visible outside the union, and even if it were visible, it is not
associated with any particular object.
\exitexample
\enternote
Initialization of unions with no user-declared constructors is described
in~(\ref{dcl.init.aggr}).
\exitnote

\rSec1[class.bit]{Bit-fields}%
\indextext{bit-field}

\pnum
A \grammarterm{member-declarator} of the form

\begin{ncbnftab}
identifier\opt \terminal{:} constant-expression
\end{ncbnftab}

\indextext{\idxcode{:}!field declaration}%
\indextext{declaration!bit-field}%
specifies a bit-field;
its length is set off from the bit-field name by a colon. The bit-field
attribute is not part of the type of the class member. The
\grammarterm{constant-expression} shall be an integral constant-expression
with a value greater than or equal to zero. The constant-expression may
be larger than the number of bits in the object
representation~(\ref{basic.types}) of the bit-field's type; in such
cases the extra bits are used as padding bits and do not participate in
the value representation~(\ref{basic.types}) of the bit-field.
\indextext{allocation!implementation~defined bit-field}%
Allocation of bit-fields within a class object is
\impldef{allocation of bit-fields within a class object}.
\indextext{bit-field!implementation~defined alignment~of}%
Alignment of bit-fields is \impldef{alignment of bit-fields within a class object}.
\indextext{layout!bit-field}%
Bit-fields are packed into some addressable allocation unit.
\enternote
bit-fields straddle allocation units on some machines and not on others.
Bit-fields are assigned right-to-left on some machines, left-to-right on
others.
\exitnote

\pnum
\indextext{bit-field!unnamed}%
A declaration for a bit-field that omits the \grammarterm{identifier}
declares an \grammarterm{unnamed} bit-field. Unnamed bit-fields are not
members and cannot be initialized.
\enternote
an unnamed bit-field is useful for padding to conform to
externally-imposed layouts.
\exitnote
\indextext{bit-field!zero~width~of}%
\indextext{bit-field!alignment~of}%
As a special case, an unnamed bit-field with a width of zero specifies
alignment of the next bit-field at an allocation unit boundary. Only
when declaring an unnamed bit-field may the
\grammarterm{constant-expression} be a value equal to zero.

\pnum
\indextext{bit-field!type~of}%
A bit-field shall not be a static member. A bit-field shall have
integral or enumeration type~(\ref{basic.fundamental}).
\indextext{bit-field!implementation-defined sign~of}%
It is \impldef{signedness of plain integral bit-field} whether a plain (neither
explicitly signed nor unsigned) \tcode{char}, \tcode{short}, \tcode{int}
or \tcode{long}
bit-field is signed or unsigned.
\indextext{Boolean}%
A \tcode{bool} value can successfully be stored in a bit-field of any
nonzero size.
\indextext{bit-field!address~of}%
The address-of operator \tcode{\&} shall not be applied to a bit-field,
so there are no pointers to bit-fields.
\indextext{restriction!bit-field}%
\indextext{restriction!address~of bit-field}%
\indextext{restriction!pointer~to bit-field}%
A non-const reference shall not be bound to a
bit-field~(\ref{dcl.init.ref}).
\enternote
if the initializer for a reference of type \tcode{const} \tcode{T\&} is
an lvalue that refers to a bit-field, the reference is bound to a
temporary initialized to hold the value of the bit-field; the reference
is not bound to the bit-field directly. See~\ref{dcl.init.ref}.
\exitnote

\pnum
If the value \tcode{true} or \tcode{false} is stored into a bit-field of
type \tcode{bool} of any size (including a one bit bit-field), the
original \tcode{bool} value and the value of the bit-field shall compare
equal. If the value of an enumerator is stored into a bit-field of the
same enumeration type and the number of bits in the bit-field is large
enough to hold all the values of that enumeration type,
the original enumerator value and the value of the bit-field shall
compare equal.
\enterexample

\begin{codeblock}
enum BOOL { f=0, t=1 };
struct A {
	BOOL b:1;
};
A a;
void f() {
	a.b = t;
	if (a.b == t)		// shall yield \tcode{true}
	{ /* ... */ }
}
\end{codeblock}
\exitexampleb

\rSec1[class.nest]{Nested class declarations}%
\indextext{definition!nested~class}%
\indextext{class~local|see{local~class}}%
\indextext{class~nested|see{nested~class}}

\pnum
A class can be declared within another class. A class declared within
another is called a \grammarterm{nested} class. The name of a nested class
is local to its enclosing class. The nested class is in the scope of its
enclosing class. Except by using explicit pointers,
references, and object names,
\indextext{nested~class!scope~of}%
declarations in a nested class can use only type names, static members,
and enumerators from the enclosing class.
\indextext{example!nested~class}%
\enterexample

\begin{codeblock}
int x;
int y;

class enclose {
public:
    int x;
    static int s;

    class inner {

	void f(int i)
	{
	    int a = sizeof(x);  // error: refers to \tcode{enclose::x}
	    x = i;              // error: assign to \tcode{enclose::x}
	    s = i;              // OK: assign to \tcode{enclose::s}
	    ::x = i;            // OK: assign to global \tcode{x}
	    y = i;              // OK: assign to global \tcode{y}
	}

	void g(enclose* p, int i)
	{
	    p->x = i;           // OK: assign to \tcode{enclose::x}
	}

    };
};

inner* p = 0;                   // error: \tcode{inner} not in scope
\end{codeblock}
\exitexampleb

\pnum
Member functions and static data members of a nested class can be
defined in a namespace scope enclosing the definition of their class.
\indextext{example!nested~class definition}%
\enterexample

\begin{codeblock}
class enclose {
public:
    class inner {
	static int x;
	void f(int i);
    };
};

int enclose::inner::x = 1;

void enclose::inner::f(int i) { /* ... */ }
\end{codeblock}
\exitexampleb

\pnum
If class \tcode{X} is defined in a namespace scope, a nested class
\tcode{Y} may be declared in class \tcode{X} and later defined in the
definition of class \tcode{X} or be later defined in a namespace scope
enclosing the definition of class \tcode{X}.
\indextext{example!nested~class forward~declaration}%
\enterexample

\begin{codeblock}
class E {
    class I1;                   // forward declaration of nested class
    class I2;
    class I1 {};		// definition of nested class
};
class E::I2 {};			// definition of nested class
\end{codeblock}
\exitexampleb

\pnum
\indextext{friend~function!nested~class}%
Like a member function, a friend function~(\ref{class.friend}) defined
within a nested class is in the lexical scope of that class; it obeys
the same rules for name binding as a static member function of that
class~(\ref{class.static}) and has no special access rights to
members of an enclosing class.

\rSec1[class.local]{Local class declarations}
\indextext{declaration!local~class}%
\indextext{definition!local~class}%

\pnum
A class can be declared within a function definition; such a class is
called a \grammarterm{local} class. The name of a local class is local to
its enclosing scope.
\indextext{local~class!scope~of}%
The local class is in the scope of the enclosing scope, and has the same
access to names outside the function as does the enclosing function.
Declarations in a local class can use only type names, static variables,
\tcode{extern} variables and functions, and enumerators from the
enclosing scope.
\enterexample
\indextext{example!local~class}%
\begin{codeblock}
int x;
void f()
{
    static int s ;
    int x;
    extern int g();

    struct local {
	int g() { return x; }   // error: \tcode{x} is auto
	int h() { return s; }   // OK
	int k() { return ::x; } // OK
	int l() { return g(); } // OK
    };
    // ...
}

local* p = 0;                   // error: \tcode{local} not in scope
\end{codeblock}
\exitexampleb

\pnum
An enclosing function has no special access to members of the local
class; it obeys the usual access rules (clause~\ref{class.access}).
\indextext{member function!local~class}%
Member functions of a local class shall be defined within their class
definition, if they are defined at all.

\pnum
\indextext{nested~class!local~class}%
If class \tcode{X} is a local class a nested class \tcode{Y} may be
declared in class \tcode{X} and later defined in the definition of class
\tcode{X} or be later defined in the same scope as the definition of
class \tcode{X}.
\indextext{restriction!local~class}%
A class nested within
a local class is a local class.

\pnum
A local class shall not have static data members.

\rSec1[class.nested.type]{Nested type names}
\indextext{type~name!nested}%
\indextext{type~name!nested!scope of}%

\pnum
Type names obey exactly the same scope rules as other names. In
particular, type names defined within a class definition cannot be used
outside their class without qualification.
\enterexample

\indextext{example!nested type~name}%
\begin{codeblock}
class X {
public:
    typedef int I;
    class Y { /* ... */ };
    I a;
};

I b;                            // error
Y c;                            // error
X::Y d;                         // OK
X::I e;                         // OK
\end{codeblock}
\exitexampleb%
\indextext{class|)}
