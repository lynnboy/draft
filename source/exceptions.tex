\rSec0[except]{Exception handling}%
\indextext{exception handling|(}

%gram: \rSec1[gram.except]{Exception handling}
%gram:

\indextext{exception object|see{exception handling, exception object}}%
\indextext{object, exception|see{exception handling, exception object}}

\pnum
Exception handling provides a way of transferring control and information
from a point in the execution of a program to an exception handler
associated with a point previously passed by the execution.
A handler will be invoked only by a
\grammarterm{throw-expression}
invoked in code executed in the handler's try block
or in functions called from the handler's try block .

\indextext{\idxcode{try}}%
%
\begin{bnf}
\nontermdef{try-block}\br
    \terminal{try} compound-statement handler-seq
\end{bnf}

\indextext{\idxcode{try}}%
%
\begin{bnf}
\nontermdef{function-try-block}\br
    \terminal{try} ctor-initializer\opt function-body handler-seq
\end{bnf}

\begin{bnf}
\nontermdef{handler-seq}\br
    handler handler-seq\opt
\end{bnf}

\indextext{\idxcode{catch}}%
%
\begin{bnf}
\nontermdef{handler}\br
    \terminal{catch (} exception-declaration \terminal{)} compound-statement
\end{bnf}

\begin{bnf}
\nontermdef{exception-declaration}\br
    type-specifier-seq declarator\br
    type-specifier-seq abstract-declarator\br
    type-specifier-seq\br
    \terminal{...}
\end{bnf}

\indextext{\idxcode{throw}}%
%
\begin{bnf}
\nontermdef{throw-expression}\br
    \terminal{throw}  assignment-expression\opt
\end{bnf}

\indextext{exception handling!try block}%
\indextext{exception handling!handler}%
\indextext{try block|see{exception handling, try block}}%
\indextext{handler|see{exception handling, handler}}%
A \grammarterm{try-block} is a \grammarterm{statement} (clause~\ref{stmt.stmt}).
A \grammarterm{throw-expression} is of type \tcode{void}. Code that executes a
\grammarterm{throw-expression} is said to ``throw an exception;'' code that
subsequently gets control is called a ``handler.'' \enternote within this clause
``try block'' is taken to mean both \grammarterm{try-block} and
\grammarterm{function-try-block}. \exitnote

\pnum
\indextext{exception handling!\idxcode{goto}}%
\indextext{exception handling!\idxcode{switch}}%
\indextext{\idxcode{goto}!and try block}%
\indextext{\idxcode{switch}!and try block}%
\indextext{\idxcode{goto}!and handler}%
\indextext{\idxcode{switch}!and handler}%
A \tcode{goto} or \tcode{switch} statement shall not be used to transfer control
into a try block or into a handler.
\enterexample
\begin{codeblock}
void f() {
    goto l1;		// Ill-formed
    goto l2;		// Ill-formed
    try {
	goto l1;	// OK
	goto l2;	// Ill-formed
	l1: ;
    } catch (...) {
	l2: ;
	goto l1;	// Ill-formed
	goto l2;	// OK
    }
}

\end{codeblock}
\exitexampleb
\indextext{\idxcode{goto}!and try block}%
\indextext{\idxcode{switch}!and try block}%
\indextext{\idxcode{return}!and try block}%
\indextext{\idxcode{continue}!and try block}%
\indextext{\idxcode{goto}!and handler}%
\indextext{\idxcode{switch}!and handler}%
\indextext{\idxcode{return}!and handler}%
\indextext{\idxcode{continue}!and handler}%
A
\tcode{goto},
\tcode{break},
\tcode{return},
or
\tcode{continue}
statement can be used to transfer control out of
a try block or handler.
When this happens, each variable declared in the try block
will be destroyed in the context that
directly contains its declaration.
\enterexample

\begin{codeblock}
lab:  try {
	   T1 t1;
	   try {
		  T2 t2;
		  if (@\textit{condition}@)
			goto lab;
	   } catch(...) { /* @\textit{handler 2}@ */ }
      } catch(...) { /* @\textit{handler 1}@ */ }
\end{codeblock}

Here, executing
\tcode{goto lab;}
will destroy first
\tcode{t2},
then
\tcode{t1},
assuming the
\grammarterm{condition}
does not declare a variable.
Any exception raised while destroying
\tcode{t2}
will result in executing
\textit{handler 2};
any exception raised while destroying
\tcode{t1}
will result in executing
\textit{handler 1}.
\exitexample

\pnum
\indextext{function try block|see{exception handling, function try block}}%
\indextext{exception handling!function try block}%
A \grammarterm{function-try-block} associates a \grammarterm{handler-seq}
with the \grammarterm{ctor-initializer},
if present, and the \grammarterm{function-body}. An exception
thrown during the execution of the initializer expressions in the
\grammarterm{ctor-initializer} or during the execution of the
\grammarterm{function-body}
transfers control to a handler in a \grammarterm{function-try-block}
in the same way as an exception thrown during the execution of a
\grammarterm{try-block}
transfers control to other handlers.
\enterexample
\begin{codeblock}
int f(int);
class C {
	int i;
	double d;
public:
	C(int, double);
};

C::C(int ii, double id)
try
	: i(f(ii)), d(id)
{
	// constructor statements
}
catch (...)
{
	// handles exceptions thrown from the ctor-initializer
	// and from the constructor statements
}

\end{codeblock}
\exitexampleb


\rSec1[except.throw]{Throwing an exception}%
\indextext{exception handling!throwing}%
\indextext{throwing|see{exception handling, throwing}}

\pnum
Throwing an exception transfers control to a handler.
An object is passed and the type of that object determines which handlers
can catch it.
\enterexample
\begin{codeblock}
throw "Help!";
\end{codeblock}
can be caught by a
\term{handler}
of
\tcode{const}
\tcode{char*}
type:
\begin{codeblock}
try {
	// ...
}
catch(const char* p) {
	// handle character string exceptions here
}
\end{codeblock}
and
\begin{codeblock}
class Overflow {
	// ...
public:
    Overflow(char,double,double);
};

void f(double x)
{
	// ...
	throw Overflow('+',x,3.45e107);
}
\end{codeblock}
can be caught by a handler for exceptions of type
\tcode{Overflow}
\begin{codeblock}
try {
	// ...
	f(1.2);
	// ...
}
catch(Overflow& oo) {
	// handle exceptions of type \tcode{Overflow} here
}
\end{codeblock}
\exitexampleb

\pnum
\indextext{exception handling!throwing}%
\indextext{exception handling!handler}%
\indextext{exception handling!nearest handler}%
When an exception is thrown, control is transferred to the nearest handler with
a matching type~(\ref{except.handle}); ``nearest'' means the handler
for which the
\grammarterm{compound-statement},
\grammarterm{ctor-initializer},
or \grammarterm{function-body}
following the
\tcode{try}
keyword was most recently entered by the thread of control and not yet exited.

\pnum
A
\grammarterm{throw-expression}
initializes a temporary object,
called the
\indextext{exception handling!exception object}\term{exception object},
the type of which
is determined by removing any top-level
\grammarterm{cv-qualifier}{s}
from the static type of the operand of
\tcode{throw}
and adjusting the type from ``array of
\tcode{T}''
or ``function returning
\tcode{T}''
to ``pointer to
\tcode{T}''
or ``pointer to function
returning
\tcode{T}'',
respectively.
\enternote
the temporary object created for a \grammarterm{throw-expression} that is a
string literal is never of type \tcode{char*} or \tcode{wchar_t*}; that is,
the special conversions for string literals from the types ``array of
\tcode{const char}'' and ``array of \tcode{const wchar_t}'' to the types
``pointer to \tcode{char}'' and ``pointer to \tcode{wchar_t}'',
respectively~(\ref{conv.array}), are never applied to a
\grammarterm{throw-expression}.
\exitnote
The temporary is used to initialize the variable named in the matching
\term{handler}~(\ref{except.handle}).
The type of the \grammarterm{throw-expression} shall not be an incomplete
type, or a pointer or reference to an incomplete type, other than
\tcode{void*}, \tcode{const void*}, \tcode{volatile void*}, or
\tcode{const volatile void*}.
Except for these restrictions and the restrictions on type matching mentioned
in~\ref{except.handle}, the operand of
\tcode{throw}
is treated exactly as a function argument in a call~(\ref{expr.call}) or the operand
of a return statement.

\pnum
\indextext{exception handling!memory}%
\indextext{exception handling!rethrowing}%
\indextext{exception handling!exception object}%
The memory for the temporary copy of the exception being thrown is
allocated in an unspecified way, except as noted in~\ref{basic.stc.dynamic.allocation}.
The temporary persists as long as there is a handler being executed for that
exception. In particular, if a handler exits by executing a \tcode{throw;}
statement, that passes control to another handler for
the same exception, so the temporary remains.
When the last handler being executed for the exception exits by any means
other than \tcode{throw;} the temporary object is destroyed and the
implementation may deallocate the memory for the temporary object; any such
deallocation is done in an unspecified way. The destruction occurs immediately
after the destruction of the object declared in the
\grammarterm{exception-declaration} in the handler.

\pnum
\indextext{exception handling!exception object!constructor}%
\indextext{exception handling!exception object!destructor}%
If the use of the temporary object can be eliminated without changing the
meaning of the program except for the execution of constructors and
destructors associated with the use of the temporary
object~(\ref{class.temporary}), then the exception in the handler can be
initialized directly with the argument of the throw exception.
When the thrown object is a class object, and the copy constructor used to
initialize the temporary copy is not accessible, the program is ill-formed
(even when the temporary object could otherwise be eliminated).
Similarly, if the destructor for that object is not accessible, the
program is ill-formed (even when the temporary object could otherwise
be eliminated).

\pnum
\indextext{exception handling!rethrow}%
\indextext{rethrow|see{exception handling, rethrow}}%
\indextext{reraise|see{exception handling, rethrow}}%
A \grammarterm{throw-expression} with no operand rethrows the exception
being handled. The exception is reactivated with the existing temporary;
no new temporary exception object is created. The exception is no longer
considered to be caught; therefore, the value of \tcode{uncaught_exception()}
will again be \tcode{true}.
\enterexample
code that must be executed because of an exception yet cannot completely
handle the exception can be writen like this:
\begin{codeblock}
try {
	// ...
}
catch (...) {			// catch all exceptions

	// respond (partially) to exception

	throw;			// pass the exception to some
				// other handler
}
\end{codeblock}
\exitexampleb

\pnum
\indextext{exception handling!terminate called@\tcode{terminate()} called}%
\indextext{\idxcode{terminate()}!called}%
The exception thrown is the one most recently caught and not finished. An
exception is considered caught when initialization is complete for the
formal parameter of the corresponding catch clause, or when \tcode{terminate()}
or \tcode{unexpected()} is entered due to a throw. An exception is considered
finished when the corresponding catch clause exits or when \tcode{unexpected()}
exits after being entered due to a \tcode{throw}.

\pnum
\indextext{exception handling!rethrow}%
\indextext{exception handling!terminate called@\tcode{terminate()} called}%
\indextext{\idxcode{terminate()}!called}%
If no exception is presently being handled,
executing a
\grammarterm{throw-expression}
with no operand calls
\tcode{terminate()} (\ref{except.terminate}).

\rSec1[except.ctor]{Constructors and destructors}%
\indextext{exception handling!constructors and destructors}%
\indextext{stack unwinding!see exception handling, constructors and destructors}%
\indextext{constructor!exception~handling|see{exception handling, constructors and destructors}}%
\indextext{destructor!exception~handling|see{exception handling, constructors and destructors}}

\pnum
As control passes from a
\grammarterm{throw-expression}
to a handler,
destructors are invoked for all automatic objects constructed since the
try block was entered.
The automatic objects are destroyed in the reverse order of the completion
of their construction.

\pnum
An object that is partially constructed or partially destroyed will have
destructors executed for all of its fully constructed subobjects,
that is, for subobjects for which the constructor has completed execution
and the destructor has not yet begun execution. Should a constructor
for an element of an automatic array throw an exception, only the
constructed elements of that array will be destroyed.
If the object or array was allocated in a
\grammarterm{new-expression},
the matching deallocation function~(\ref{basic.stc.dynamic.deallocation}, \ref{expr.new}, \ref{class.free}),
if any, is called to free the storage occupied by the object.

\pnum
\indextext{unwinding!stack}%
The process of calling destructors for automatic objects constructed on the
path from a try block to a
\grammarterm{throw-expression}
is called
``\term{stack unwinding}.''
\enternote
If a destructor called during stack unwinding exits with an exception,
\tcode{terminate}
is called~(\ref{except.terminate}).
So destructors should generally catch
exceptions and not let them propagate out of the destructor.
\exitnoteb

\rSec1[except.handle]{Handling an exception}
\indextext{exception handling!handler|(}%

\pnum
The
\grammarterm{exception-declaration}
in a
\term{handler}
describes the type(s) of exceptions that can cause
that
\term{handler}
to be entered.
\indextext{exception handling!handler!incomplete type in}%
\indextext{exception handling!handler!rvalue reference in}%
\indextext{exception handling!handler!array in}%
\indextext{exception handling!handler!pointer to function in}%
The
\grammarterm{exception-declaration}
shall not denote an incomplete type.
The
\grammarterm{exception-declaration}
shall not denote a pointer or reference to an
incomplete type, other than
\tcode{void*},
\tcode{const}
\tcode{void*},
\tcode{volatile}
\tcode{void*},
or
\tcode{const}
\tcode{volatile}
\tcode{void*}.
Types shall not be defined in an
\grammarterm{exception-declaration}.

\pnum
A handler of type ``array of
\tcode{T}''
or ``function returning
\tcode{T}''
is adjusted to be of type ``pointer to
\tcode{T}''
or ``pointer to function
returning
\tcode{T}'',
respectively.

\pnum
\indextext{exception handling!handler!match|(}%
A
\term{handler}
is a match for
an exception object
of type
\tcode{E}
if
\begin{itemize}
\item%
The
\term{handler}
is of type
\textit{cv}
\tcode{T}
or
\textit{cv}
\tcode{T\&}
and
\tcode{E}
and
\tcode{T}
are the same type (ignoring the top-level
\grammarterm{cv-qualifiers}),
or
\item%
the
\term{handler}
is of type
\textit{cv}
\tcode{T}
or
\textit{cv}
\tcode{T\&}
and
\tcode{T}
is an unambiguous public base class of
\tcode{E},
or
\item%
the
\term{handler}
is of type
\textit{cv1}
\tcode{T*}
\textit{cv2}
and
\tcode{E}
is a pointer type that can be
converted to the type of the
\term{handler}
by either or both of
\begin{itemize}

\item%
a standard pointer conversion~(\ref{conv.ptr}) not involving conversions
to pointers to private or protected or ambiguous classes
\item%
a qualification conversion

\end{itemize}

\end{itemize}

\enternote
a
\grammarterm{throw-expression}
which is an integral constant expression of integer type
that evaluates to zero does not match a handler of pointer type;
that is, the null pointer constant conversions~(\ref{conv.ptr},
\ref{conv.mem}) do not apply.
\exitnote

\pnum
\enterexample
\begin{codeblock}
class Matherr { /* ... */ virtual vf(); };
class Overflow: public Matherr { /* ... */ };
class Underflow: public Matherr { /* ... */ };
class Zerodivide: public Matherr { /* ... */ };

void f()
{
    try {
	g();
    }
    
    catch (Overflow oo) {
	// ...
    }
    catch (Matherr mm) {
	// ...
    }
}
\end{codeblock}
Here, the
\tcode{Overflow}
handler will catch exceptions of type
\tcode{Overflow}
and the
\tcode{Matherr}
handler will catch exceptions of type
\tcode{Matherr}
and of all types publicly derived from
\tcode{Matherr}
including exceptions of type
\tcode{Underflow}
and
\tcode{Zerodivide}.
\exitexample

\pnum
The handlers for a try block are tried in order of appearance.
That makes it possible to write handlers that can never be
executed, for example by placing a handler for a derived class after
a handler for a corresponding base class.

\pnum
A
\tcode{...}
in a handler's
\grammarterm{exception-declaration}
functions similarly to
\tcode{...}
in a function parameter declaration;
it specifies a match for any exception.
If present, a
\tcode{...}
handler shall be the last handler for its try block.

\pnum
If no match is found among the handlers for a try block,
the search for a matching
handler continues in a dynamically surrounding try block.

\pnum
An exception is considered handled upon entry to a handler.
\enternote
the stack will have been unwound at that point.
\exitnote

\pnum
If no matching handler is found in a program,
the function
\tcode{terminate()}
is called;
whether or not the stack is unwound before this call to
\tcode{terminate()}
is \impldef{stack unwinding before call to
\tcode{terminate()}}~(\ref{except.terminate}).

\pnum
Referring to any non-static member or base class of an object
in the handler for a
\grammarterm{function-try-block}
of a constructor or destructor for that object results in undefined behavior.

\pnum
The fully constructed base classes and members of an object shall
be destroyed before entering the handler of a
\grammarterm{function-try-block}
of a constructor or destructor for that object.

\pnum
The scope and lifetime of the parameters of a function or constructor
extend into the handlers of a
\grammarterm{function-try-block}.

\pnum
Exceptions thrown in destructors of objects with static storage duration or in
constructors of namespace-scope objects are not caught by a
\grammarterm{function-try-block}
on
\tcode{main()}.

\pnum
If the handlers of a
\grammarterm{function-try-block}
contain a jump into the body of a constructor or destructor, the program
is ill-formed.

\pnum
If a return statement appears in a handler of the
\grammarterm{function-try-block}
of a constructor, the program is ill-formed.

\pnum
The exception being handled
is rethrown if control reaches the end of a handler of the
\grammarterm{function-try-block}
of a constructor or destructor. Otherwise, a
function returns when control reaches the end of a handler for the
\grammarterm{function-try-block}~(\ref{stmt.return}).
Flowing off the end of a
\grammarterm{function-try-block}
is equivalent to a
\tcode{return}
with no value;
this results in undefined behavior in a value-returning function~(\ref{stmt.return}).

\pnum
When the \grammarterm{exception-declaration} specifies a class type, a copy
constructor is used to initialize either the object declared in the
\grammarterm{exception-declaration} or,
if the \grammarterm{exception-declaration} does not specify a name, a
temporary object of that type. The object shall not have an abstract class type.
The object is destroyed when the handler exits, after the destruction of
any automatic objects initialized within the handler. The copy constructor
and destructor shall be accessible in the context of the handler. If the
copy constructor and destructor are implicitly declared~(\ref{class.copy}),
such a use in the handler causes these functions to be implicitly defined;
otherwise the program shall provide a definition for these functions.

\pnum
If the use of a temporary object can be eliminated without changing the
meaning of the program except for execution of constructors and destructors
associated with the use of the temporary object, then the optional name
can be bound directly to the temporary object specified in a
\grammarterm{throw-expression} causing the handler to be executed. The copy
constructor and destructor associated with the object shall be accessible
even when the temporary object is eliminated.

\pnum
When the handler declares a non-constant object,
any changes to that object will not affect the temporary object
that was initialized by execution of the
\grammarterm{throw-expression}.
When the handler declares a reference to a non-constant object,
any changes to the referenced object are changes to the
temporary object initialized when the
\grammarterm{throw-expression}
was executed and will have effect should that object be rethrown.%
\indextext{exception handling!handler!match|)}%
\indextext{exception handling!handler|)}

\rSec1[except.spec]{Exception specifications}%
\indextext{exception specification|(}

\pnum
A function declaration lists exceptions
that its function might directly or indirectly throw
by using an
\grammarterm{exception-specification}
as a suffix of its declarator.

\begin{bnf}
\nontermdef{exception-specification}\br
    \terminal{throw (} type-id-list\opt \terminal{)}
\end{bnf}

\begin{bnf}
\nontermdef{type-id-list}\br
    type-id\br
    type-id-list \terminal{,} type-id
\end{bnf}

An
\grammarterm{exception-specification}
shall appear only on a function declarator in a function,
pointer, reference or pointer to member declaration or definition.
An
\grammarterm{exception-specification}
shall not appear in a typedef declaration.
\enterexample
\begin{codeblock}
void f() throw(int);                    // OK
void (*fp)() throw (int);               // OK
void g(void pfa() throw(int));          // OK
typedef int (*pf)() throw(int);         // ill-formed
\end{codeblock}

\exitexampleb
\indextext{exception specification!incomplete type and}%
A type denoted in an
\grammarterm{exception-specification}
shall not denote an incomplete type.
A type denoted in an
\grammarterm{exception-specification}
shall not denote a pointer or reference to an incomplete type, other than
\tcode{void*},
\tcode{const}
\tcode{void*},
\tcode{volatile}
\tcode{void*},
or
\tcode{const}
\tcode{volatile}
\tcode{void*}.

\pnum
If any declaration of a function has an
\grammarterm{exception-specification},
all declarations, including the definition and an explicit specialization,
of that function shall have an
\grammarterm{exception-specification}
with the same set of \grammarterm{type-id}{s}.
If any declaration of a pointer to function, reference to function,
or pointer to member function has an
\grammarterm{exception-specification},
all occurrences of that declaration shall have an
\grammarterm{exception-specification}
with the same set of \grammarterm{type-id}{s}.
In an explicit instantiation directive an
\grammarterm{exception-specification}
may be specified, but is not required.
If an
\grammarterm{exception-specification}
is specified in an explicit instantiation directive, it shall
have the same set of \grammarterm{type-id}{s} as
other declarations of that function.
A diagnostic is required only if the sets of \grammarterm{type-id}{s}
are different within a single translation unit.

\pnum
\indextext{exception specification!virtual function and}%
If a virtual function has an
\grammarterm{exception-specification},
all declarations, including the definition, of any function
that overrides that virtual function in any derived class
shall only allow exceptions that are allowed by the
\grammarterm{exception-specification}
of the base class virtual function.
\enterexample
\begin{codeblock}
struct B {
    virtual void f() throw (int, double);
    virtual void g();
};

struct D: B {
    void f();			// ill-formed
    void g() throw (int);	// OK
};
\end{codeblock}

The declaration of
\tcode{D::f}
is ill-formed because it allows all exceptions, whereas
\tcode{B::f}
allows only
\tcode{int}
and
\tcode{double}.
\exitexample
A similar restriction applies to assignment to and
initialization of pointers to functions, pointers
to member functions, and references to functions:
the target entity shall allow at least the exceptions
allowed by the source value in the assignment or
initialization.
\enterexample
\begin{codeblock}
class A { /* ... */ };
void (*pf1)();			// no exception specification
void (*pf2)() throw(A);

void f()
{
	pf1 = pf2;		// OK: \tcode{pf1} is less restrictive
	pf2 = pf1;		// error: \tcode{pf2} is more restrictive
}
\end{codeblock}
\exitexampleb

\pnum
In such an assignment or initialization,
\grammarterm{exception-specification}{s}
on return types and parameter types shall match exactly.
In other assignments or initializations,
\grammarterm{exception-specification}{s}
shall match exactly.

\pnum
Types shall not be defined in \grammarterm{exception-specification}{s}.

\pnum
An
\grammarterm{exception-specification}
can include the same type more than once
and can include classes that are related by inheritance,
even though doing so is redundant.
An
\grammarterm{exception-specification}
can also include the class
\tcode{std::bad_exception}~(\ref{lib.bad.exception}).

\pnum
\indextext{exception handling!allowing an exception}%
\indextext{allowing an exception|see{exception handling, allowing an exception}}%
A function is said to
\term{allow}
an exception of type
\tcode{E}
if its
\grammarterm{exception-specification}
contains a type
\tcode{T}
for which a handler of type
\tcode{T}
would be a match~(\ref{except.handle}) for an exception of type
\tcode{E}.

\pnum
\indextext{exception handling!unexpected called@\tcode{unexpected()} called}%
\indextext{\idxcode{unexpected()}!called}%
Whenever an exception is thrown and the search for a handler~(\ref{except.handle})
encounters the outermost block of a function with an
\grammarterm{exception-specification}, the function
\tcode{unexpected()} is called~(\ref{except.unexpected}) if the
\grammarterm{exception-specification} does not allow the exception.
\enterexample
\begin{codeblock}
class X { };
class Y { };
class Z: public X { };
class W { };

void f() throw (X, Y)
{
    int n = 0;
    if (n) throw X();		// OK
    if (n) throw Z();		// also OK
    throw W();			// will call \tcode{unexpected()}
}
\end{codeblock}
\exitexampleb

\pnum
\indextext{\idxcode{unexpected()}}%
The function
\tcode{unexpected()}
may throw an exception that will satisfy the
\grammarterm{exception-specification}
for which it was invoked, and in this case the search for another handler
will continue at the call of the function with this
\grammarterm{exception-specification}
(see~\ref{except.unexpected}), or it may call
\tcode{terminate()}.

\pnum
An implementation shall not reject an expression merely because when
executed it throws or might
throw an exception that the containing function does not allow.
\enterexample
\begin{codeblock}
extern void f() throw(X, Y);

void g() throw(X)
{
	f();			// OK
}

\end{codeblock}
the call to
\tcode{f}
is well-formed even though when called,
\tcode{f}
might throw exception
\tcode{Y}
that
\tcode{g}
does not allow.
\exitexample

\pnum
A function with no
\grammarterm{exception-specification}
allows all exceptions.
A function with an empty
\grammarterm{exception-specification},
\tcode{throw()},
does not allow any exceptions.

\pnum
An
\grammarterm{exception-specification}
is not considered part of a function's type.

\pnum
An implicitly declared special member function (clause~\ref{special}) shall have an
\grammarterm{exception-specification}.
If
\tcode{f}
is an implicitly declared default constructor, copy constructor,
destructor, or copy assignment operator, its implicit
\grammarterm{exception-specification} specifies
the
\grammarterm{type-id}
\tcode{T}
if and only if
\tcode{T}
is allowed by the \grammarterm{exception-specification} of a function directly
invoked by \tcode{f}'s
implicit
definition;
\tcode{f}
shall allow all exceptions if any function it directly invokes allows all
exceptions, and
\tcode{f}
shall allow no exceptions if every function it directly invokes allows no
exceptions.
\enterexample
\begin{codeblock}
struct A {
    A();
    A(const A&) throw();
    ~A() throw(X);
};
struct B {
    B() throw();
    B(const B&) throw();
    ~B() throw(Y);
};
struct D : public A, public B {
	// Implicit declaration of \tcode{D::D();}
	// Implicit declaration of \tcode{D::D(const D\&) throw();}
	// Implicit declaration of \tcode{D::$\sim$D() throw(X,Y);}
};
\end{codeblock}

Furthermore, if
\tcode{A::\~{}A()}
or
\tcode{B::\~{}B()}
were virtual,
\tcode{D::\~{}D()}
would not be as restrictive as that of
\tcode{A::\~{}A},
and the program would be ill-formed since a function that overrides a virtual
function from a base class shall have an \grammarterm{exception-specification}
 at least as restrictive as that in the base class.
\exitexample

\rSec1[except.special]{Special functions}

\pnum
The exception handling mechanism relies on two functions,
\tcode{terminate()} and
\tcode{unexpected()}, for coping with errors related to the exception handling
mechanism itself~(\ref{lib.support.exception}).

\rSec2[except.terminate]{The \tcode{terminate()} function}

\pnum
\indextext{\idxcode{terminate()}}%
In the following situations exception handling must be abandoned
for less subtle error handling techniques.

\indextext{\idxcode{terminate()}!called}%
\begin{itemize}
\item%
when the exception handling mechanism, after completing
evaluation of the expression to be thrown but before
the exception is caught~(\ref{except.throw}),
calls a user function that exits via an uncaught exception,\footnote{For
example, if the object being thrown is of a class with a copy constructor,
\tcode{terminate()} will be called if that copy constructor exits with an
exception during a \tcode{throw}.}

\item%
when the exception handling mechanism cannot find a handler for a thrown exception~(\ref{except.handle}), or

\item%
when the destruction of an object during stack unwinding~(\ref{except.ctor})
exits using an exception, or

\item%
when construction or destruction of a non-local
object with static storage duration
exits using an exception~(\ref{basic.start.init}), or

\item%
when execution of a function registered with
\tcode{atexit}
exits using an exception~(\ref{lib.support.start.term}), or

\item%
when a
\grammarterm{throw-expression}
with no operand attempts to rethrow an exception and no exception is being
handled~(\ref{except.throw}), or

\item%
when
\tcode{unexpected}
throws an exception which is not allowed by the previously violated
\grammarterm{exception-specification},
and
\tcode{std::bad_exception}
is not included in that
\grammarterm{exception-specifica\brk{-}tion} (\ref{except.unexpected}), or

\item%
when the implementation's default \tcode{unexpected_handler}
is called~(\ref{lib.unexpected.handler})

\end{itemize}

\pnum
\indextext{\idxcode{terminate()}}%
In such cases,

\begin{codeblock}
void terminate();
\end{codeblock}

is called~(\ref{lib.exception.terminate}).
In the situation where no matching handler is found, it is
\impldef{stack unwinding before call to \tcode{terminate()}} whether or not the
stack is unwound
before
\tcode{terminate()}
is called.
In all other situations, the stack shall not be unwound before
\tcode{terminate()}
is called.
An implementation is not permitted to finish stack unwinding
prematurely based on a determination that the unwind process
will eventually cause a call to
\tcode{terminate()}.

\rSec2[except.unexpected]{The \tcode{unexpected()} function}

\pnum
\indextext{\idxcode{unexpected()}}%
If a function with
an \grammarterm{exception-specification}
throws an exception that is not listed in the
\grammarterm{exception-specification},
the function
\begin{codeblock}
void unexpected();
\end{codeblock}
is called~(\ref{lib.exception.unexpected}) immediately after completing
the stack unwinding for the former function.

\pnum
The
\tcode{unexpected()}
function shall not return, but it can throw (or re-throw) an exception.
If it throws a new exception which is allowed by the exception specification
which previously was violated, then the search for another handler
will continue at the call of the function whose exception specification was violated.
If it throws or rethrows an exception that the
\grammarterm{exception-specification}
does not allow
then the following happens:
\indextext{\idxcode{bad_exception}}%
If the
\grammarterm{exception-specification}
does not include the class
\tcode{std::bad_exception}~(\ref{lib.bad.exception})
then the function
\tcode{terminate()}
is called, otherwise the thrown exception is replaced by an
implementation-defined object of the type
\tcode{std::bad_exception}
and the search for another handler will continue at the call of the function
whose
\grammarterm{exception-specification}
was violated.

\pnum
Thus,
an \grammarterm{exception-specification}
guarantees that only the listed exceptions will be thrown.
If the
\grammarterm{exception-specification}
includes the type
\tcode{std::bad_exception}
then any exception not on the list may be replaced by
\tcode{std\-::\-bad_ex\-cep\-tion}
within the function
\tcode{unexpected()}.

\rSec2[except.uncaught]{The \tcode{uncaught_exception()} function}%
\indextext{\idxcode{uncaught_exception()}}

\pnum
The function
\begin{codeblock}
bool uncaught_exception() throw()
\end{codeblock}
returns
\tcode{true}
after completing evaluation of the object to be thrown until completing the
initialization of the \grammarterm{exception-declaration} in the matching
handler~(\ref{lib.uncaught}).
This includes stack unwinding.
If the exception is rethrown~(\ref{except.throw}),
\tcode{uncaught_exception()}
returns
\tcode{true}
from the point of rethrow until the rethrown exception is caught again.

\rSec1[except.access]{Exceptions and access}

\pnum
If the \grammarterm{exception-declaration} in a catch clause has class type,
and the function in which the catch clause occurs does not have access to
the destructor of that class, the program is ill-formed.

\pnum
An object can be thrown if it can be copied and destroyed in the context
of the function in which the \grammarterm{throw-expression} occurs.%
\indextext{exception handling|)}
