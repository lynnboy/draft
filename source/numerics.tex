\rSec0[lib.numerics]{Numerics library}

\pnum
This clause describes components that \Cpp programs may use to perform
seminumerical operations.

\pnum
The following subclauses describe components for
complex number types,
numeric (%
\textit{n}-at-a-time)
arrays, generalized numeric algorithms,
and facilities included from the ISO C library,
as summarized in Table~\ref{tab:numerics.lib.summary}.

\begin{libsumtab}{Numerics library summary}{tab:numerics.lib.summary}
\ref{lib.numeric.requirements}  & Requirements &           \\ \rowsep
\ref{lib.complex.numbers} & Complex Numbers & \tcode{<complex>} \\ \rowsep
\ref{lib.numarray}  & Numeric arrays     & \tcode{<valarray>}  \\ \rowsep
\ref{lib.numeric.ops} & Generalized numeric operations  & \tcode{<numeric>} \\ \rowsep
\ref{lib.c.math}  & C library            & \tcode{<cmath>}   \\
              &                        & \tcode{<cstdlib>} \\
\end{libsumtab}

\rSec1[lib.numeric.requirements]{Numeric type requirements}
\indextext{requirements!numeric type}

\pnum
The
\tcode{complex}
and
\tcode{valarray}
components are parameterized by the type of information they contain and manipulate.
A \Cpp program shall instantiate these components only with a type
\tcode{T}
that satisfies the
following requirements:\footnote{In other words, value types.
These include built-in arithmetic types, pointers, the library class
\tcode{complex},
and instantiations of
\tcode{valarray}
for value types.}

\begin{itemize}
\item \tcode{T} is not an abstract class (it has no pure virtual member functions);
\item \tcode{T} is not a reference type;
\item \tcode{T} is not cv-qualified;
\item If \tcode{T} is a class, it has a public default constructor;
\item If \tcode{T} is a class, it has a public copy constructor with the signature \tcode{T::T(const T\&)}
\item If \tcode{T} is a class, it has a public destructor;
\item If \tcode{T} is a class, it has a public assignment operator whose signature is either
\tcode{T\& T::operator=(const T\&)}
or
\tcode{T\& T::operator=(T)}
\item If \tcode{T} is a class, its assignment operator, copy and default constructors,
and destructor shall correspond to each other in the following sense:
Initialization of raw storage using the default constructor, followed by
assignment, is semantically equivalent to initialization of raw
storage using the copy constructor.
Destruction of an object, followed by
initialization of its raw storage using the copy constructor,
is semantically equivalent to assignment to the original object.

\enternote
This rule states that there shall not be any subtle differences in the semantics
of initialization versus assignment.
This gives an implementation
considerable flexibility in how arrays are initialized.

\enterexample
An implementation is allowed to initialize a
\tcode{valarray}
by allocating storage using the
\tcode{new}
operator (which
implies a call to the default constructor for each element) and then
assigning each element its value.
Or the implementation can allocate raw
storage and use the copy constructor to initialize each element.
\exitexampleb

If the distinction between initialization and assignment is important
for a class, or if it fails to satisfy any of
the other conditions listed above, the programmer should use
\tcode{vector}~(\ref{lib.vector}) instead of
\tcode{valarray}
for that class;
\exitnoteb
\item If \tcode{T} is a class, it does not overload unary
\tcode{operator\&}.
\end{itemize}

\pnum
If any operation on \tcode{T}
throws an exception the effects are undefined.

\pnum
In addition, many member and related functions of
\tcode{valarray<T>}
can be successfully instantiated
and will exhibit well-defined behavior if and only if
\tcode{T} satisfies additional requirements specified for each such member
or related function.

\pnum
\enterexample
It is valid to instantiate
\tcode{valarray<complex>},
but
\tcode{operator>()}
will not be successfully instantiated for
\tcode{valarray<complex>}
operands, since
\tcode{complex}
does not have any ordering operators.
\exitexampleb

\rSec1[lib.complex.numbers]{Complex numbers}

\pnum
The header
\indexlibrary{\idxhdr{complex}}%
\tcode{<complex>}
defines a
class template,
and numerous functions for representing and manipulating complex numbers.

\pnum
The effect of instantiating the template
\tcode{complex}
for any type other than \tcode{float}, \tcode{double}, or \tcode{long double} is unspecified.

\pnum
If the result of a function is not mathematically defined or not in
the range of representable values for its type, the behavior is
undefined.

\rSec2[lib.complex.synopsis]{Header \tcode{<complex>} synopsis}

\indexlibrary{\idxhdr{complex}}%
\begin{codeblock}
namespace std {
  template<class T> class complex;
  template<> class complex<float>;
  template<> class complex<double>;
  template<> class complex<long double>;

  // \ref{lib.complex.ops}, operators:
  template<class T>
    complex<T> operator+(const complex<T>&, const complex<T>&);
  template<class T> complex<T> operator+(const complex<T>&, const T&);
  template<class T> complex<T> operator+(const T&, const complex<T>&);

  template<class T> complex<T> operator-
    (const complex<T>&, const complex<T>&);
  template<class T> complex<T> operator-(const complex<T>&, const T&);
  template<class T> complex<T> operator-(const T&, const complex<T>&);

  template<class T> complex<T> operator*
    (const complex<T>&, const complex<T>&);
  template<class T> complex<T> operator*(const complex<T>&, const T&);
  template<class T> complex<T> operator*(const T&, const complex<T>&);

  template<class T> complex<T> operator/
    (const complex<T>&, const complex<T>&);
  template<class T> complex<T> operator/(const complex<T>&, const T&);
  template<class T> complex<T> operator/(const T&, const complex<T>&);

  template<class T> complex<T> operator+(const complex<T>&);
  template<class T> complex<T> operator-(const complex<T>&);

  template<class T> bool operator==
    (const complex<T>&, const complex<T>&);
  template<class T> bool operator==(const complex<T>&, const T&);
  template<class T> bool operator==(const T&, const complex<T>&);

  template<class T> bool operator!=(const complex<T>&, const complex<T>&);
  template<class T> bool operator!=(const complex<T>&, const T&);
  template<class T> bool operator!=(const T&, const complex<T>&);

  template<class T, class charT, class traits>
  basic_istream<charT, traits>&
  operator>>(basic_istream<charT, traits>&, complex<T>&);

  template<class T, class charT, class traits>
  basic_ostream<charT, traits>&
  operator<<(basic_ostream<charT, traits>&, const complex<T>&);

  // \ref{lib.complex.value.ops}, values:

  template<class T> T real(const complex<T>&);
  template<class T> T imag(const complex<T>&);

  template<class T> T abs(const complex<T>&);
  template<class T> T arg(const complex<T>&);
  template<class T> T norm(const complex<T>&);

  template<class T> complex<T> conj(const complex<T>&);
  template<class T> complex<T> polar(const T& rho, const T& theta = 0);

  // \ref{lib.complex.transcendentals}, transcendentals:
  template<class T> complex<T> cos  (const complex<T>&);
  template<class T> complex<T> cosh (const complex<T>&);
  template<class T> complex<T> exp  (const complex<T>&);
  template<class T> complex<T> log  (const complex<T>&);
  template<class T> complex<T> log10(const complex<T>&);

  template<class T> complex<T> pow(const complex<T>&, int);
  template<class T> complex<T> pow(const complex<T>&, const T&);
  template<class T> complex<T> pow(const complex<T>&, const complex<T>&);
  template<class T> complex<T> pow(const T&, const complex<T>&);

  template<class T> complex<T> sin  (const complex<T>&);
  template<class T> complex<T> sinh (const complex<T>&);
  template<class T> complex<T> sqrt (const complex<T>&);
  template<class T> complex<T> tan  (const complex<T>&);
  template<class T> complex<T> tanh (const complex<T>&);
}
\end{codeblock}

\rSec2[lib.complex]{Class template \tcode{complex}}

\indexlibrary{\idxcode{complex}}%
\begin{codeblock}
namespace std {
  template<class T>
  class complex {
  public:
    typedef T value_type;

    complex(const T& re = T(), const T& im = T());
    complex(const complex&);
    template<class X> complex(const complex<X>&);

    T real() const;
    T imag() const;

    complex<T>& operator= (const T&);
    complex<T>& operator+=(const T&);
    complex<T>& operator-=(const T&);
    complex<T>& operator*=(const T&);
    complex<T>& operator/=(const T&);

    complex& operator=(const complex&);
    template<class X> complex<T>& operator= (const complex<X>&);
    template<class X> complex<T>& operator+=(const complex<X>&);
    template<class X> complex<T>& operator-=(const complex<X>&);
    template<class X> complex<T>& operator*=(const complex<X>&);
    template<class X> complex<T>& operator/=(const complex<X>&);
  };
}
\end{codeblock}

\pnum
The class
\tcode{complex}
describes an object that can
store the Cartesian components,
\tcode{real()}
and
\tcode{imag()},
of a complex
number.

\rSec2[lib.complex.special]{\tcode{complex} specializations}

\begin{codeblock}
  template<> class complex<float> {
  public:
    typedef float value_type;

    complex(float re = 0.0f, float im = 0.0f);
    explicit complex(const complex<double>&);
    explicit complex(const complex<long double>&);

    float real() const;
    float imag() const;

    complex<float>& operator= (float);
    complex<float>& operator+=(float);
    complex<float>& operator-=(float);
    complex<float>& operator*=(float);
    complex<float>& operator/=(float);

    complex<float>& operator=(const complex<float>&);
    template<class X> complex<float>& operator= (const complex<X>&);
    template<class X> complex<float>& operator+=(const complex<X>&);
    template<class X> complex<float>& operator-=(const complex<X>&);
    template<class X> complex<float>& operator*=(const complex<X>&);
    template<class X> complex<float>& operator/=(const complex<X>&);
  };

  template<> class complex<double> {
  public:
    typedef double value_type;

    complex(double re = 0.0, double im = 0.0);
    complex(const complex<float>&);
    explicit complex(const complex<long double>&);

    double real() const;
    double imag() const;

    complex<double>& operator= (double);
    complex<double>& operator+=(double);
    complex<double>& operator-=(double);
    complex<double>& operator*=(double);
    complex<double>& operator/=(double);

    complex<double>& operator=(const complex<double>&);
    template<class X> complex<double>& operator= (const complex<X>&);
    template<class X> complex<double>& operator+=(const complex<X>&);
    template<class X> complex<double>& operator-=(const complex<X>&);
    template<class X> complex<double>& operator*=(const complex<X>&);
    template<class X> complex<double>& operator/=(const complex<X>&);
  };

  template<> class complex<long double> {
  public:
    typedef long double value_type;

    complex(long double re = 0.0L, long double im = 0.0L);
    complex(const complex<float>&);
    complex(const complex<double>&);

    long double real() const;
    long double imag() const;

    complex<long double>& operator=(const complex<long double>&);
    complex<long double>& operator= (long double);
    complex<long double>& operator+=(long double);
    complex<long double>& operator-=(long double);
    complex<long double>& operator*=(long double);
    complex<long double>& operator/=(long double);

    template<class X> complex<long double>& operator= (const complex<X>&);
    template<class X> complex<long double>& operator+=(const complex<X>&);
    template<class X> complex<long double>& operator-=(const complex<X>&);
    template<class X> complex<long double>& operator*=(const complex<X>&);
    template<class X> complex<long double>& operator/=(const complex<X>&);
  };
\end{codeblock}

\rSec2[lib.complex.members]{\tcode{complex} member functions}

\indexlibrary{\idxcode{complex}!\idxcode{complex}}%
\begin{itemdecl}
template<class T> complex(const T& re = T(), const T& im = T());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{complex}.

\pnum
\postcondition
\tcode{real() == re \&\& imag() == im}.
\end{itemdescr}

\rSec2[lib.complex.member.ops]{\tcode{complex} member operators}

\indexlibrary{\idxcode{operator+=}!\idxcode{complex}}%
\begin{itemdecl}
template <class T> complex<T>& operator+=(const T& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Adds the scalar value \tcode{rhs} to the real part of the complex value
\tcode{*this}
and stores the result in the real part of
\tcode{*this},
leaving the imaginary part unchanged.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator-=}!\idxcode{complex}}%
\begin{itemdecl}
template <class T> complex<T>& operator-=(const T& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Subtracts the scalar value \tcode{rhs} from the real part of the complex value
\tcode{*this}
and stores the result in the real part of
\tcode{*this},
leaving the imaginary part unchanged.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator*=}!\idxcode{complex}}%
\begin{itemdecl}
template <class T> complex<T>& operator*=(const T& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Multiplies the scalar value \tcode{rhs} by the complex value
\tcode{*this}
and stores the result in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator/=}!\idxcode{complex}}%
\begin{itemdecl}
template <class T> complex<T>& operator/=(const T& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Divides the scalar value \tcode{rhs} into the complex value
\tcode{*this}
and stores the result in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator+=}!\idxcode{complex}}%
\begin{itemdecl}
template <class T> complex<T>& operator+=(const complex<T>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Adds the complex value \tcode{rhs} to the complex value
\tcode{*this}
and stores the sum in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator-=}!\idxcode{complex}}%
\begin{itemdecl}
template <class T> complex<T>& operator-=(const complex<T>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Subtracts the complex value \tcode{rhs} from the complex value
\tcode{*this}
and stores the difference in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator*=}!\idxcode{complex}}%
\begin{itemdecl}
template <class T> complex<T>& operator*=(const complex<T>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Multiplies the complex value \tcode{rhs} by the complex value
\tcode{*this}
and stores the product in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator/=}!\idxcode{complex}}%
\begin{itemdecl}
template <class T> complex<T>& operator/=(const complex<T>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Divides the complex value \tcode{rhs} into the complex value
\tcode{*this}
and stores the quotient in
\tcode{*this}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec2[lib.complex.ops]{\tcode{complex} non-member operations}

\indexlibrary{\idxcode{operator+}!\idxcode{complex}}%
\begin{itemdecl}
template<class T> complex<T> operator+(const complex<T>& lhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\notes
unary operator.

\pnum
\returns
\tcode{complex<T>(lhs)}.
\end{itemdescr}

\begin{codeblock}
template<class T>
  complex<T> operator+(const complex<T>& lhs, const complex<T>& rhs);
template<class T> complex<T> operator+(const complex<T>& lhs, const T& rhs);
template<class T> complex<T> operator+(const T& lhs, const complex<T>& rhs);
\end{codeblock}

\begin{itemdescr}
\pnum
\returns
\tcode{complex<T>(lhs) += rhs}.
\end{itemdescr}

\indexlibrary{\idxcode{operator-}!\idxcode{complex}}%
\begin{itemdecl}
template<class T> complex<T> operator-(const complex<T>& lhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\notes
unary operator.

\pnum
\returns
\tcode{complex<T>(-lhs.real(),-lhs.imag())}.
\end{itemdescr}

\indexlibrary{\idxcode{operator-}!\idxcode{complex}}%
\indexlibrary{\idxcode{complex}!\idxcode{operator-}}%
\begin{itemdecl}
template<class T>
  complex<T> operator-(const complex<T>& lhs, const complex<T>& rhs);
template<class T> complex<T> operator-(const complex<T>& lhs, const T& rhs);
template<class T> complex<T> operator-(const T& lhs, const complex<T>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{complex<T>(lhs) -= rhs}.
\end{itemdescr}

\indexlibrary{\idxcode{operator*}!\idxcode{complex}}%
\begin{itemdecl}
template<class T>
  complex<T> operator*(const complex<T>& lhs, const complex<T>& rhs);
template<class T> complex<T> operator*(const complex<T>& lhs, const T& rhs);
template<class T> complex<T> operator*(const T& lhs, const complex<T>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{complex<T>(lhs) *= rhs}.
\end{itemdescr}

\indexlibrary{\idxcode{operator/}!\idxcode{complex}}%
\indexlibrary{\idxcode{complex}!\idxcode{operator/}}%
\begin{itemdecl}
template<class T>
  complex<T> operator/(const complex<T>& lhs, const complex<T>& rhs);
template<class T> complex<T> operator/(const complex<T>& lhs, const T& rhs);
template<class T> complex<T> operator/(const T& lhs, const complex<T>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{complex<T>(lhs) /= rhs}.
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{complex}}%
\begin{itemdecl}
template<class T>
  bool operator==(const complex<T>& lhs, const complex<T>& rhs);
template<class T> bool operator==(const complex<T>& lhs, const T& rhs);
template<class T> bool operator==(const T& lhs, const complex<T>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{lhs.real() == rhs.real() \&\& lhs.imag() == rhs.imag()}.

\pnum
\notes
The imaginary part is assumed to be
\tcode{T()},
or 0.0, for the
\tcode{T}
arguments.
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{complex}}%
\begin{itemdecl}
template<class T>
  bool operator!=(const complex<T>& lhs, const complex<T>& rhs);
template<class T> bool operator!=(const complex<T>& lhs, const T& rhs);
template<class T> bool operator!=(const T& lhs, const complex<T>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rhs.real() != lhs.real() || rhs.imag() != lhs.imag()}.
\end{itemdescr}

\indexlibrary{operator>>@\tcode{operator\shr}!\idxcode{complex}}%
\begin{itemdecl}
template<class T, class charT, class traits>
basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Extracts a complex number \tcode{x} of the form:
\tcode{u},
\tcode{(u)},
or
\tcode{(u,v)},
where
\tcode{u}
is the real part and
\tcode{v}
is the imaginary part~(\ref{lib.istream.formatted}).

\pnum
\requires
The input values shall be convertible to
\tcode{T}.

If bad input is encountered, calls
\tcode{is.setstate(ios_base::failbit)}
(which may throw
\tcode{ios::failure} (\ref{lib.iostate.flags})).

\pnum
\returns
\tcode{is}.

\pnumalt
\notes
This extraction is performed as a series of simpler
extractions.
Therefore, the skipping of whitespace is specified to be
the same for each of the simpler extractions.
\end{itemdescr}

\indexlibrary{operator<<@\tcode{operator\shl}!\idxcode{complex}}%
\begin{itemdecl}
template<class T, class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& o, const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
inserts the complex number \tcode{x}
onto the stream \tcode{o} as if it were implemented as follows:

\begin{codeblock}
  template<class T, class charT, class traits>
  basic_ostream<charT, traits>&
  operator<<(basic_ostream<charT, traits>& o, const complex<T>& x)
  {
          basic_ostringstream<charT, traits> s;
          s.flags(o.flags());
          s.imbue(o.getloc());
          s.precision(o.precision());
          s << '(' << x.real() << "," << x.imag() << ')';
          return o << s.str();
  }
\end{codeblock}
\end{itemdescr}

\rSec2[lib.complex.value.ops]{\tcode{complex} value operations}

\indexlibrary{\idxcode{real}!\idxcode{complex}}%
\begin{itemdecl}
template<class T> T real(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.real()}.
\end{itemdescr}

\indexlibrary{\idxcode{imag}!\idxcode{complex}}%
\begin{itemdecl}
template<class T> T imag(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.imag()}.
\end{itemdescr}

\indexlibrary{\idxcode{abs}!\idxcode{complex}}%
\begin{itemdecl}
template<class T> T abs(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
the magnitude of \tcode{x}.
\end{itemdescr}

\indexlibrary{\idxcode{arg}!\idxcode{complex}}%
\begin{itemdecl}
template<class T> T arg(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
the phase angle of \tcode{x}, or \tcode{atan2(imag(x), real(x))}.
\end{itemdescr}

\indexlibrary{\idxcode{norm}!\idxcode{complex}}%
\begin{itemdecl}
template<class T> T norm(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
the squared magnitude of \tcode{x}.
\end{itemdescr}

\indexlibrary{\idxcode{conj}!\idxcode{complex}}%
\begin{itemdecl}
template<class T> complex<T> conj(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
the complex conjugate of \tcode{x}.
\end{itemdescr}

\indexlibrary{\idxcode{polar}!\idxcode{complex}}%
\begin{itemdecl}
template<class T> complex<T> polar(const T& rho, const T& theta = 0);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
the
\tcode{complex}
value corresponding
to a complex number whose magnitude is \tcode{rho} and whose phase angle
is \tcode{theta}.
\end{itemdescr}

\rSec2[lib.complex.transcendentals]{\tcode{complex} transcendentals}

\indexlibrary{\idxcode{cos}!\idxcode{complex}}%
\begin{itemdecl}
template<class T> complex<T> cos(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
the complex cosine of \tcode{x}.
\end{itemdescr}

\indexlibrary{\idxcode{cosh}!\idxcode{complex}}%
\begin{itemdecl}
template<class T> complex<T> cosh(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
the complex hyperbolic cosine of \tcode{x}.
\end{itemdescr}

\indexlibrary{\idxcode{exp}!\idxcode{complex}}%
\begin{itemdecl}
template<class T> complex<T> exp(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
the complex base e exponential of \tcode{x}.
\end{itemdescr}

\indexlibrary{\idxcode{log}!\idxcode{complex}}%
\begin{itemdecl}
template<class T> complex<T> log(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\notes
the branch cuts are along the negative real axis.

\pnum
\returns
the complex natural (base e) logarithm of \tcode{x},
in the range of a strip mathematically unbounded along the
real axis and in the interval \crange{-i times pi}{i times pi}
along the imaginary axis.
When \tcode{x} is a negative real
number,
\tcode{imag(log(x))}
is pi.
\end{itemdescr}

\indexlibrary{\idxcode{log10}!\idxcode{complex}}%
\begin{itemdecl}
template<class T> complex<T> log10(const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\notes
the branch cuts are along the negative real axis.

\pnum
\returns
the complex common (base 10) logarithm of \tcode{x}, defined as
\tcode{log(x)/log(10)}.
\end{itemdescr}

\indexlibrary{\idxcode{pow}!\idxcode{complex}}%
\begin{itemdecl}
template<class T> complex<T> pow(const complex<T>& x, int y);
template<class T>
  complex<T> pow(const complex<T>& x, const complex<T>& y);
template<class T> complex<T> pow  (const complex<T>& x, const T& y);
template<class T> complex<T> pow  (const T& x, const complex<T>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\notes
the branch cuts are along the negative real axis.

\pnum
\returns
the complex power of base \tcode{x} raised to the \tcode{y}-th power,
defined as
\tcode{exp(y*log(x))}.
The value returned for
\tcode{pow(0,0)}
is implementation-defined.
\end{itemdescr}

\indexlibrary{\idxcode{sin}!\idxcode{complex}}%
\begin{itemdecl}
template<class T> complex<T> sin  (const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
the complex sine of \tcode{x}.
\end{itemdescr}

\indexlibrary{\idxcode{sinh}!\idxcode{complex}}%
\begin{itemdecl}
template<class T> complex<T> sinh (const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
the complex hyperbolic sine of \tcode{x}.
\end{itemdescr}

\indexlibrary{\idxcode{sqrt}!\idxcode{complex}}%
\begin{itemdecl}
template<class T> complex<T> sqrt (const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\notes
the branch cuts are along the negative real axis.

\pnum
\returns
the complex square root of \tcode{x}, in the range of the right
half-plane.
If the argument is a negative real number, the
value returned lies on the positive imaginary axis.
\end{itemdescr}

\indexlibrary{\idxcode{tan}!\idxcode{complex}}%
\begin{itemdecl}
template<class T> complex<T> tan  (const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
the complex tangent of \tcode{x}.
\end{itemdescr}

\indexlibrary{\idxcode{tanh}!\idxcode{complex}}%
\begin{itemdecl}
template<class T> complex<T> tanh (const complex<T>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
rhe complex hyperbolic tangent of \tcode{x}.
\end{itemdescr}

\rSec1[lib.numarray]{Numeric arrays}

\rSec2[lib.valarray.synopsis]{Header \tcode{<valarray>} synopsis}
\indexlibrary{\idxhdr{valarray}}%
\begin{codeblock}
namespace std {
  template<class T> class valarray;         // An array of type \tcode{T}
  class slice;                              // a BLAS-like slice out of an array
  template<class T> class slice_array;
  class gslice;                             // a generalized slice out of an array
  template<class T> class gslice_array;
  template<class T> class mask_array;       // a masked array
  template<class T> class indirect_array;   // an indirected array

  template<class T> valarray<T> operator*
    (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> operator* (const valarray<T>&, const T&);
  template<class T> valarray<T> operator* (const T&, const valarray<T>&);

  template<class T> valarray<T> operator/
    (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> operator/ (const valarray<T>&, const T&);
  template<class T> valarray<T> operator/ (const T&, const valarray<T>&);

  template<class T> valarray<T> operator%
    (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> operator% (const valarray<T>&, const T&);
  template<class T> valarray<T> operator% (const T&, const valarray<T>&);

  template<class T> valarray<T> operator+
    (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> operator+ (const valarray<T>&, const T&);
  template<class T> valarray<T> operator+ (const T&, const valarray<T>&);

  template<class T> valarray<T> operator-
    (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> operator- (const valarray<T>&, const T&);
  template<class T> valarray<T> operator- (const T&, const valarray<T>&);

  template<class T> valarray<T> operator^
    (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> operator^ (const valarray<T>&, const T&);
  template<class T> valarray<T> operator^ (const T&, const valarray<T>&);

  template<class T> valarray<T> operator&
    (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> operator& (const valarray<T>&, const T&);
  template<class T> valarray<T> operator& (const T&, const valarray<T>&);

  template<class T> valarray<T> operator|
    (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> operator| (const valarray<T>&, const T&);
  template<class T> valarray<T> operator| (const T&, const valarray<T>&);

  template<class T> valarray<T> operator<<
    (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> operator<<(const valarray<T>&, const T&);
  template<class T> valarray<T> operator<<(const T&, const valarray<T>&);

  template<class T> valarray<T> operator>>
    (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> operator>>(const valarray<T>&, const T&);
  template<class T> valarray<T> operator>>(const T&, const valarray<T>&);

  template<class T> valarray<bool> operator&&
    (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<bool> operator&&(const valarray<T>&, const T&);
  template<class T> valarray<bool> operator&&(const T&, const valarray<T>&);

  template<class T> valarray<bool> operator||
    (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<bool> operator||(const valarray<T>&, const T&);
  template<class T> valarray<bool> operator||(const T&, const valarray<T>&);

  template<class T>
    valarray<bool> operator==(const valarray<T>&, const valarray<T>&);
  template<class T> valarray<bool> operator==(const valarray<T>&, const T&);
  template<class T> valarray<bool> operator==(const T&, const valarray<T>&);
  template<class T>
    valarray<bool> operator!=(const valarray<T>&, const valarray<T>&);
  template<class T> valarray<bool> operator!=(const valarray<T>&, const T&);
  template<class T> valarray<bool> operator!=(const T&, const valarray<T>&);

  template<class T>
    valarray<bool> operator< (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<bool> operator< (const valarray<T>&, const T&);
  template<class T> valarray<bool> operator< (const T&, const valarray<T>&);
  template<class T>
    valarray<bool> operator> (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<bool> operator> (const valarray<T>&, const T&);
  template<class T> valarray<bool> operator> (const T&, const valarray<T>&);
  template<class T>
    valarray<bool> operator<=(const valarray<T>&, const valarray<T>&);
  template<class T> valarray<bool> operator<=(const valarray<T>&, const T&);
  template<class T> valarray<bool> operator<=(const T&, const valarray<T>&);
  template<class T>
    valarray<bool> operator>=(const valarray<T>&, const valarray<T>&);
  template<class T> valarray<bool> operator>=(const valarray<T>&, const T&);
  template<class T> valarray<bool> operator>=(const T&, const valarray<T>&);

  template<class T> valarray<T> abs  (const valarray<T>&);
  template<class T> valarray<T> acos (const valarray<T>&);
  template<class T> valarray<T> asin (const valarray<T>&);
  template<class T> valarray<T> atan (const valarray<T>&);

  template<class T> valarray<T> atan2
    (const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> atan2(const valarray<T>&, const T&);
  template<class T> valarray<T> atan2(const T&, const valarray<T>&);

  template<class T> valarray<T> cos  (const valarray<T>&);
  template<class T> valarray<T> cosh (const valarray<T>&);
  template<class T> valarray<T> exp  (const valarray<T>&);
  template<class T> valarray<T> log  (const valarray<T>&);
  template<class T> valarray<T> log10(const valarray<T>&);

  template<class T> valarray<T> pow(const valarray<T>&, const valarray<T>&);
  template<class T> valarray<T> pow(const valarray<T>&, const T&);
  template<class T> valarray<T> pow(const T&, const valarray<T>&);

  template<class T> valarray<T> sin  (const valarray<T>&);
  template<class T> valarray<T> sinh (const valarray<T>&);
  template<class T> valarray<T> sqrt (const valarray<T>&);
  template<class T> valarray<T> tan  (const valarray<T>&);
  template<class T> valarray<T> tanh (const valarray<T>&);
}
\end{codeblock}

\pnum
The header
\tcode{<valarray>}
defines five
class templates
(\tcode{valarray},
\tcode{slice_array},
\tcode{gslice_array},
\tcode{mask_array},
and
\tcode{indirect_array}),
two classes (\tcode{slice}
and
\tcode{gslice}),
and a series of related
function templates
for representing
and manipulating arrays of values.

\pnum
The
\tcode{valarray}
array classes
are defined to be free of certain forms of aliasing, thus allowing
operations on these classes to be optimized.

\pnum
Any function returning a
\tcode{valarray<T>}
is permitted to return an object of another type, provided all the
const member functions of
\tcode{valarray<T>}
are also applicable to this type.
This return type shall not add
more than two levels of template nesting over the most deeply nested
argument type.\footnote{Clause~\ref{limits} recommends a minimum number
of recursively nested template
instantiations.
This requirement thus indirectly suggests a minimum
allowable complexity for valarray expressions.}

\pnum
Implementations introducing such replacement types shall provide
additional functions and operators as follows:
\begin{itemize}
\item
for every function taking a
\tcode{const valarray<T>\&},
identical functions taking the replacement types shall be added;
\item
for every function taking two
\tcode{const valarray<T>\&}
arguments, identical functions taking every combination of
\tcode{const valarray<T>\&}
and replacement types shall be added.
\end{itemize}

\pnum
In particular, an implementation shall allow a
\tcode{valarray<T>}
to be constructed from such replacement types and shall allow assignments
and computed assignments of such types to
\tcode{valarray<T>},
\tcode{slice_array<T>},
\tcode{gslice_array<T>},
\tcode{mask_array<T>}
and
\tcode{indirect_array<T>}
objects.

\pnum
These library functions are permitted to throw a
\tcode{bad_alloc}~(\ref{lib.bad.alloc}) exception if there are not sufficient resources available
to carry out the operation.
Note that the exception is not mandated.

\rSec2[lib.template.valarray]{Class template \tcode{valarray}}

\indexlibrary{\idxcode{valarray}}%
\begin{codeblock}
namespace std {
  template<class T> class valarray {
  public:
    typedef T value_type;

    // \ref{lib.valarray.cons} construct/destroy:
    valarray();
    explicit valarray(size_t);
    valarray(const T&, size_t);
    valarray(const T*, size_t);
    valarray(const valarray&);
    valarray(const slice_array<T>&);
    valarray(const gslice_array<T>&);
    valarray(const mask_array<T>&);
    valarray(const indirect_array<T>&);
   ~valarray();

    // \ref{lib.valarray.assign} assignment:
    valarray<T>& operator=(const valarray<T>&);
    valarray<T>& operator=(const T&);
    valarray<T>& operator=(const slice_array<T>&);
    valarray<T>& operator=(const gslice_array<T>&);
    valarray<T>& operator=(const mask_array<T>&);
    valarray<T>& operator=(const indirect_array<T>&);

    // \ref{lib.valarray.access} element access:
    T                 operator[](size_t) const;
    T&                operator[](size_t);

    // \ref{lib.valarray.sub} subset operations:
    valarray<T>       operator[](slice) const;
    slice_array<T>    operator[](slice);
    valarray<T>       operator[](const gslice&) const;
    gslice_array<T>   operator[](const gslice&);
    valarray<T>       operator[](const valarray<bool>&) const;
    mask_array<T>     operator[](const valarray<bool>&);
    valarray<T>       operator[](const valarray<size_t>&) const;
    indirect_array<T> operator[](const valarray<size_t>&);

    // \ref{lib.valarray.unary} unary operators:
    valarray<T> operator+() const;
    valarray<T> operator-() const;
    valarray<T> operator~() const;
    valarray<bool> operator!() const;

    // \ref{lib.valarray.cassign} computed assignment:
    valarray<T>& operator*= (const T&);
    valarray<T>& operator/= (const T&);
    valarray<T>& operator%= (const T&);
    valarray<T>& operator+= (const T&);
    valarray<T>& operator-= (const T&);
    valarray<T>& operator^= (const T&);
    valarray<T>& operator&= (const T&);
    valarray<T>& operator|= (const T&);
    valarray<T>& operator<<=(const T&);
    valarray<T>& operator>>=(const T&);

    valarray<T>& operator*= (const valarray<T>&);
    valarray<T>& operator/= (const valarray<T>&);
    valarray<T>& operator%= (const valarray<T>&);
    valarray<T>& operator+= (const valarray<T>&);
    valarray<T>& operator-= (const valarray<T>&);
    valarray<T>& operator^= (const valarray<T>&);
    valarray<T>& operator|= (const valarray<T>&);
    valarray<T>& operator&= (const valarray<T>&);
    valarray<T>& operator<<=(const valarray<T>&);
    valarray<T>& operator>>=(const valarray<T>&);

    // \ref{lib.valarray.members} member functions:
    size_t size() const;

    T    sum() const;
    T    min() const;
    T    max() const;

    valarray<T> shift (int) const;
    valarray<T> cshift(int) const;
    valarray<T> apply(T func(T)) const;
    valarray<T> apply(T func(const T&)) const;
    void resize(size_t sz, T c = T());
  };
}
\end{codeblock}

\pnum
The
class template
\tcode{valarray<T>}
is a
one-dimensional smart array, with elements numbered sequentially from zero.
It is a representation of the mathematical concept
of an ordered set of values.
The illusion of higher dimensionality
may be produced by the familiar idiom of computed indices, together
with the powerful subsetting capabilities provided
by the generalized subscript operators.\footnote{The intent is to specify
an array template that has the minimum functionality
necessary to address aliasing ambiguities and the proliferation of
temporaries.
Thus, the
\tcode{valarray}
template is neither a
matrix class nor a field class.
However, it is a very useful building block for designing such classes.}

\pnum
An implementation is permitted to qualify any of the functions declared in
\tcode{<valarray>}
as
\tcode{inline}.

\rSec3[lib.valarray.cons]{\tcode{valarray} constructors}

\indexlibrary{\idxcode{valarray}!\idxcode{valarray}}%
\begin{itemdecl}
valarray();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{valarray<T>},\footnote{For convenience, such objects are referred
to as ``arrays'' throughout the
remainder of~\ref{lib.numarray}.}
which has zero length until it is passed into a library function as a
modifiable lvalue or through a non-constant \tcode{this}
pointer.\footnote{This default constructor is essential,
since arrays of
\tcode{valarray}
are likely to prove useful. There shall also be a way to change the size of
an array after initialization; this is supplied by the semantics of the
\tcode{resize}
member function.}
\end{itemdescr}

\indexlibrary{\idxcode{valarray}!\idxcode{constructor}}%
\begin{itemdecl}
explicit valarray(size_t);
\end{itemdecl}

\begin{itemdescr}
\pnum
The array created by this constructor has a length equal to the value of the argument.
The elements of the array are constructed using the default constructor for the
instantiating type \tcode{T}.
\end{itemdescr}

\indexlibrary{\idxcode{valarray}!\idxcode{constructor}}%
\begin{itemdecl}
valarray(const T&, size_t);
\end{itemdecl}

\begin{itemdescr}
\pnum
The array created by this constructor has a length equal to the second
argument.
The elements of the array are initialized with the value of the first argument.
\end{itemdescr}

\indexlibrary{\idxcode{valarray}!\idxcode{constructor}}%
\begin{itemdecl}
valarray(const T*, size_t);
\end{itemdecl}

\begin{itemdescr}
\pnum
The array created by this constructor has a length equal to the second
argument
\tcode{n}.
The values of the elements of the array are initialized with the
first
\tcode{n}
values pointed to by the first argument.\footnote{This constructor is the
preferred method for converting a C array to a
\tcode{valarray}
object.}
If the value of the second argument is greater than the number of values
pointed to by the first argument, the behavior is undefined.%
\indextext{undefined}
\end{itemdescr}

\indexlibrary{\idxcode{valarray}!\idxcode{constructor}}%
\begin{itemdecl}
valarray(const valarray<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
The array created by this constructor has the same length as the argument
array.
The elements are initialized with the values of the corresponding
elements of the argument array.\footnote{This copy constructor creates
a distinct array rather than an alias.
Implementations in which arrays share storage are permitted, but they
shall implement a copy-on-reference mechanism to ensure that arrays are
conceptually distinct.}
\end{itemdescr}

\indexlibrary{\idxcode{valarray}!\idxcode{constructor}}%
\begin{itemdecl}
valarray(const slice_array<T>&);
valarray(const gslice_array<T>&);
valarray(const mask_array<T>&);
valarray(const indirect_array<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
These conversion constructors convert one of the four reference templates
to a
\tcode{valarray}.
\end{itemdescr}

\indexlibrary{\idxcode{valarray}!destructor}%
\begin{itemdecl}
~valarray();
\end{itemdecl}

\begin{itemdescr}
\pnum
The destructor is applied to every element of
\tcode{*this};
an implementation may return all allocated memory.
\end{itemdescr}

\rSec3[lib.valarray.assign]{\tcode{valarray} assignment}

\indexlibrary{\idxcode{operator=}!\idxcode{valarray}}%
\begin{itemdecl}
valarray<T>& operator=(const valarray<T>& v);
\end{itemdecl}

\begin{itemdescr}
\pnum
Each element of the
\tcode{*this}
array is assigned the value of the corresponding element of the argument
array.
The resulting behavior is undefined if the length of the argument array is not
equal to the length of the \tcode{*this} array.
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{valarray}}%
\begin{itemdecl}
valarray<T>& operator=(const T&);
\end{itemdecl}

\begin{itemdescr}
\pnum
The scalar assignment operator causes each element of the
\tcode{*this}
array to be assigned the value of the argument.
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator=}}%
\begin{itemdecl}
valarray<T>& operator=(const slice_array<T>&);
valarray<T>& operator=(const gslice_array<T>&);
valarray<T>& operator=(const mask_array<T>&);
valarray<T>& operator=(const indirect_array<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
These operators allow the results of a generalized subscripting operation
to be assigned directly to a
\tcode{valarray}.

\pnum
If the value of an element in the left hand side of a valarray assignment
operator depends on the value of another element in that left hand side,
the resulting behavior is undefined.
\end{itemdescr}

\rSec3[lib.valarray.access]{\tcode{valarray} element access}

\indexlibrary{\idxcode{operator[]}!\idxcode{valarray}}%
\begin{itemdecl}
T  operator[](size_t) const;
T& operator[](size_t);
\end{itemdecl}

\begin{itemdescr}
\pnum
When applied to a constant array, the subscript operator
returns the value of the corresponding element of the array.
When applied to a non-constant array, the subscript operator
returns a reference to the corresponding element of the array.

\pnum
Thus, the expression
\tcode{(a[i] = q, a[i]) == q}
evaluates as true for any non-constant
\tcode{valarray<T> a},
any
\tcode{T q},
and for any
\tcode{size_t i}
such that the value of
\tcode{i}
is less than the length of
\tcode{a}.

\pnum
The expression
\tcode{\&a[i+j] == \&a[i] + j}
evaluates as true for all
\tcode{size_t i}
and
\tcode{size_t j}
such that
\tcode{i+j}
is less than the length of the non-constant array
\tcode{a}.

\pnum
Likewise, the expression
\tcode{\&a[i] != \&b[j]}
evaluates as
\tcode{true}
for any two non-constant arrays
\tcode{a}
and
\tcode{b}
and for any
\tcode{size_t i}
and
\tcode{size_t j}
such that
\tcode{i}
is less than the length of
\tcode{a}
and
\tcode{j}
is less than the length of
\tcode{b}.
This property indicates an absence of aliasing and may be used to
advantage by optimizing compilers.\footnote{Compilers may take advantage
of inlining, constant propagation, loop fusion,
tracking of pointers obtained from
\tcode{operator new},
and other
techniques to generate efficient
\tcode{valarray}s.}

\pnum
The reference returned by the subscript operator for a non-constant array is
guaranteed to be valid until the member function
\tcode{resize(size_t, T)}~(\ref{lib.valarray.members}) is called for that array or until the lifetime of
that array ends, whichever happens first.

\pnum
If the subscript operator
is invoked with a
\tcode{size_t}
argument whose value is not
less than the length of the array, the behavior is undefined.%
\indextext{undefined}
\end{itemdescr}

\rSec3[lib.valarray.sub]{\tcode{valarray} subset operations}

\indexlibrary{\idxcode{operator[]}!\idxcode{valarray}}%
\begin{itemdecl}
valarray<T>       operator[](slice) const;
slice_array<T>    operator[](slice);
valarray<T>       operator[](const gslice&) const;
gslice_array<T>   operator[](const gslice&);
valarray<T>       operator[](const valarray<bool>&) const;
mask_array<T>     operator[](const valarray<bool>&);
valarray<T>       operator[](const valarray<size_t>&) const;
indirect_array<T> operator[](const valarray<size_t>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
Each of these operations returns a subset of the array.
The \tcode{const}-qualified versions return this subset as a new \tcode{valarray}.
The non-\tcode{const} versions return a class template object which has reference
semantics to the original array.
\end{itemdescr}

\rSec3[lib.valarray.unary]{\tcode{valarray} unary operators}

\indexlibrary{\idxcode{operator+}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator-}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator\~{}}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator"!}!\idxcode{valarray}}%
\begin{itemdecl}
valarray<T> operator+() const;
valarray<T> operator-() const;
valarray<T> operator~() const;
valarray<bool> operator!() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
Each of these operators may only be instantiated for a type \tcode{T}
to which the indicated operator can be applied and for which the indicated
operator returns a value which is of type \tcode{T} (\tcode{bool} for
\tcode{operator!}) or which may be unambiguously converted to type
\tcode{T} (\tcode{bool} for \tcode{operator!}).

\pnum
Each of these operators returns an array whose length is equal to the length
of the array.
Each element of the returned array is initialized with the result of
applying the indicated operator to the corresponding element of the array.
\end{itemdescr}

\rSec3[lib.valarray.cassign]{\tcode{valarray} computed assignment}

\indexlibrary{\idxcode{operator*=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator/=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator\%=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator+=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator-=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator\^{}=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator\&=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator"|=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator\shl=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator\shr=}!\idxcode{valarray}}%
\begin{itemdecl}
valarray<T>& operator*= (const valarray<T>&);
valarray<T>& operator/= (const valarray<T>&);
valarray<T>& operator%= (const valarray<T>&);
valarray<T>& operator+= (const valarray<T>&);
valarray<T>& operator-= (const valarray<T>&);
valarray<T>& operator^= (const valarray<T>&);
valarray<T>& operator&= (const valarray<T>&);
valarray<T>& operator|= (const valarray<T>&);
valarray<T>& operator<<=(const valarray<T>&);
valarray<T>& operator>>=(const valarray<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
Each of these operators may only be instantiated for a type \tcode{T}
to which the indicated operator can be applied.
Each of these operators
performs the indicated operation on each of its elements and the
corresponding element of the argument array.

\pnum
The array is then returned by reference.

\pnum
If the array and the
argument array do not have the same length, the behavior is undefined.%
\indextext{undefined}
The appearance of an array on the left hand side of a computed assignment
does \tcode{not} invalidate references or pointers.

\pnum
If the value of an element in the left hand side of a valarray computed
assignment operator depends on the value of another element in that left
hand side, the resulting behavior is undefined.
\end{itemdescr}

\indexlibrary{\idxcode{operator*=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator*=}}%
\indexlibrary{\idxcode{operator/=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator/=}}%
\indexlibrary{\idxcode{operator\%=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator\%=}}%
\indexlibrary{\idxcode{operator+=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator+=}}%
\indexlibrary{\idxcode{operator-=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator-=}}%
\indexlibrary{\idxcode{operator\^{}=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator\^{}=}}%
\indexlibrary{\idxcode{operator\&=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator\&=}}%
\indexlibrary{\idxcode{operator"|=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator"|=}}%
\indexlibrary{\idxcode{operator\shl=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator\shl=}}%
\indexlibrary{\idxcode{operator\shr=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator\shr=}}%
\begin{itemdecl}
valarray<T>& operator*= (const T&);
valarray<T>& operator/= (const T&);
valarray<T>& operator%= (const T&);
valarray<T>& operator+= (const T&);
valarray<T>& operator-= (const T&);
valarray<T>& operator^= (const T&);
valarray<T>& operator&= (const T&);
valarray<T>& operator|= (const T&);
valarray<T>& operator<<=(const T&);
valarray<T>& operator>>=(const T&);
\end{itemdecl}

\begin{itemdescr}
\pnum
Each of these operators may only be instantiated for a type \tcode{T}
to which the indicated operator can be applied.

\pnum
Each of these operators applies the indicated operation to each element
of the array and the non-array argument.

\pnum
The array is then returned by reference.

\pnum
The appearance of an array on the left hand side of a computed assignment
does
\textit{not}
invalidate references or pointers to the elements of the array.
\end{itemdescr}

\rSec3[lib.valarray.members]{\tcode{valarray} member functions}

\indexlibrary{\idxcode{length}!\idxcode{valarray}}%
\begin{itemdecl}
size_t size() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
This function returns the number of elements in the array.
\end{itemdescr}

\indexlibrary{\idxcode{sum}!\idxcode{valarray}}%
\begin{itemdecl}
T sum() const;
\end{itemdecl}

\begin{itemdescr}
This function may only be instantiated for a type \tcode{T} to which
\tcode{operator+=}
can be applied.
This function returns the sum of all the elements of the array.

\pnum
If the array has length 0, the behavior is undefined.%
\indextext{undefined}
If the array has length 1,
\tcode{sum()}
returns the value of element 0.
Otherwise, the returned value is calculated by applying
\tcode{operator+=}
to a copy of an element of the array and
all other elements of the array in an unspecified order.%
\indextext{unspecified behavior}
\end{itemdescr}

\indexlibrary{\idxcode{min}!\idxcode{valarray}}%
\begin{itemdecl}
T min() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
This function returns the minimum value contained in
\tcode{*this}.
The value returned for an array of length 0 is undefined.
For an array
of length 1, the value of element 0 is returned.
For all other array
lengths, the determination is made using
\tcode{operator<}.
\end{itemdescr}

\indexlibrary{\idxcode{max}!\idxcode{valarray}}%
\begin{itemdecl}
T max() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
This function returns the maximum value contained in
\tcode{*this}.
The value returned for an array of length 0 is undefined.
For an array
of length 1, the value of element 0 is returned.
For all other array
lengths, the determination is made using
\tcode{operator<}.
\end{itemdescr}

\indexlibrary{\idxcode{shift}!\idxcode{valarray}}%
\begin{itemdecl}
valarray<T> shift(int n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
This function returns an object of class
\tcode{valarray<T>}
of length
\tcode{size()},
each of whose elements
\textit{I}
is
\tcode{(*this)[I+n]}
if
\tcode{I+n}
is non-negative and less than
\tcode{size()},
otherwise
\tcode{T()}.
Thus if element zero is taken as the leftmost element,
a positive value of \tcode{n} shifts the elements left \tcode{n}
places, with zero fill.

\pnum
\enterexample
If the argument has the value -2,
the first two elements of the result will be constructed using the default
constructor; the third element of the result will be assigned the value
of the first element of the argument; etc.
\exitexampleb
\end{itemdescr}

\indexlibrary{\idxcode{cshift}!\idxcode{valarray}}%
\begin{itemdecl}
valarray<T> cshift(int n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
This function returns an object of class
\tcode{valarray<T>}
of length
\tcode{size()},
each of whose elements \tcode{I} is \tcode{(*this)[(I+n)\%size()]}.
Thus, if element zero is taken as the leftmost element, a positive value of
\tcode{n} shifts the elements circularly left \tcode{n} places.
\end{itemdescr}

\indexlibrary{\idxcode{apply}!\idxcode{valarray}}%
\begin{itemdecl}
valarray<T> apply(T func(T)) const;
valarray<T> apply(T func(const T&)) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
These functions return an array whose length is equal to the array.
Each element of the returned array is assigned
the value returned by applying the argument function to the
corresponding element of the array.

\indexlibrary{\idxcode{resize}!\idxcode{valarray}}%
\begin{itemdecl}
void resize(size_t sz, T c = T());
\end{itemdecl}

\pnum
This member function changes the length of the
\tcode{*this}
array to
\tcode{sz}
and then assigns to each element the value of the second argument.
Resizing invalidates all pointers and references to elements in the array.
\end{itemdescr}

\rSec2[lib.valarray.nonmembers]{\tcode{valarray} non-member operations}

\rSec3[lib.valarray.binary]{\tcode{valarray} binary operators}

\indexlibrary{\idxcode{operator*}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator/}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator\%}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator+}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator-}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator\^{}}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator\&}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator"|}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator\shl}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator\shr}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator\&\&}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator"|"|}!\idxcode{valarray}}%
\begin{itemdecl}
template<class T> valarray<T> operator*
    (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator/
    (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator%
    (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator+
    (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator-
    (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator^
    (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator&
    (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator|
    (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator<<
    (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator>>
    (const valarray<T>&, const valarray<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
Each of these operators may only be instantiated for a type \tcode{T}
to which the indicated operator can be applied and for which the indicated
operator returns a value which is of type \tcode{T} or which
can be unambiguously converted to type \tcode{T}.

\pnum
Each of these operators returns an array whose length is equal to the
lengths of the argument arrays.
Each element of the returned array is
initialized with the result of applying the indicated operator to the
corresponding elements of the argument arrays.

\pnum
If the argument arrays do not have the same length, the behavior is undefined.%
\indextext{undefined}
\end{itemdescr}

\indexlibrary{\idxcode{operator*}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator*}}%
\indexlibrary{\idxcode{operator/}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator/}}%
\indexlibrary{\idxcode{operator\%}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator\%}}%
\indexlibrary{\idxcode{operator+}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator+}}%
\indexlibrary{\idxcode{operator=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator=}}%
\indexlibrary{\idxcode{operator\^{}}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator\^{}}}%
\indexlibrary{\idxcode{operator\&}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator\&}}%
\indexlibrary{\idxcode{operator"|}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator"|}}%
\indexlibrary{\idxcode{operator\shl}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator\shl}}%
\indexlibrary{\idxcode{operator\shr}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator\shr}}%
\begin{itemdecl}
template<class T> valarray<T> operator* (const valarray<T>&, const T&);
template<class T> valarray<T> operator* (const T&, const valarray<T>&);
template<class T> valarray<T> operator/ (const valarray<T>&, const T&);
template<class T> valarray<T> operator/ (const T&, const valarray<T>&);
template<class T> valarray<T> operator% (const valarray<T>&, const T&);
template<class T> valarray<T> operator% (const T&, const valarray<T>&);
template<class T> valarray<T> operator+ (const valarray<T>&, const T&);
template<class T> valarray<T> operator+ (const T&, const valarray<T>&);
template<class T> valarray<T> operator- (const valarray<T>&, const T&);
template<class T> valarray<T> operator- (const T&, const valarray<T>&);
template<class T> valarray<T> operator^ (const valarray<T>&, const T&);
template<class T> valarray<T> operator^ (const T&, const valarray<T>&);
template<class T> valarray<T> operator& (const valarray<T>&, const T&);
template<class T> valarray<T> operator& (const T&, const valarray<T>&);
template<class T> valarray<T> operator| (const valarray<T>&, const T&);
template<class T> valarray<T> operator| (const T&, const valarray<T>&);
template<class T> valarray<T> operator<<(const valarray<T>&, const T&);
template<class T> valarray<T> operator<<(const T&, const valarray<T>&);
template<class T> valarray<T> operator>>(const valarray<T>&, const T&);
template<class T> valarray<T> operator>>(const T&, const valarray<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
Each of these operators may only be instantiated for a type \tcode{T}
to which the indicated operator can be applied and for which
the indicated operator returns a value which is of type \tcode{T}
or which can be unambiguously converted to type \tcode{T}.

\pnum
Each of these operators returns an array whose length is equal to the
length of the array argument.
Each element of the returned array is
initialized with the result of applying the indicated operator to the
corresponding element of the array argument and the non-array argument.
\end{itemdescr}

\rSec3[lib.valarray.comparison]{\tcode{valarray} logical operators}

\indexlibrary{\idxcode{operator==}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator"!=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator<}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator>}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator<=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator>=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator\&\&}!\idxcode{valarray}}%
\indexlibrary{\idxcode{operator"|"|}!\idxcode{valarray}}%
\begin{itemdecl}
template<class T> valarray<bool> operator==
    (const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator!=
    (const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator<
    (const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator>
    (const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator<=
    (const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator>=
    (const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator&&
    (const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator||
    (const valarray<T>&, const valarray<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
Each of these operators may only be instantiated for a type \tcode{T}
to which the indicated operator can be applied and for which
the indicated operator returns a value which is of type \tcode{bool}
or which can be unambiguously converted to type \tcode{bool}.

\pnum
Each of these operators returns a \tcode{bool} array whose length
is equal to the length of the array arguments.
Each element of the returned
array is initialized with the result of applying the indicated
operator to the corresponding elements of the argument arrays.

\pnum
If the two array arguments do not have the same length,
the behavior is undefined.%
\indextext{undefined}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator==}}%
\indexlibrary{\idxcode{operator"!=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator"!=}}%
\indexlibrary{\idxcode{operator<}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator<}}%
\indexlibrary{\idxcode{operator<=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator<=}}%
\indexlibrary{\idxcode{operator>}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator>}}%
\indexlibrary{\idxcode{operator>=}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator>=}}%
\indexlibrary{\idxcode{operator\&\&}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator\&\&}}%
\indexlibrary{\idxcode{operator"|"|}!\idxcode{valarray}}%
\indexlibrary{\idxcode{valarray}!\idxcode{operator"|"|}}%
\begin{itemdecl}
template<class T> valarray<bool> operator==(const valarray<T>&, const T&);
template<class T> valarray<bool> operator==(const T&, const valarray<T>&);
template<class T> valarray<bool> operator!=(const valarray<T>&, const T&);
template<class T> valarray<bool> operator!=(const T&, const valarray<T>&);
template<class T> valarray<bool> operator< (const valarray<T>&, const T&);
template<class T> valarray<bool> operator< (const T&, const valarray<T>&);
template<class T> valarray<bool> operator> (const valarray<T>&, const T&);
template<class T> valarray<bool> operator> (const T&, const valarray<T>&);
template<class T> valarray<bool> operator<=(const valarray<T>&, const T&);
template<class T> valarray<bool> operator<=(const T&, const valarray<T>&);
template<class T> valarray<bool> operator>=(const valarray<T>&, const T&);
template<class T> valarray<bool> operator>=(const T&, const valarray<T>&);
template<class T> valarray<bool> operator&&(const valarray<T>&, const T&);
template<class T> valarray<bool> operator&&(const T&, const valarray<T>&);
template<class T> valarray<bool> operator||(const valarray<T>&, const T&);
template<class T> valarray<bool> operator||(const T&, const valarray<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
Each of these operators may only be instantiated for a type \tcode{T}
to which the indicated operator can be applied and for which
the indicated operator returns a value which is of type \tcode{bool}
or which can be unambiguously converted to type \tcode{bool}.

\pnum
Each of these operators returns a \tcode{bool} array whose
length is equal to the length of the array argument.
Each element
of the returned array is initialized with the result of applying the
indicated operator to the corresponding element of the array and the non-array argument.
\end{itemdescr}

\rSec3[lib.valarray.transcend]{\tcode{valarray} transcendentals}

\indexlibrary{\idxcode{abs}}%
\indexlibrary{\idxcode{acos}}%
\indexlibrary{\idxcode{asin}}%
\indexlibrary{\idxcode{atan}}%
\indexlibrary{\idxcode{atan2}}%
\indexlibrary{\idxcode{cos}}%
\indexlibrary{\idxcode{cosh}}%
\indexlibrary{\idxcode{exp}}%
\indexlibrary{\idxcode{log}}%
\indexlibrary{\idxcode{log10}}%
\indexlibrary{\idxcode{pow}}%
\indexlibrary{\idxcode{sin}}%
\indexlibrary{\idxcode{sinh}}%
\indexlibrary{\idxcode{sqrt}}%
\indexlibrary{\idxcode{tan}}%
\indexlibrary{\idxcode{tanh}}%
\begin{itemdecl}
template<class T> valarray<T> abs  (const valarray<T>&);
template<class T> valarray<T> acos (const valarray<T>&);
template<class T> valarray<T> asin (const valarray<T>&);
template<class T> valarray<T> atan (const valarray<T>&);
template<class T> valarray<T> atan2
    (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> atan2(const valarray<T>&, const T&);
template<class T> valarray<T> atan2(const T&, const valarray<T>&);
template<class T> valarray<T> cos  (const valarray<T>&);
template<class T> valarray<T> cosh (const valarray<T>&);
template<class T> valarray<T> exp  (const valarray<T>&);
template<class T> valarray<T> log  (const valarray<T>&);
template<class T> valarray<T> log10(const valarray<T>&);
template<class T> valarray<T> pow
    (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> pow  (const valarray<T>&, const T&);
template<class T> valarray<T> pow  (const T&, const valarray<T>&);
template<class T> valarray<T> sin  (const valarray<T>&);
template<class T> valarray<T> sinh (const valarray<T>&);
template<class T> valarray<T> sqrt (const valarray<T>&);
template<class T> valarray<T> tan  (const valarray<T>&);
template<class T> valarray<T> tanh (const valarray<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
Each of these functions may only be instantiated for a type \tcode{T}
to which a unique function with the indicated name can be applied.
This function shall return a value which is of type \tcode{T}
or which can be unambiguously converted to type \tcode{T}.
\end{itemdescr}

\rSec2[lib.class.slice]{Class \tcode{slice}}

\indexlibrary{\idxcode{slice}}%
\begin{codeblock}
namespace std {
  class slice {
  public:
    slice();
    slice(size_t, size_t, size_t);

    size_t start() const;
    size_t size() const;
    size_t stride() const;
  };
}
\end{codeblock}

\pnum
The
\tcode{slice}
class represents a BLAS-like slice from an array.
Such a slice is specified by a starting index, a length, and a
stride.\footnote{BLAS stands for
\textit{Basic Linear Algebra Subprograms.}
\Cpp programs may instantiate this class.
See, for example,
Dongarra, Du Croz, Duff, and Hammerling:
\textit{A set of Level 3 Basic Linear Algebra Subprograms};
Technical Report MCS-P1-0888,
Argonne National Laboratory (USA),
Mathematics and Computer Science Division,
August, 1988.}

\rSec3[lib.cons.slice]{\tcode{slice} constructors}

\indexlibrary{\idxcode{slice}!\idxcode{slice}}%
\begin{itemdecl}
slice();
slice(size_t start, size_t length, size_t stride);
slice(const slice&);
\end{itemdecl}

\begin{itemdescr}
\pnum
The default constructor for \tcode{slice} creates a \tcode{slice} which
specifies no elements.
A default constructor is provided only to permit the declaration of arrays of slices.
The constructor with arguments for a slice takes a start, length, and stride
parameter.

\pnum
\enterexample
\tcode{slice(3, 8, 2)}
constructs a slice which selects elements 3, 5, 7, ... 17 from an array.
\exitexampleb
\end{itemdescr}

\rSec3[lib.slice.access]{\tcode{slice} access functions}

\indexlibrary{\idxcode{start}!\idxcode{slice}}%
\indexlibrary{\idxcode{size}!\idxcode{slice}}%
\indexlibrary{\idxcode{stride}!\idxcode{slice}}%
\begin{itemdecl}
size_t start() const;
size_t size() const;
size_t stride() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
These functions return the start, length, or stride specified
by a \tcode{slice} object.
\end{itemdescr}

\rSec2[lib.template.slice.array]{Class template \tcode{slice_array}}

\indexlibrary{\idxcode{slice_array}}%
\begin{codeblock}
namespace std {
  template <class T> class slice_array {
  public:
    typedef T value_type;

    void operator=  (const valarray<T>&) const;
    void operator*= (const valarray<T>&) const;
    void operator/= (const valarray<T>&) const;
    void operator%= (const valarray<T>&) const;
    void operator+= (const valarray<T>&) const;
    void operator-= (const valarray<T>&) const;
    void operator^= (const valarray<T>&) const;
    void operator&= (const valarray<T>&) const;
    void operator|= (const valarray<T>&) const;
    void operator<<=(const valarray<T>&) const;
    void operator>>=(const valarray<T>&) const;

    void operator=(const T&);
   ~slice_array();
  private:
    slice_array();
    slice_array(const slice_array&);
    slice_array& operator=(const slice_array&);
  };
}
\end{codeblock}

\pnum
The
\tcode{slice_array}
template is a helper template used by the
\tcode{slice}
subscript operator

\begin{codeblock}
slice_array<T> valarray<T>::operator[](slice);
\end{codeblock}

It has reference semantics to a subset of an array specified by a
\tcode{slice}
object.

\pnum
\enterexample
The expression
\tcode{a[slice(1, 5, 3)] = b;}
has the effect of assigning the elements of
\tcode{b}
to a slice of the elements in
\tcode{a}.
For the slice shown, the elements
selected from
\tcode{a}
are 1, 4, ..., 13.
\exitexampleb

\pnum
\enternote
\Cpp programs may not instantiate \tcode{slice_array}, since all its
constructors are private. It is intented purely as a helper class and
should be transparent to the user.
\exitnoteb

\rSec3[lib.cons.slice.arr]{\tcode{slice_array} constructors}

\indexlibrary{\idxcode{slice_array}!\idxcode{slice_array}}%
\begin{itemdecl}
slice_array();
slice_array(const slice_array&);
\end{itemdecl}

\begin{itemdescr}
\pnum
The \tcode{slice_array} template has no public constructors. These
constructors are declared to be private. These constructors need
not be defined.
\end{itemdescr}

\rSec3[lib.slice.arr.assign]{\tcode{slice_array} assignment}

\indexlibrary{\idxcode{operator=}!\idxcode{slice_array}}%
\begin{itemdecl}
void         operator=(const valarray<T>&) const;
slice_array& operator=(const slice_array&);
\end{itemdecl}

\begin{itemdescr}
\pnum
The second of these two assignment operators is declared private and
need not be defined. The first has reference semantics,
assigning the values of the argument array elements to selected
elements of the
\tcode{valarray<T>}
object to which the
\tcode{slice_array}
object refers.
\end{itemdescr}

\rSec3[lib.slice.arr.comp.assign]{\tcode{slice_array} computed assignment}

\indexlibrary{\idxcode{operator*=}!\idxcode{slice_array}}%
\indexlibrary{\idxcode{operator/=}!\idxcode{slice_array}}%
\indexlibrary{\idxcode{operator\%=}!\idxcode{slice_array}}%
\indexlibrary{\idxcode{operator+=}!\idxcode{slice_array}}%
\indexlibrary{\idxcode{operator-=}!\idxcode{slice_array}}%
\indexlibrary{\idxcode{operator\^{}=}!\idxcode{slice_array}}%
\indexlibrary{\idxcode{operator\&=}!\idxcode{slice_array}}%
\indexlibrary{\idxcode{operator"|=}!\idxcode{slice_array}}%
\indexlibrary{\idxcode{operator\shl=}!\idxcode{slice_array}}%
\indexlibrary{\idxcode{operator\shr=}!\idxcode{slice_array}}%
\begin{itemdecl}
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
These computed assignments have reference semantics, applying the
indicated operation to the elements of the argument array
and selected elements of the
\tcode{valarray<T>}
object to which the
\tcode{slice_array}
object refers.
\end{itemdescr}

\rSec3[lib.slice.arr.fill]{\tcode{slice_array} fill function}

\indexlibrary{\idxcode{fill}!\idxcode{slice_array}}%
\begin{itemdecl}
void operator=(const T&);
\end{itemdecl}

\begin{itemdescr}
\pnum
This function has reference semantics, assigning the value of its argument
to the elements of the
\tcode{valarray<T>}
object to which the
\tcode{slice_array}
object refers.
\end{itemdescr}

\rSec2[lib.class.gslice]{The \tcode{gslice} class}

\indexlibrary{\idxcode{gslice}}%
\begin{codeblock}
namespace std {
  class gslice {
  public:
    gslice();
    gslice(size_t s, const valarray<size_t>& l, const valarray<size_t>& d);

    size_t           start() const;
    valarray<size_t> size() const;
    valarray<size_t> stride() const;
  };
}
\end{codeblock}

\pnum
This class represents a generalized slice out of an array.
A
\tcode{gslice}
is defined by a starting offset ($s$),
a set of lengths ($l_j$),
and a set of strides ($d_j$).
The number of lengths shall equal the number of strides.

\pnum
A
\tcode{gslice}
represents a mapping from a set of indices ($i_j$),
equal in number to the number of strides, to a single index $k$.
It is useful for building multidimensional array classes using
the
\tcode{valarray}
template, which is one-dimensional.
The set of one-dimensional index values specified by a
\tcode{gslice}
are $$k = s + \sum_ji_jd_j$$
% \$k = s + sum from j \{ i sub j d sub j \}\$
where the multidimensional indices $i_j$ range in value from
0 to $l_{ij} - 1$.

\pnum
\enterexample
The
\tcode{gslice}
specification
\begin{codeblock}
start  = 3
length = {2, 4, 3}
stride = {19, 4, 1}
\end{codeblock}
yields the sequence of one-dimensional indices

$$k = 3 + (0,1) \times 19 + (0,1,2,3) \times 4 + (0,1,2) \times 1$$

which are ordered as shown in the following table:

\begin{tabbing}
\hspace{.5in}\=\hspace{.4in}\=\kill%
\>$(i_0,\quad i_1,\quad i_2,\quad k)\quad =$\\
\>\>$(0,\quad 0,\quad 0,\quad \ 3)$,    \\
\>\>$(0,\quad 0,\quad 1,\quad \ 4)$,    \\
\>\>$(0,\quad 0,\quad 2,\quad \ 5)$,    \\
\>\>$(0,\quad 1,\quad 0,\quad \ 7)$,    \\
\>\>$(0,\quad 1,\quad 1,\quad \ 8)$,    \\
\>\>$(0,\quad 1,\quad 2,\quad \ 9)$,    \\
\>\>$(0,\quad 2,\quad 0,\quad 11)$, \\
\>\>$(0,\quad 2,\quad 1,\quad 12)$, \\
\>\>$(0,\quad 2,\quad 2,\quad 13)$, \\
\>\>$(0,\quad 3,\quad 0,\quad 15)$, \\
\>\>$(0,\quad 3,\quad 1,\quad 16)$, \\
\>\>$(0,\quad 3,\quad 2,\quad 17)$, \\
\>\>$(1,\quad 0,\quad 0,\quad 22)$, \\
\>\>$(1,\quad 0,\quad 1,\quad 23)$, \\
\>\>$\ldots$      \\
\>\>$(1,\quad 3,\quad 2,\quad 36)$
\end{tabbing}

That is, the highest-ordered index turns fastest.
\exitexampleb

\pnum
It is possible to have degenerate generalized slices in which an address
is repeated.

\pnum
\enterexample
If the stride parameters in the previous
example are changed to \{1, 1, 1\}, the first few elements of the
resulting sequence of indices will be

\begin{tabbing}
\hspace{.9in}\=\kill%
\>$(0,\quad 0,\quad 0,\quad \ 3)$,  \\
\>$(0,\quad 0,\quad 1,\quad \ 4)$,  \\
\>$(0,\quad 0,\quad 2,\quad \ 5)$,  \\
\>$(0,\quad 1,\quad 0,\quad \ 4)$,  \\
\>$(0,\quad 1,\quad 1,\quad \ 5)$,  \\
\>$(0,\quad 1,\quad 2,\quad \ 6)$,  \\
\>$\ldots$
\end{tabbing}
\exitexampleb

\pnum
If a degenerate slice is used as the argument to the
non-\tcode{const}
version of
\tcode{operator[](const gslice\&)},
the resulting behavior is undefined.
\indextext{undefined}%

\rSec3[lib.gslice.cons]{\tcode{gslice} constructors}

\indexlibrary{\idxcode{gslice}!constructor}%
\begin{itemdecl}
gslice();
gslice(size_t start, const valarray<size_t>& lengths,
                           const valarray<size_t>& strides);
gslice(const gslice&);
\end{itemdecl}

\begin{itemdescr}
\pnum
The default constructor creates a \tcode{gslice} which specifies no elements.
The constructor with arguments builds a
\tcode{gslice}
based on a specification of start, lengths, and strides, as explained
in the previous section.
\end{itemdescr}

\rSec3[lib.gslice.access]{\tcode{gslice} access functions}

\indexlibrary{\idxcode{start}!\idxcode{gslice}}%
\indexlibrary{\idxcode{size}!\idxcode{gslice}}%
\indexlibrary{\idxcode{stride}!\idxcode{gslice}}%
\begin{itemdecl}
size_t           start()  const;
valarray<size_t> size() const;
valarray<size_t> stride() const;
\end{itemdecl}

\begin{itemdescr}
These access functions return the representation of the
start, lengths, or strides specified for the \tcode{gslice}.
\end{itemdescr}

\rSec2[lib.template.gslice.array]{Class template \tcode{gslice_array}}

\indexlibrary{\idxcode{gslice_array}}%
\begin{codeblock}
namespace std {
  template <class T> class gslice_array {
  public:
    typedef T value_type;

    void operator=  (const valarray<T>&) const;
    void operator*= (const valarray<T>&) const;
    void operator/= (const valarray<T>&) const;
    void operator%= (const valarray<T>&) const;
    void operator+= (const valarray<T>&) const;
    void operator-= (const valarray<T>&) const;
    void operator^= (const valarray<T>&) const;
    void operator&= (const valarray<T>&) const;
    void operator|= (const valarray<T>&) const;
    void operator<<=(const valarray<T>&) const;
    void operator>>=(const valarray<T>&) const;

    void operator=(const T&);
   ~gslice_array();
  private:
    gslice_array();
    gslice_array(const gslice_array&);
    gslice_array& operator=(const gslice_array&);
  };
}
\end{codeblock}

\pnum
This template is a helper template used by the
\tcode{slice}
subscript operator

\indexlibrary{\idxcode{gslice_array}}%
\indexlibrary{\idxcode{valarray}}%
\begin{itemdecl}
gslice_array<T> valarray<T>::operator[](const gslice&);
\end{itemdecl}

\begin{itemdescr}
It has reference semantics to a subset of an array specified by a
\tcode{gslice}
object.

\pnum
Thus, the expression
\tcode{a[gslice(1, length, stride)] = b}
has the effect of assigning the elements of
\tcode{b}
to a
generalized slice of the elements in
\tcode{a}.

\pnum
\enternote
\Cpp programs may not instantiate \tcode{gslice_array}, since all its
constructors are private. It is intended purely as a helper class and should
be transparent to the user.
\exitnoteb
\end{itemdescr}

\rSec3[lib.gslice.array.cons]{\tcode{gslice_array} constructors}

\indexlibrary{\idxcode{gslice_array}!\idxcode{gslice_array}}%
\begin{itemdecl}
gslice_array();
gslice_array(const gslice_array&);
\end{itemdecl}

\begin{itemdescr}
\pnum
The \tcode{gslice_array} template has no public constructors. It declares
the above constructors to be private. These constructors need not be defined.
\end{itemdescr}

\rSec3[lib.gslice.array.assign]{\tcode{gslice_array} assignment}

\indexlibrary{\idxcode{operator=}!\idxcode{gslice_array}}%
\begin{itemdecl}
void operator=(const valarray<T>&) const;
gslice_array& operator=(const gslice_array&);
\end{itemdecl}

\begin{itemdescr}
\pnum
The second of these two assignment operators is declared private and
need not be defined. The first has reference semantics, assigning the values
of the argument array elements to selected elements of the
\tcode{valarray<T>}
object to which the
\tcode{gslice_array}
refers.
\end{itemdescr}

\rSec3[lib.gslice.array.comp.assign]{\tcode{gslice_array} computed assignment}

\indexlibrary{\idxcode{operator*=}!\idxcode{gslice_array}}%
\indexlibrary{\idxcode{operator/=}!\idxcode{gslice_array}}%
\indexlibrary{\idxcode{operator\%=}!\idxcode{gslice_array}}%
\indexlibrary{\idxcode{operator+=}!\idxcode{gslice_array}}%
\indexlibrary{\idxcode{operator-=}!\idxcode{gslice_array}}%
\indexlibrary{\idxcode{operator\^{}=}!\idxcode{gslice_array}}%
\indexlibrary{\idxcode{operator\&=}!\idxcode{gslice_array}}%
\indexlibrary{\idxcode{operator"|=}!\idxcode{gslice_array}}%
\indexlibrary{\idxcode{operator\shl=}!\idxcode{gslice_array}}%
\indexlibrary{\idxcode{operator\shr=}!\idxcode{gslice_array}}%
\begin{itemdecl}
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
These computed assignments have reference semantics, applying the
indicated operation to the elements of the argument array and selected
elements of the
\tcode{valarray<T>}
object to which the
\tcode{gslice_array}
object refers.
\end{itemdescr}

\rSec3[lib.gslice.array.fill]{\tcode{gslice_array} fill function}

\indexlibrary{\idxcode{fill}!\idxcode{gslice_array}}%
\begin{itemdecl}
void operator=(const T&);
\end{itemdecl}

\begin{itemdescr}
\pnum
This function has reference semantics, assigning the value of its argument
to the elements of the
\tcode{valarray<T>}
object to which the
\tcode{gslice_array}
object refers.
\end{itemdescr}

\rSec2[lib.template.mask.array]{Class template \tcode{mask_array}}

\indexlibrary{\idxcode{mask_array}}%
\begin{codeblock}
namespace std {
  template <class T> class mask_array {
  public:
    typedef T value_type;

    void operator=  (const valarray<T>&) const;
    void operator*= (const valarray<T>&) const;
    void operator/= (const valarray<T>&) const;
    void operator%= (const valarray<T>&) const;
    void operator+= (const valarray<T>&) const;
    void operator-= (const valarray<T>&) const;
    void operator^= (const valarray<T>&) const;
    void operator&= (const valarray<T>&) const;
    void operator|= (const valarray<T>&) const;
    void operator<<=(const valarray<T>&) const;
    void operator>>=(const valarray<T>&) const;

    void operator=(const T&);
   ~mask_array();
  private:
    mask_array();
    mask_array(const mask_array&);
    mask_array& operator=(const mask_array&);
  };
}
\end{codeblock}

\pnum
This template is a helper template used by the mask subscript operator:

\indexlibrary{\idxcode{operator[]}!\idxcode{mask_array}}%
\indexlibrary{\idxcode{mask_array}!\idxcode{operator[]}}%
\begin{itemdecl}
mask_array<T> valarray<T>::operator[](const valarray<bool>&).
\end{itemdecl}

\begin{itemdescr}
It has reference semantics to a subset of an array specified by a boolean mask.
Thus, the expression
\tcode{a[mask] = b;}
has the effect of assigning the elements of
\tcode{b}
to the masked
elements in
\tcode{a}
(those for which the corresponding element
in
\tcode{mask}
is
\tcode{true}.)

\pnum
\enternote
\Cpp programs may not declare instances of \tcode{mask_array}, since all its
constructors are private. It is intended purely as a helper class, and should
be transparent to the user.
\exitnoteb
\end{itemdescr}

\rSec3[lib.mask.array.cons]{\tcode{mask_array} constructors}

\indexlibrary{\idxcode{mask_array}!\idxcode{mask_array}}%
\begin{itemdecl}
mask_array();
mask_array(const mask_array&);
\end{itemdecl}

\begin{itemdescr}
\pnum
The \tcode{mask_array} template has no public constructors. It declares the
above constructors to be private. These constructors need not be defined.
\end{itemdescr}

\rSec3[lib.mask.array.assign]{\tcode{mask_array} assignment}

\indexlibrary{\idxcode{operator=}!\idxcode{mask_array}}%
\begin{itemdecl}
void operator=(const valarray<T>&) const;
mask_array& operator=(const mask_array&);
\end{itemdecl}

\begin{itemdescr}
\pnum
The second of these two assignment operators is declared private and need
not be defined. The first has reference semantics, assigning the values
of the argument array elements to selected elements of the
\tcode{valarray<T>}
object to which it refers.
\end{itemdescr}

\rSec3[lib.mask.array.comp.assign]{\tcode{mask_array} computed assignment}

\indexlibrary{\idxcode{operator*=}!\idxcode{mask_array}}%
\indexlibrary{\idxcode{operator/=}!\idxcode{mask_array}}%
\indexlibrary{\idxcode{operator\%=}!\idxcode{mask_array}}%
\indexlibrary{\idxcode{operator+=}!\idxcode{mask_array}}%
\indexlibrary{\idxcode{operator-=}!\idxcode{mask_array}}%
\indexlibrary{\idxcode{operator\^{}=}!\idxcode{mask_array}}%
\indexlibrary{\idxcode{operator\&=}!\idxcode{mask_array}}%
\indexlibrary{\idxcode{operator"|=}!\idxcode{mask_array}}%
\indexlibrary{\idxcode{operator\shl=}!\idxcode{mask_array}}%
\indexlibrary{\idxcode{operator\shr=}!\idxcode{mask_array}}%
\begin{itemdecl}
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
These computed assignments have reference semantics, applying the
indicated operation to the elements of the argument array and selected elements
of the
\tcode{valarray<T>}
object to which the mask object refers.
\end{itemdescr}

\rSec3[lib.mask.array.fill]{\tcode{mask_array} fill function}

\indexlibrary{\idxcode{fill}!\idxcode{mask_array}}%
\begin{itemdecl}
void operator=(const T&);
\end{itemdecl}

\begin{itemdescr}
This function has reference semantics, assigning the value of its
argument to the elements of the
\tcode{valarray<T>}
object to which the
\tcode{mask_array}
object refers.
\end{itemdescr}

\rSec2[lib.template.indirect.array]{Class template \tcode{indirect_array}}

\indexlibrary{\idxcode{indirect_array}}%
\begin{codeblock}
namespace std {
  template <class T> class indirect_array {
  public:
    typedef T value_type;

    void operator=  (const valarray<T>&) const;
    void operator*= (const valarray<T>&) const;
    void operator/= (const valarray<T>&) const;
    void operator%= (const valarray<T>&) const;
    void operator+= (const valarray<T>&) const;
    void operator-= (const valarray<T>&) const;
    void operator^= (const valarray<T>&) const;
    void operator&= (const valarray<T>&) const;
    void operator|= (const valarray<T>&) const;
    void operator<<=(const valarray<T>&) const;
    void operator>>=(const valarray<T>&) const;

    void operator=(const T&);
   ~indirect_array();
  private:
    indirect_array();
    indirect_array(const indirect_array&);
    indirect_array& operator=(const indirect_array&);
  };
}
\end{codeblock}

\pnum
This template is a helper template used by the indirect subscript operator

\indexlibrary{\idxcode{operator[]}!\idxcode{indirect_array}}%
\indexlibrary{\idxcode{indirect_array}!\idxcode{operator[]}}%
\begin{itemdecl}
indirect_array<T> valarray<T>::operator[](const valarray<size_t>&).
\end{itemdecl}

\begin{itemdescr}
It has reference semantics to a subset of an array specified by an
\tcode{indirect_array}.
Thus the expression
\tcode{a[\brk{}indirect] = b;}
has the effect of assigning the elements of
\tcode{b}
to the elements in
\tcode{a}
whose indices appear in
\tcode{indirect}.

\pnum
\enternote
\Cpp programs may not declare instances of \tcode{indirect_array}, since all
its constructors are private. It is intended purely as a helper class, and
should be transparent to the user.
\exitnoteb
\end{itemdescr}

\rSec3[lib.indirect.array.cons]{\tcode{indirect_array} constructors}

\indexlibrary{\idxcode{indirect_array}!\idxcode{indirect_array}}%
\begin{itemdecl}
indirect_array();
indirect_array(const indirect_array&);
\end{itemdecl}

\begin{itemdescr}
The \tcode{indirect_array} template has no public constructors. The constructors
listed above are private. These constructors need not be defined.
\end{itemdescr}

\rSec3[lib.indirect.array.assign]{\tcode{indirect_array} assignment}

\indexlibrary{\idxcode{operator=}!\idxcode{indirect_array}}%
\begin{itemdecl}
void operator=(const valarray<T>&) const;
indirect_array& operator=(const indirect_array&);
\end{itemdecl}

\begin{itemdescr}
\pnum
The second of these two assignment operators is declared private and need
not be defined. The first has reference semantics, assigning the values
of the argument array elements to selected elements of the
\tcode{valarray<T>}
object to which it refers.

\pnum
If the
\tcode{indirect_array}
specifies an element in the
\tcode{valarray<T>}
object to which it refers more than once, the behavior is undefined.
\indextext{undefined}%

\pnum
\enterexample
\begin{codeblock}
int addr[] = {2, 3, 1, 4, 4};
valarray<size_t> indirect(addr, 5);
valarray<double> a(0., 10), b(1., 5);
a[indirect] = b;
\end{codeblock}
results in undefined behavior since element 4 is specified twice in the
indirection.
\exitexampleb
\end{itemdescr}

\rSec3[lib.indirect.array.comp.assign]{\tcode{indirect_array} computed assignment}

\indexlibrary{\idxcode{operator*=}!\idxcode{indirect_array}}%
\indexlibrary{\idxcode{operator*=}!\idxcode{indirect_array}}%
\indexlibrary{\idxcode{operator*=}!\idxcode{indirect_array}}%
\indexlibrary{\idxcode{operator/=}!\idxcode{indirect_array}}%
\indexlibrary{\idxcode{operator\%=}!\idxcode{indirect_array}}%
\indexlibrary{\idxcode{operator+=}!\idxcode{indirect_array}}%
\indexlibrary{\idxcode{operator-=}!\idxcode{indirect_array}}%
\indexlibrary{\idxcode{operator\^{}=}!\idxcode{indirect_array}}%
\indexlibrary{\idxcode{operator\&=}!\idxcode{indirect_array}}%
\indexlibrary{\idxcode{operator"|=}!\idxcode{indirect_array}}%
\indexlibrary{\idxcode{operator\shl=}!\idxcode{indirect_array}}%
\indexlibrary{\idxcode{operator\shr=}!\idxcode{indirect_array}}%
\begin{itemdecl}
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
These computed assignments have reference semantics, applying the indicated
operation to the elements of the argument array and selected elements of the
\tcode{valarray<T>}
object to which the
\tcode{indirect_array}
object refers.

\pnum
If the
\tcode{indirect_array}
specifies an element in the
\tcode{valarray<T>}
object to which it refers more than once,
the behavior is undefined.
\indextext{undefined}
\end{itemdescr}

\rSec3[lib.indirect.array.fill]{\tcode{indirect_array} fill function}

\indexlibrary{\idxcode{fill}!\idxcode{indirect_array}}%
\begin{itemdecl}
void operator=(const T&);
\end{itemdecl}

\begin{itemdescr}
\pnum
This function has reference semantics, assigning the value of its argument
to the elements of the
\tcode{valarray<T>}
object to which the
\tcode{indirect_array}
object refers.
\end{itemdescr}

\rSec1[lib.numeric.ops]{Generalized numeric operations}

\synopsis{Header \tcode{<numeric>} synopsis}

\indexlibrary{\idxhdr{numeric}}%
\begin{codeblock}
namespace std {
  template <class InputIterator, class T>
    T accumulate(InputIterator first, InputIterator last, T init);
  template <class InputIterator, class T, class BinaryOperation>
    T accumulate(InputIterator first, InputIterator last, T init,
                 BinaryOperation binary_op);

  template <class InputIterator1, class InputIterator2, class T>
    T inner_product(InputIterator1 first1, InputIterator1 last1,
                    InputIterator2 first2, T init);
  template <class InputIterator1, class InputIterator2, class T,
            class BinaryOperation1, class BinaryOperation2>
    T inner_product(InputIterator1 first1, InputIterator1 last1,
                    InputIterator2 first2, T init,
                    BinaryOperation1 binary_op1,
                    BinaryOperation2 binary_op2);

  template <class InputIterator, class OutputIterator>
    OutputIterator partial_sum(InputIterator first,
                               InputIterator last,
                               OutputIterator result);
  template <class InputIterator, class OutputIterator,
            class BinaryOperation>
    OutputIterator partial_sum(InputIterator first,
                               InputIterator last,
                               OutputIterator result,
                               BinaryOperation binary_op);

  template <class InputIterator, class OutputIterator>
    OutputIterator adjacent_difference(InputIterator first,
                                       InputIterator last,
                                       OutputIterator result);
  template <class InputIterator, class OutputIterator,
            class BinaryOperation>
    OutputIterator adjacent_difference(InputIterator first,
                                       InputIterator last,
                                       OutputIterator result,
                                       BinaryOperation binary_op);
}
\end{codeblock}

\pnum
The requirements on the types of algorithms' arguments that are
described in the introduction to clause~\ref{lib.algorithms} also
apply to the following algorithms.

\rSec2[lib.accumulate]{Accumulate}

\indexlibrary{\idxcode{accumulate}}%
\begin{itemdecl}
template <class InputIterator, class T>
  T accumulate(InputIterator first, InputIterator last, T init);
template <class InputIterator, class T, class BinaryOperation>
  T accumulate(InputIterator first, InputIterator last, T init,
               BinaryOperation binary_op);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Computes its result by initializing the accumulator
\tcode{acc}
with the initial value
\tcode{init}
and then modifies it with
\tcode{acc = acc + *i}
or
\tcode{acc = binary_op(acc, *i)}
for every iterator
\tcode{i}
in the range \range{first}{last}
in order.\footnote{\tcode{accumulate}
is similar to the APL reduction operator and Common Lisp reduce function, but
it avoids the difficulty of defining the result of reduction on an empty
sequence by always requiring an initial value.}

\pnum
\requires
\tcode{T} must meet the requirements of CopyConstructible~(\ref{lib.copyconstructible})
and Assignable~(\ref{lib.container.requirements}) types.
\tcode{binary_op}
shall not cause side effect.
\end{itemdescr}

\rSec2[lib.inner.product]{Inner product}
\indexlibrary{\idxcode{inner_product}}%

\indexlibrary{\idxcode{inner_product}}%
\begin{itemdecl}
template <class InputIterator1, class InputIterator2, class T>
  T inner_product(InputIterator1 first1, InputIterator1 last1,
                  InputIterator2 first2, T init);
template <class InputIterator1, class InputIterator2, class T,
          class BinaryOperation1, class BinaryOperation2>
  T inner_product(InputIterator1 first1, InputIterator1 last1,
                  InputIterator2 first2, T init,
                  BinaryOperation1 binary_op1,
                  BinaryOperation2 binary_op2);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Computes its result by initializing the accumulator
\tcode{acc}
with the initial value
\tcode{init}
and then modifying it with
\tcode{acc = acc + (*i1) * (*i2)}
or
\tcode{acc = binary_op1(acc, binary_op2(*i1, *i2))}
for every iterator
\tcode{i1}
in the range \range{first}{last}
and iterator
\tcode{i2}
in the range
\range{first2}{first2 + (last - first)}
in order.

\pnum
\requires
\tcode{T} must meet the requirements of CopyConstructible~(\ref{lib.copyconstructible})
and Assignable~(\ref{lib.container.requirements}) types.
\tcode{binary_op1}
and
\tcode{binary_op2}
shall not cause side effects.
\end{itemdescr}

\rSec2[lib.partial.sum]{Partial sum}

\indexlibrary{\idxcode{partial_sum}}%
\begin{itemdecl}
template <class InputIterator, class OutputIterator>
  OutputIterator
    partial_sum(InputIterator first, InputIterator last,
                OutputIterator result);
template
  <class InputIterator, class OutputIterator, class BinaryOperation>
    OutputIterator
      partial_sum(InputIterator first, InputIterator last,
                  OutputIterator result, BinaryOperation binary_op);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Assigns to every element referred to by iterator \tcode{i} in the range
\tcode{[result, result + (last - first))} a value correspondingly equal to\\
\tcode{((...(*first + *(first + 1)) + ...) + *(first + (i - result)))}\\
or\\
\tcode{binary_op(binary_op(..., binary_op(*first, *(first + 1)),...),
*(first + (i - result)))}

\pnum
\returns
\tcode{result + (last - first)}.

\pnum
\complexity
Exactly
\tcode{(last - first) - 1}
applications of
\tcode{binary_op}.

\pnum
\requires
\tcode{binary_op} is expected not to have any side effects.

\pnum
\notes
\tcode{result}
may be equal to
\tcode{first}.
\end{itemdescr}

\rSec2[lib.adjacent.difference]{Adjacent difference}

\indexlibrary{\idxcode{adjacent_difference}}%
\begin{itemdecl}
template <class InputIterator, class OutputIterator>
  OutputIterator
    adjacent_difference(InputIterator first, InputIterator last,
                        OutputIterator result);
template
  <class InputIterator, class OutputIterator, class BinaryOperation>
    OutputIterator
      adjacent_difference(InputIterator first, InputIterator last,
                          OutputIterator result,
                          BinaryOperation binary_op);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Assigns to every element referred to by iterator \tcode{i} in the range
\tcode{[result + 1, result + (last - first))} a value correspondingly equal to\\
\tcode{*(first + (i - result)) - *(first + (i - result) - 1)}\\
or\\
\tcode{binary_op(*(first + (i - result)), *(first + (i - result) - 1))}.\\
\tcode{result} gets the value of \tcode{*first}.

\pnum
\requires
\tcode{binary_op} shall not have any side effects.

\pnum
\notes
\tcode{result}
may be equal to
\tcode{first}.

\pnum
\returns
\tcode{result + (last - first)}.

\pnum
\complexity
Exactly
\tcode{(last - first) - 1}
applications of
\tcode{binary_op}.
\end{itemdescr}

\rSec1[lib.c.math]{C Library}

\pnum
Tables~\ref{tab:numerics.hdr.cmath} and~\ref{tab:numerics.hdr.cstdlib}
describe headers \tcode{<cmath>}
and \tcode{<cstdlib>} (\tcode{abs()}, \tcode{div()}, \tcode{rand()}, \tcode{srand()}),
respectively.

\begin{libsyntab5}{cmath}{tab:numerics.hdr.cmath}
\macro &
\tcode{HUGE_VAL} &&&\\ \rowsep

\cspan{\functions} \\

\tcode{acos}   &
\tcode{cos}  &
\tcode{fmod}  &
\tcode{modf}  &
\tcode{tan} \\

\tcode{asin}  &
\tcode{cosh} &
\tcode{frexp} &
\tcode{pow} &
\tcode{tanh} \\

\tcode{atan} &
\tcode{exp} &
\tcode{ldexp} &
\tcode{sin} & \\

\tcode{atan2} &
\tcode{fabs} &
\tcode{log} &
\tcode{sinh} & \\

\tcode{ceil} &
\tcode{floor} &
\tcode{log10} &
\tcode{sqrt} & \\

\end{libsyntab5}

\begin{libsyntab3}{cstdlib}{tab:numerics.hdr.cstdlib}
\macros       & \tcode{RAND_MAX}&         \\ \rowsep
\types        & \tcode{div_t} & \tcode{ldiv_t} \\ \rowsep
\functions    &         &         \\
\tcode{abs}   & \tcode{labs}  & \tcode{srand}  \\
\tcode{div}   & \tcode{ldiv}  & \tcode{rand}   \\
\end{libsyntab3}

\pnum
The contents of these headers are the same as the Standard C library headers
\tcode{<math.h>}
and
\tcode{<stdlib.h>}
respectively, with the following additions:

\pnum
In addition to the
\tcode{int}
versions of certain math functions in
\tcode{<cstdlib>},
\Cpp adds
\tcode{long}
overloaded versions of these functions, with the same semantics.

\pnum
The added signatures are:
\indexlibrary{\idxcode{abs}}%
\indexlibrary{\idxcode{div}}%
\begin{codeblock}
long   abs(long);               // \tcode{labs()}
ldiv_t div(long, long);         // \tcode{ldiv()}
\end{codeblock}

\pnum
In addition to the
\tcode{double}
versions of the math functions in
\tcode{<cmath>},
\Cpp adds
\tcode{float}
and
\tcode{long double}
overloaded versions of these functions, with the same semantics.

\pnum
The added signatures are:

\indexlibrary{\idxcode{abs}}%
\indexlibrary{\idxcode{acos}}%
\indexlibrary{\idxcode{asin}}%
\indexlibrary{\idxcode{atan}}%
\indexlibrary{\idxcode{atan2}}%
\indexlibrary{\idxcode{ceil}}%
\indexlibrary{\idxcode{cos}}%
\indexlibrary{\idxcode{cosh}}%
\indexlibrary{\idxcode{exp}}%
\indexlibrary{\idxcode{fabs}}%
\indexlibrary{\idxcode{floor}}%
\indexlibrary{\idxcode{fmod}}%
\indexlibrary{\idxcode{frexp}}%
\indexlibrary{\idxcode{ldexp}}%
\indexlibrary{\idxcode{log}}%
\indexlibrary{\idxcode{log10}}%
\indexlibrary{\idxcode{modf}}%
\indexlibrary{\idxcode{pow}}%
\indexlibrary{\idxcode{pow}}%
\indexlibrary{\idxcode{sin}}%
\indexlibrary{\idxcode{sinh}}%
\indexlibrary{\idxcode{sqrt}}%
\indexlibrary{\idxcode{tan}}%
\indexlibrary{\idxcode{tanh}}%

\begin{codeblock}
float abs  (float);
float acos (float);
float asin (float);
float atan (float);
float atan2(float, float);
float ceil (float);
float cos  (float);
float cosh (float);
float exp  (float);
float fabs (float);
float floor(float);
float fmod (float, float);
float frexp(float, int*);
float ldexp(float, int);
float log  (float);
float log10(float);
float modf (float, float*);
float pow  (float, float);
float pow  (float, int);
float sin  (float);
float sinh (float);
float sqrt (float);
float tan  (float);
float tanh (float);

double abs(double);            // \tcode{fabs()}
double pow(double, int);

long double abs  (long double);
long double acos (long double);
long double asin (long double);
long double atan (long double);
long double atan2(long double, long double);
long double ceil (long double);
long double cos  (long double);
long double cosh (long double);
long double exp  (long double);
long double fabs (long double);
long double floor(long double);
long double fmod (long double, long double);
long double frexp(long double, int*);
long double ldexp(long double, int);
long double log  (long double);
long double log10(long double);
long double modf (long double, long double*);
long double pow  (long double, long double);
long double pow  (long double, int);
long double sin  (long double);
long double sinh (long double);
long double sqrt (long double);
long double tan  (long double);
long double tanh (long double);
\end{codeblock}

\xref
ISO C subclauses 7.5, 7.10.2, 7.10.6.
