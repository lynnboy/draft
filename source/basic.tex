\rSec0[basic]{Basic concepts}

%gram: \rSec1[gram.basic]{Basic concepts}
%gram:

\pnum
\enternote this clause presents the basic concepts of the \Cpp language.
It explains the difference between an \term{object} and a
\term{name} and how they relate to the notion of an \term{lvalue}.
It introduces the concepts of a
\term{declaration} and a \term{definition} and presents \Cpp's
notion of \term{type}, \term{scope}, \term{linkage}, and
\term{storage} \term{duration}. The mechanisms for starting and
terminating a program are discussed. Finally, this clause presents the
fundamental types of the language and lists the ways of constructing
\term{compound} types from these.

\pnum
This clause does not cover concepts that affect only a single
part of the language. Such concepts are discussed in the relevant
clauses. \exitnote

\pnum
\indextext{name}%
\indextext{declaration}%
\indextext{type}%
\indextext{object}%
\indextext{storage~class}%
\indextext{scope}%
\indextext{linkage}%
\indextext{region!declarative}%
\indextext{entity}%
An \defn{entity} is a value, object, subobject, base class subobject,
array element, variable, function, instance of a function, enumerator, type,
class member, template, or namespace.

\pnum
A \defn{name} is a use of an \grammarterm{identifier}~(\ref{lex.name}) that
denotes an entity or \grammarterm{label}~(\ref{stmt.goto}, \ref{stmt.label}).
A \defn{variable} is introduced by the declaration of an object.
The variable's name denotes the object.

\pnum
Every name that denotes an entity is introduced by a
\term{declaration}. Every name that denotes a label is introduced
either by a \tcode{goto} statement~(\ref{stmt.goto}) or a
\grammarterm{labeled-statement}~(\ref{stmt.label}).

\pnum
Some names denote types, classes, enumerations, or templates. In general,
it is necessary to determine whether or not a name denotes
one of these entities before parsing the program that contains it. The
process that determines this is called
\indextext{lookup!name}%
\term{name lookup}~(\ref{basic.lookup}).

\pnum
Two names are \term{the same} if

\begin{itemize}
\item they are identifiers composed of the same character sequence; or
\item they are the names of overloaded operator functions formed with
the same operator; or
\item they are the names of user-defined conversion functions formed
with the same type.
\end{itemize}

\pnum
\indextext{translation~unit!name~and}%
\indextext{linkage}%
An identifier used in more than one translation unit can potentially
refer to the same entity in these translation units depending on the
linkage~(\ref{basic.link}) of the identifier specified in each
translation unit.

\rSec1[basic.def]{Declarations and definitions}

\pnum
\indextext{declaration!definition~versus}%
\indextext{declaration}%
\indextext{declaration!name}%
A declaration (clause~\ref{dcl.dcl}) introduces names into a translation
unit or redeclares names introduced by previous declarations.
A declaration specifies the interpretation and attributes of these names.

\pnum
\indextext{declaration!function}%
\indextext{definition}%
A declaration is a \defn{definition} unless it declares a function
without specifying the function's body~(\ref{dcl.fct.def}), it contains
the
\indextext{declaration!\idxcode{extern}}%
\tcode{extern} specifier~(\ref{dcl.stc}) or a
\grammarterm{linkage-specification}\footnote{Appearing inside the braced-enclosed
\grammarterm{declaration-seq} in a \grammarterm{linkage-specification} does
not affect whether a declaration is a definition.}
(\ref{dcl.link}) and neither an \grammarterm{initializer} nor a
\grammarterm{function-body},
\indextext{declaration!\idxcode{static member}}%
it declares a static data member in a class
declaration~(\ref{class.static}),
\indextext{declaration!class~name}%
it is a class name declaration~(\ref{class.name}),
or it is a
\indextext{declaration!\idxcode{typedef}}%
\tcode{typedef} declaration~(\ref{dcl.typedef}),
a
\grammarterm{using-declaration}~(\ref{namespace.udecl}),
or a \grammarterm{using-directive}~(\ref{namespace.udir}).

\pnum
\enterexample all but one of the following are definitions:

\indextext{example!definition}%
\begin{codeblock}
int a;                          // defines \tcode{a}
extern const int c = 1;         // defines \tcode{c}
int f(int x) { return x+a; }    // defines \tcode{f} and defines \tcode{x}
struct S { int a; int b; };     // defines \tcode{S}, \tcode{S::a}, and \tcode{S::b}
struct X {                      // defines \tcode{X}
    int x;                      // defines nonstatic data member \tcode{x}
    static int y;               // declares static data member \tcode{y}
    X(): x(0) { }               // defines a constructor of \tcode{X}
};
int X::y = 1;                   // defines \tcode{X::y}
enum { up, down };              // defines \tcode{up} and \tcode{down}
namespace N { int d; }          // defines \tcode{N} and \tcode{N::d}
namespace N1 = N;               // defines \tcode{N1}
X anX;                          // defines \tcode{anX}

\end{codeblock}
whereas these are just declarations:
\indextext{example!declaration}%
\begin{codeblock}
extern int a;                   // declares \tcode{a}
extern const int c;             // declares \tcode{c}
int f(int);                     // declares \tcode{f}
struct S;                       // declares \tcode{S}
typedef int Int;                // declares \tcode{Int}
extern X anotherX;              // declares \tcode{anotherX}
using N::d;                     // declares \tcode{N::d}
\end{codeblock}
\exitexampleb

\pnum
\enternote 
\indextext{implementation-generated}%
in some circumstances, \Cpp implementations implicitly define the
default constructor~(\ref{class.ctor}),
copy constructor~(\ref{class.copy}),
assignment operator~(\ref{class.copy}),
or destructor~(\ref{class.dtor}) member functions.
\enterexample given

\begin{codeblock}
struct C {
    string s;                   // \tcode{string} is the standard library class (clause~\ref{lib.strings})
};

int main()
{
    C a;
    C b = a;
    b = a;
}
\end{codeblock}

the implementation will implicitly define functions to make the
definition of \tcode{C} equivalent to

\begin{codeblock}
struct C {
    string s;
    C() : s() { }
    C(const C& x): s(x.s) { }
    C& operator=(const C& x) { s = x.s; return *this; }
    ~C() { }
};
\end{codeblock}
\exitexampleb
\exitnoteb

\pnum
\enternote a class name can also be implicitly declared by an
\grammarterm{elaborated-type-specifier}~(\ref{dcl.type.elab}).
\exitnote

\pnum
\indextext{type!incomplete}%
A program is ill-formed if the definition of any object gives the object
an incomplete type~(\ref{basic.types}).

\indextext{object!definition}%
\indextext{function!definition}%
\indextext{class!definition}%
\indextext{enumerator!definition}%
\indextext{one-definition~rule|(}%
\rSec1[basic.def.odr]{One definition rule}

\pnum
No translation unit shall contain more than one definition of any
variable, function, class type, enumeration type, or template.

\pnum
An expression is \defn{potentially evaluated} unless it appears where
an integral constant expression is required (see~\ref{expr.const}),
is the operand of the \tcode{sizeof} operator~(\ref{expr.sizeof}),
or is the operand of the \tcode{typeid} operator and the expression does not
designate an lvalue of polymorphic class type~(\ref{expr.typeid}).
An object or non-overloaded function is \defn{used} if its name appears in
a potentially-evaluated expression. A virtual member
function is used if it is not pure.
An overloaded function is used if it is selected by overload resolution
when referred to from a potentially-evaluated expression.
\enternote this covers calls to named
functions~(\ref{expr.call}), operator overloading (clause~\ref{over}),
user-defined conversions~(\ref{class.conv.fct}), allocation function for
placement new~(\ref{expr.new}), as well as non-default
initialization~(\ref{dcl.init}). A copy constructor is used even if the
call is actually elided by the implementation. \exitnote An allocation
or deallocation function for a class is used by a new expression
appearing in a potentially-evaluated expression as specified
in~\ref{expr.new} and~\ref{class.free}. A deallocation function for a
class is used by a delete expression appearing in a
potentially-evaluated expression as specified in~\ref{expr.delete}
and~\ref{class.free}. 
A copy-assignment function for a class is used by an implicitly-defined
copy-assignment function for another class as specified
in~\ref{class.copy}. A default constructor for a class is used by
default initialization as specified
in~\ref{dcl.init}. A constructor for a class is used as specified
in~\ref{dcl.init}. A destructor for a class is used as specified
in~\ref{class.dtor}.

\pnum
Every program shall contain exactly one definition of every non-inline
function or object that is used in that program; no diagnostic required.
The definition can appear explicitly in the program, it can be found in
the standard or a user-defined library, or (when appropriate) it is
implicitly defined (see~\ref{class.ctor}, \ref{class.dtor} and
\ref{class.copy}). An inline function shall be defined in every
translation unit in which it is used.

\pnum
\indextext{type!incomplete}%
Exactly one definition of a class is required in a translation unit if
the class is used in a way that requires the class type to be complete.
\enterexample the following complete translation unit is well-formed,
even though it never defines \tcode{X}:

\begin{codeblock}
struct X;                       // declare \tcode{X} as a struct type
struct X* x1;                   // use \tcode{X} in pointer formation
X* x2;                          // use \tcode{X} in pointer formation
\end{codeblock}
\exitexampleb
\enternote the rules for declarations and expressions
describe in which contexts complete class types are required. A class
type \tcode{T} must be complete if:

\begin{itemize}
\item an object of type \tcode{T} is defined~(\ref{basic.def}, \ref{expr.new}), or
\item an lvalue-to-rvalue conversion is applied to an lvalue referring
to an object of type \tcode{T}~(\ref{conv.lval}), or
\item an expression is converted (either implicitly or explicitly) to
type \tcode{T} (clause~\ref{conv}, \ref{expr.type.conv},
\ref{expr.dynamic.cast}, \ref{expr.static.cast}, \ref{expr.cast}), or
\item an expression that is not a null pointer constant, and has type
other than \tcode{void *}, is converted to the type pointer to \tcode{T}
or reference to \tcode{T} using an implicit conversion
(clause~\ref{conv}), a \tcode{dynamic_cast}~(\ref{expr.dynamic.cast}) or
a \tcode{static_cast}~(\ref{expr.static.cast}), or
\item a class member access operator is applied to an expression of type
\tcode{T}~(\ref{expr.ref}), or
\item the \tcode{typeid} operator~(\ref{expr.typeid}) or the
\tcode{sizeof} operator~(\ref{expr.sizeof}) is applied to an operand of
type \tcode{T}, or
\item a function with a return type or argument type of type \tcode{T}
is defined~(\ref{basic.def}) or called~(\ref{expr.call}), or
\item an lvalue of type \tcode{T} is assigned to~(\ref{expr.ass}).
\exitnote 
\end{itemize}

\pnum
There can be more than one definition of a class type
(clause~\ref{class}), enumeration type~(\ref{dcl.enum}), inline function
with external linkage~(\ref{dcl.fct.spec}), class template
(clause~\ref{temp}), non-static function template~(\ref{temp.fct}),
static data member of a class template~(\ref{temp.static}), member
function of a class template~(\ref{temp.mem.func}), or template
specialization for which some template parameters are not
specified~(\ref{temp.spec}, \ref{temp.class.spec}) in a program provided
that each definition appears in a different translation unit, and
provided the definitions satisfy the following requirements. Given such
an entity named \tcode{D} defined in more than one translation unit,
then
\begin{itemize}
\item each definition of \tcode{D} shall consist of the same sequence of
tokens; and
\item in each definition of \tcode{D}, corresponding names, looked up
according to~\ref{basic.lookup}, shall refer to an entity defined within
the definition of \tcode{D}, or shall refer to the same entity, after
overload resolution~(\ref{over.match}) and after matching of partial
template specialization~(\ref{temp.over}), except that a name can refer
to a \tcode{const} object with internal or no linkage if the object has
the same integral or enumeration type in all definitions of \tcode{D},
and the object is initialized with a constant
expression~(\ref{expr.const}), and the value (but not the address) of
the object is used, and the object has the same value in all definitions
of \tcode{D}; and
\item in each definition of \tcode{D}, the overloaded operators referred
to, the implicit calls to conversion functions, constructors, operator
new functions and operator delete functions, shall refer to the same
function, or to a function defined within the definition of \tcode{D};
and
\item in each definition of \tcode{D}, a default argument used by an
(implicit or explicit) function call is treated as if its token sequence
were present in the definition of \tcode{D}; that is, the default
argument is subject to the three requirements described above (and, if
the default argument has sub-expressions with default arguments, this
requirement applies recursively).\footnote{\ref{dcl.fct.default} 
describes how default argument names are looked up.}
\item if \tcode{D} is a class with an implicitly-declared
constructor~(\ref{class.ctor}), it is as if the constructor was
implicitly defined in every translation unit where it is used, and the
implicit definition in every translation unit shall call the same
constructor for a base class or a class member of \tcode{D}.
\enterexample

\begin{codeblock}
//translation unit 1:
struct X {
	X(int);
	X(int, int);
};
X::X(int = 0) { }
class D: public X { };
D d2;                           // \tcode{X(int)} called by \tcode{D()}

//translation unit 2:
struct X {
	X(int);
	X(int, int);
};
X::X(int = 0, int = 0) { }
class D: public X { };          // \tcode{X(int, int)} called by \tcode{D()};
                                // \tcode{D()}'s implicit definition
                                // violates the ODR
\end{codeblock}
\exitexampleb
If \tcode{D} is a template and is defined in more than one
translation unit, then the last four requirements from the list above
shall apply to names from the template's enclosing scope used in the
template definition~(\ref{temp.nondep}), and also to dependent names at
the point of instantiation~(\ref{temp.dep}). If the definitions of
\tcode{D} satisfy all these requirements, then the program shall behave
as if there were a single definition of \tcode{D}. If the definitions of
\tcode{D} do not satisfy these requirements, then the behavior is
undefined.%
\end{itemize}
\indextext{one-definition~rule|)}

\rSec1[basic.scope]{Declarative regions and scopes}%
\indextext{scope|(}

\pnum
\indextext{name!scope~of}%
Every name is introduced in some portion of program text called a
\indextext{region!declarative}%
\indextext{scope!potential}%
\defn{declarative region}, which is the largest part of the program
in which that name is \defn{valid}, that is, in which that name may
be used as an unqualified name to refer to the same entity. In general,
each particular name is valid only within some possibly discontiguous
portion of program text called its \defn{scope}. To determine the
scope of a declaration, it is sometimes convenient to refer to the
\defn{potential scope} of a declaration. The scope of a declaration
is the same as its potential scope unless the potential scope contains
another declaration of the same name. In that case, the potential scope
of the declaration in the inner (contained) declarative region is
excluded from the scope of the declaration in the outer (containing)
declarative region.

\pnum
\enterexample
in

\begin{codeblock}
int j = 24;
int main()
{
	int i = j, j;
	j = 42;
}
\end{codeblock}

the identifier \tcode{j} is declared twice as a name (and used twice).
The declarative region of the first \tcode{j} includes the entire
example. The potential scope of the first \tcode{j} begins immediately
after that \tcode{j} and extends to the end of the program, but its
(actual) scope excludes the text between the \tcode{,} and the
\tcode{\}}. The declarative region of the second declaration of
\tcode{j} (the \tcode{j} immediately before the semicolon) includes all
the text between \tcode{\{} and \tcode{\}}, but its potential scope
excludes the declaration of \tcode{i}. The scope of the second
declaration of \tcode{j} is the same as its potential scope.
\exitexample

\pnum
The names declared by a declaration are introduced into the scope in
which the declaration occurs, except that the presence of a
\tcode{friend} specifier~(\ref{class.friend}), certain uses of the
\grammarterm{elaborated-type-specifier}~(\ref{basic.scope.pdecl}), and
\grammarterm{using-directive}{s}~(\ref{namespace.udir}) alter this general
behavior.

\pnum
Given a set of declarations in a single declarative region, each of
which specifies the same unqualified name,

\begin{itemize}
\item they shall all refer to the same entity, or all refer to functions
and function templates; or
\item exactly one declaration shall declare a class name or enumeration
name that is not a typedef name and the other declarations shall all
refer to the same object or enumerator, or all refer to functions and
function templates; in this case the class name or enumeration name is
hidden~(\ref{basic.scope.hiding}). \enternote a namespace name or a
class template name must be unique in its declarative
region~(\ref{namespace.alias}, clause~\ref{temp}). \exitnote
\end{itemize}
\enternote these restrictions apply to the declarative region into which
a name is introduced, which is not necessarily the same as the region in
which the declaration occurs. In particular,
\grammarterm{elaborated-type-specifier}{s}~(\ref{basic.scope.pdecl}) and
friend declarations~(\ref{class.friend}) may introduce a (possibly not
visible) name into an enclosing namespace; these restrictions apply to
that region. Local extern declarations~(\ref{basic.link}) may introduce
a name into the declarative region where the declaration appears and
also introduce a (possibly not visible) name into an enclosing
namespace; these restrictions apply to both regions. \exitnote

\pnum
\enternote the name lookup rules are summarized in~\ref{basic.lookup}.
\exitnote

\rSec2[basic.scope.pdecl]{Point of declaration}

\pnum
\indextext{name!point~of declaration}%
The \defn{point of declaration} for a name is immediately after its
complete declarator (clause~\ref{dcl.decl}) and before its
\grammarterm{initializer} (if any), except as noted below. \enterexample

\begin{codeblock}
int x = 12;
{ int x = x; }
\end{codeblock}

Here the second \tcode{x} is initialized with its own (indeterminate)
value. \exitexample

\pnum
\enternote 
\indextext{name~hiding}%
a nonlocal name remains visible up
to the point of declaration of the local name that hides it. \enterexample

\begin{codeblock}
const int  i = 2;
{ int  i[i]; }
\end{codeblock}

declares a local array of two integers. \exitexample \exitnote

\pnum
\indextext{declaration!enumerator point~of}%
The point of declaration for an enumerator is immediately after its
\grammarterm{enumerator-definition}. \enterexample

\begin{codeblock}
const int x = 12;
{ enum { x = x }; }
\end{codeblock}

Here, the enumerator \tcode{x} is initialized with the value of the
constant \tcode{x}, namely 12. \exitexample

\pnum
After the point of declaration of a class member, the member name can be
looked up in the scope of its class. \enternote
\indextext{type!incomplete}%
this is true even if the class is an incomplete class. For example,

\begin{codeblock}
struct X {
	enum E { z = 16 };
	int b[X::z];            // OK
};
\end{codeblock}
\exitnoteb

\pnum
The point of declaration of a class first declared in an
\grammarterm{elaborated-type-specifier} is as follows:

\begin{itemize}
\item for an \grammarterm{elaborated-type-specifier} of the form

\begin{ncbnf}
class-key identifier \terminal{;}
\end{ncbnf}

the \grammarterm{elaborated-type-specifier} declares the
\grammarterm{identifier} to be a
\grammarterm{class-name} in the scope that contains the declaration,
otherwise
\item for an \grammarterm{elaborated-type-specifier} of the form

\begin{ncbnf}
class-key identifier
\end{ncbnf}

if the
\grammarterm{elaborated-type-specifier} is used in the
\grammarterm{decl-specifier-seq} or \grammarterm{parameter-declaration-clause}
of a function defined in namespace scope, the \grammarterm{identifier} is
declared as a \grammarterm{class-name} in the namespace that contains the
declaration; otherwise, except as a friend declaration, the
\grammarterm{identifier} is declared in the smallest non-class,
non-function-prototype scope that contains the declaration. \enternote
if the \grammarterm{elaborated-type-specifier} designates an enumeration,
the \grammarterm{identifier} must refer to an already declared
\grammarterm{enum-name}. If the \grammarterm{identifier} in the
\grammarterm{elaborated-type-specifier} is a \grammarterm{qualified-id},
it must refer to an already declared \grammarterm{class-name} or
\grammarterm{enum-name}. See~\ref{basic.lookup.elab}. \exitnote
\end{itemize}

\pnum
\enternote friend declarations refer to functions or classes that are
members of the nearest enclosing namespace, but they do not introduce
new names into that namespace~(\ref{namespace.memdef}). Function
declarations at block scope and object declarations with the
\tcode{extern} specifier at block scope refer to declarations that are
members of an enclosing namespace, but they do not introduce new names
into that scope.
\exitnote

\pnum
\enternote For point of instantiation of a template,
see~\ref{temp.point}.\exitnote%
\indextext{scope!declarations and|)}

\rSec2[basic.scope.local]{Local scope}

\pnum
\indextext{scope!block}%
\indextext{local~scope|see{block scope}}%
A name declared in a block~(\ref{stmt.block}) is local to that block.
Its potential scope begins at its point of
declaration~(\ref{basic.scope.pdecl}) and ends at the end of its
declarative region.

\pnum
\indextext{parameter!scope~of}%
The potential scope of a function parameter name in a function
definition~(\ref{dcl.fct.def}) begins at its point of declaration. If
the function has a \grammarterm{function-try-block} the potential scope of
a parameter ends at the end of the last associated handler, else it ends
at the end of the outermost block of the function definition. A
parameter name shall not be redeclared in the outermost block of the
function definition nor in the outermost block of any handler associated
with a \grammarterm{function-try-block}.

\pnum
\indextext{scope!exception~declaration}%
The name in a \tcode{catch} exception-declaration is local to the
handler and shall not be redeclared in the outermost block of the handler.

\pnum
Names declared in the \grammarterm{for-init-statement}, and in the
\grammarterm{condition} of \tcode{if}, \tcode{while}, \tcode{for}, and
\tcode{switch} statements are local to the \tcode{if}, \tcode{while},
\tcode{for}, or \tcode{switch} statement (including the controlled
statement), and shall not be redeclared in a subsequent condition of
that statement nor in the outermost block (or, for the \tcode{if}
statement, any of the outermost blocks) of the controlled statement;
see~\ref{stmt.select}.

\rSec2[basic.scope.proto]{Function prototype scope}

\pnum
\indextext{scope!function~prototype}%
\indextext{function~prototype}%
In a function declaration, or in any function declarator except the
declarator of a function definition~(\ref{dcl.fct.def}), names of
parameters (if supplied) have function prototype scope, which terminates
at the end of the nearest enclosing function declarator.

\rSec2[basic.funscope]{Function scope}

\pnum
\indextext{scope!function}%
\indextext{label!scope~of}%
Labels~(\ref{stmt.label}) have \term{function scope} and
may be used anywhere in the function in which they are declared. Only
labels have function scope.

\rSec2[basic.scope.namespace]{Namespace scope}

\pnum
\indextext{scope!namespace}%
The declarative region of a \grammarterm{namespace-definition} is its
\grammarterm{namespace-body}. The potential scope denoted by an
\grammarterm{original-namespace-name} is the concatenation of the
declarative regions established by each of the
\grammarterm{namespace-definition}{s} in the same declarative region with
that \grammarterm{original-namespace-name}. Entities declared in a
\grammarterm{namespace-body} are said to be \defn{members} of the
namespace, and names introduced by these declarations into the
declarative region of the namespace are said to be \defn{member
names} of the namespace. A namespace member name has namespace scope.
Its potential scope includes its namespace from the name's point of
declaration~(\ref{basic.scope.pdecl}) onwards; and for each
\grammarterm{using-directive}~(\ref{namespace.udir}) that nominates the
member's namespace, the member's potential scope includes that portion
of the potential scope of the \grammarterm{using-directive} that follows
the member's point of declaration. \enterexample

\begin{codeblock}
namespace N {
	int i;
	int g(int a) { return a; }
	int j();
	void q();
}
namespace { int l=1; }
// the potential scope of \tcode{l} is from its point of declaration
// to the end of the translation unit

namespace N {
	int g(char a)		// overloads \tcode{N::g(int)}
	{
		return l+a;     // \tcode{l} is from unnamed namespace
	}

	int i;			// error: duplicate definition
	int j();		// OK: duplicate function declaration

	int j()			// OK: definition of \tcode{N::j()}
	{
		return g(i);    // calls \tcode{N::g(int)}
	}
	int q();		// error: different return type
}
\end{codeblock}
\exitexampleb

\pnum
A namespace member can also be referred to after the \tcode{::} scope
resolution operator~(\ref{expr.prim}) applied to the name of its
namespace or the name of a namespace which nominates the member's
namespace in a \grammarterm{using-directive;} see~\ref{namespace.qual}.

\pnum
\indextext{scope!global namespace}%
\indextext{scope!global}%
The outermost declarative region of a translation unit is also a
namespace, called the \defn{global namespace}. A name declared in
the global namespace has \defn{global namespace scope} (also called
\defn{global scope}). The potential scope of such a name begins at
its point of declaration~(\ref{basic.scope.pdecl}) and ends at the end
of the translation unit that is its declarative region.
\indextext{name!global}%
Names with global namespace scope are said to be
\defnx{global}{global}.

\rSec2[basic.scope.class]{Class scope}

\pnum
\indextext{scope!class}%
The following rules describe the scope of names declared in classes.

\begin{enumeraten}
\item The potential scope of a name declared in a class consists not
only of the declarative region following the name's declarator,
but also of all function bodies, default arguments, and constructor
\grammarterm{ctor-initializers} in that class (including such
things in nested classes).
\item A name \tcode{N} used in a class \tcode{S} shall refer to the same
declaration in its context and when re-evaluated in the completed scope
of \tcode{S}. No diagnostic is required for a violation of this rule.
\item If reordering member declarations in a class yields an alternate
valid program under (1) and (2), the program is ill-formed, no
diagnostic is required.
\item A name declared within a member function hides a declaration of
the same name whose scope extends to or past the end of the member
function's class.
\item The potential scope of a declaration that extends to or past the
end of a class definition also extends to the regions defined by its
member definitions, even if the members are defined lexically outside
the class (this includes static data member definitions, nested class
definitions, member function definitions (including the member function
body and, for constructor functions~(\ref{class.ctor}),
the ctor-initializer~(\ref{class.base.init})) and any portion of the
declarator part of such definitions which follows the identifier,
including a \grammarterm{parameter-declaration-clause} and any default
arguments~(\ref{dcl.fct.default}). \enterexample

\begin{codeblock}
typedef int  c;
enum { i = 1 };

class X {
    char  v[i];				// error: \tcode{i} refers to \tcode{::i}
					// but when reevaluated is \tcode{X::i}
    int  f() { return sizeof(c); }	//  OK: \tcode{X::c}
    char  c;
    enum { i = 2 };
};

typedef char*  T;
struct Y {
    T  a;			// error: \tcode{T} refers to \tcode{::T}
				// but when reevaluated is \tcode{Y::T}
    typedef long  T;
    T  b;
};

typedef int I;
class D {
    typedef I I;		// error, even though no reordering involved
};
\end{codeblock}
\exitexampleb
\end{enumeraten}

\pnum
The name of a class member shall only be used as follows:

\begin{itemize}
\item in the scope of its class (as described above) or a class derived
(clause~\ref{class.derived}) from its class,
\item after the \tcode{.} operator applied to an expression of the type
of its class~(\ref{expr.ref}) or a class derived from its class,
\item after the \tcode{->} operator applied to a pointer to an object of
its class~(\ref{expr.ref}) or a class derived from its class,
\item after the \tcode{::} scope resolution operator~(\ref{expr.prim})
applied to the name of its class or a class derived from its class.
\end{itemize}

\rSec2[basic.scope.hiding]{Name hiding}

\pnum
\indextext{scope~name~hiding~and}%
\indextext{name~hiding}%
\indextext{hiding|see{name hiding}}%
A name can be hidden by an explicit declaration of that same name in a
nested declarative region or derived class~(\ref{class.member.lookup}).

\pnum
\indextext{name~hiding}%
A class name~(\ref{class.name}) or enumeration name~(\ref{dcl.enum}) can
be hidden by the name of an object, function, or enumerator are declared in
the same scope. If a class or enumeration name and an object, function,
or enumerator are declared in the same scope (in any order) with the
same name, the class or enumeration name is hidden wherever the object,
function, or enumerator name is visible.

\pnum
In a member function definition, the declaration of a local name hides
the declaration of a member of the class with the same name;
see~\ref{basic.scope.class}. The declaration of a member in a derived
class (clause~\ref{class.derived}) hides the declaration of a member of
a base class of the same name; see~\ref{class.member.lookup}.

\pnum
During the lookup of a name qualified by a namespace name, declarations
that would otherwise be made visible by a \grammarterm{using-directive} can
be hidden by declarations with the same name in the namespace containing
the \grammarterm{using-directive;} see~(\ref{namespace.qual}).

\pnum
\indextext{visibility}%
If a name is in scope and is not hidden it is said to be \defn{visible}.%
\indextext{scope|)}

\rSec1[basic.lookup]{Name lookup}%
\indextext{scope!name~lookup~and|(}%
\indextext{lookup!name|(}%

\pnum
The name lookup rules apply uniformly to all names (including
\grammarterm{typedef-names}~(\ref{dcl.typedef}),
\grammarterm{namespace-names}~(\ref{basic.namespace}), and
\grammarterm{class-names}~(\ref{class.name})) wherever the grammar allows
such names in the context discussed by a particular rule. Name lookup
associates the use of a name with a declaration~(\ref{basic.def}) of
that name. Name lookup shall find an unambiguous declaration for the
name (see~\ref{class.member.lookup}). Name lookup may associate more
than one declaration with a name if it finds the name to be a function
name; the declarations are said to form a set of overloaded
functions~(\ref{over.load}). Overload resolution~(\ref{over.match})
takes place after name lookup has succeeded. The access rules
(clause~\ref{class.access}) are considered only once name lookup and
function overload resolution (if applicable) have succeeded. Only after
name lookup, function overload resolution (if applicable) and access
checking have succeeded are the attributes introduced by the name's
declaration used further in expression processing (clause~\ref{expr}).

\pnum
A name ``looked up in the context of an expression'' is looked up as an
unqualified name in the scope where the expression is found.

\pnum
The injected-class-name of a class (clause~\ref{class}) is also
considered to be a member of that class for the purposes of name hiding
and lookup.

\pnum
\enternote \ref{basic.link} discusses linkage issues. The notions of
scope, point of declaration and name hiding are discussed
in~\ref{basic.scope}. \exitnote

\rSec2[basic.lookup.unqual]{Unqualified name lookup}

\pnum
\indextext{lookup!unqualified~name}%
\indextext{name!unqualified}%
In all the cases listed in~\ref{basic.lookup.unqual}, the scopes are
searched for a declaration in the order listed in each of the respective
categories; name lookup ends as soon as a declaration is found for the
name. If no declaration is found, the program is ill-formed.

\pnum
The declarations from the namespace nominated by a
\grammarterm{using-directive} become visible in a namespace enclosing the
\grammarterm{using-directive}; see~\ref{namespace.udir}. For the purpose of
the unqualified name lookup rules described
in~\ref{basic.lookup.unqual}, the declarations from the namespace
nominated by the \grammarterm{using-directive} are considered members of
that enclosing namespace.

\pnum
The lookup for an unqualified name used as the
\grammarterm{postfix-expression} of a function call is described
in~\ref{basic.lookup.koenig}. \enternote for purposes of determining
(during parsing) whether an expression is a
\grammarterm{postfix-expression} for a function call, the usual name lookup
rules apply. The rules in~\ref{basic.lookup.koenig} have no effect on
the syntactic interpretation of an expression. For example,

\begin{codeblock}
typedef int f;
struct A {
	friend void f(A &);
	operator int();
	void g(A a) {
		f(a);
	}
};
\end{codeblock}

The expression \tcode{f(a)} is a \grammarterm{cast-expression} equivalent
to \tcode{int(a)}. Because the expression is not a function call, the
argument-dependent
name lookup~(\ref{basic.lookup.koenig}) does not apply and the friend
function \tcode{f} is not found. \exitnote

\pnum
A name used in global scope, outside of any function, class or
user-declared namespace, shall be declared before its use in global
scope.

\pnum
A name used in a user-declared namespace outside of the definition of
any function or class shall be declared before its use in that namespace
or before its use in a namespace enclosing its namespace.

\pnum
A name used in the definition of a function following the function's
\grammarterm{declarator-id}\footnote{This refers to unqualified names
that occur, for instance, in
a type or default argument expression in the
\grammarterm{parameter-declaration-clause} or used in the function body.}
that is a member of namespace \tcode{N} (where, only for the purpose of
exposition, \tcode{N} could represent the global scope) shall be
declared before its use in the block in which it is used or in one of
its enclosing blocks~(\ref{stmt.block}) or, shall be declared before its
use in namespace \tcode{N} or, if \tcode{N} is a nested namespace, shall
be declared before its use in one of \tcode{N}'s enclosing namespaces.\\
\enterexample

\begin{codeblock}
namespace A {
	namespace N {
		void f();
	}
}
void A::N::f() {
	i = 5;
	// The following scopes are searched for a declaration of \tcode{i}:
	// 1) outermost block scope of \tcode{A::N::f}, before the use of \tcode{i}
	// 2) scope of namespace \tcode{N}
	// 3) scope of namespace \tcode{A}
	// 4) global scope, before the definition of \tcode{A::N::f}
}
\end{codeblock}
\exitexampleb

\pnum
A name used in the definition of a class \tcode{X} outside of a member
function body or nested class definition\footnote{This refers to unqualified
names following the class name;
such a name may be used in the \grammarterm{base-clause} or may be used in
the class definition.}
shall be declared in one of the following ways:

\begin{itemize}
\item before its use in class \tcode{X} or be a member of a base class
of \tcode{X}~(\ref{class.member.lookup}), or
\item if \tcode{X} is a nested class of class
\tcode{Y}~(\ref{class.nest}), before the definition of \tcode{X} in
\tcode{Y}, or shall be a member of a base class of \tcode{Y} (this
lookup applies in turn to \tcode{Y} 's enclosing classes, starting with
the innermost enclosing class),\footnote{This lookup applies whether the
definition of \tcode{X} is
nested within \tcode{Y}'s definition or whether \tcode{X}'s definition
appears in a namespace scope enclosing \tcode{Y} 's
definition~(\ref{class.nest}).}
or
\item if \tcode{X} is a local class~(\ref{class.local}) or is a nested
class of a local class, before the definition of class \tcode{X} in a
block enclosing the definition of class \tcode{X}, or
\item if \tcode{X} is a member of namespace \tcode{N}, or is a nested
class of a class that is a member of \tcode{N}, or is a local class or a
nested class within a local class of a function that is a member of
\tcode{N}, before the definition of class \tcode{X} in namespace
\tcode{N} or in one of \tcode{N} 's enclosing namespaces.
\end{itemize}

\enterexample 

\begin{codeblock}
namespace M {
	class B { };
}

\end{codeblock}
\begin{codeblock}
namespace N {
	class Y : public M::B {
		class X {
			int a[i];
		};
	};
}

// The following scopes are searched for a declaration of \tcode{i}:
// 1) scope of class \tcode{N::Y::X}, before the use of \tcode{i}
// 2) scope of class \tcode{N::Y}, before the definition of \tcode{N::Y::X}
// 3) scope of \tcode{N::Y}'s base class \tcode{M::B}
// 4) scope of namespace \tcode{N}, before the definition of \tcode{N::Y}
// 5) global scope, before the definition of \tcode{N}
\end{codeblock}

\exitexampleb \enternote when looking for a prior declaration of a class
or function introduced by a \tcode{friend} declaration, scopes outside
of the innermost enclosing namespace scope are not considered;
see~\ref{namespace.memdef}. \exitnote \enternote \ref{basic.scope.class}
further describes the restrictions on the use of names in a class
definition. \ref{class.nest} further describes the restrictions on the
use of names in nested class definitions. \ref{class.local} further
describes the restrictions on the use of names in local class
definitions. \exitnote

\pnum
A name used in the definition of a member function~(\ref{class.mfct}) of
class \tcode{X} following the function's
\grammarterm{declarator-id}\footnote{That is, an unqualified name that occurs,
for instance, in a type or default argument expression in the
\grammarterm{parameter-declaration-clause}, in the function body, or in an
expression of a \grammarterm{mem-initializer} in a constructor definition.}
shall be declared in one of the following ways:

\begin{itemize}
\item before its use in the block in which it is used or in an enclosing
block~(\ref{stmt.block}), or

\item shall be a member of class \tcode{X} or be a member of a base
class of \tcode{X}~(\ref{class.member.lookup}), or

\item if \tcode{X}
is a nested class of class \tcode{Y}~(\ref{class.nest}), shall be a
member of \tcode{Y}, or shall be a member of a base class of \tcode{Y}
(this lookup applies in turn to \tcode{Y}'s enclosing classes, starting
with the innermost enclosing class),\footnote{This lookup applies whether
the member function is defined
within the definition of class \tcode{X} or whether the member function
is defined in a namespace scope enclosing \tcode{X}'s definition.}
or

\item if \tcode{X} is a local class~(\ref{class.local}) or is a nested
class of a local class, before the definition of class \tcode{X} in a
block enclosing the definition of class \tcode{X}, or

\item if \tcode{X} is a member of namespace \tcode{N}, or is a nested
class of a class that is a member of \tcode{N}, or is a local class or a
nested class within a local class of a function that is a member of
\tcode{N}, before the member function definition, in namespace \tcode{N}
or in one of \tcode{N} 's enclosing namespaces.
\end{itemize}

\enterexample 
\begin{codeblock}
class B { };
namespace M {
	namespace N {
		class X : public B {
			void f();
		};
	}
}
void M::N::X::f() {
	i = 16;
}

// The following scopes are searched for a declaration of \tcode{i}:
// 1) outermost block scope of \tcode{M::N::X::f}, before the use of \tcode{i}
// 2) scope of class \tcode{M::N::X}
// 3) scope of \tcode{M::N::X}'s base class \tcode{B}
// 4) scope of namespace \tcode{M::N}
// 5) scope of namespace \tcode{M}
// 6) global scope, before the definition of \tcode{M::N::X::f}
\end{codeblock}
\exitexampleb \enternote \ref{class.mfct} and~\ref{class.static} further
describe the restrictions on the use of names in member function
definitions. \ref{class.nest} further describes the restrictions on the
use of names in the scope of nested classes. \ref{class.local} further
describes the restrictions on the use of names in local class
definitions. \exitnote

\pnum
Name lookup for a name used in the definition of a \tcode{friend}
function~(\ref{class.friend}) defined inline in the class granting
friendship shall proceed as described for lookup in member function
definitions. If the \tcode{friend} function is not defined in the class
granting friendship, name lookup in the \tcode{friend} function
definition shall proceed as described for lookup in namespace member
function definitions.

\pnum
In a \tcode{friend} declaration naming a member function, a name used in
the function declarator and not part of a \grammarterm{template-argument}
in a \grammarterm{template-id} is first looked up in the scope of the
member function's class. If it is not found, or if the name is part of a
\grammarterm{template-argument} in a
\grammarterm{template-id}, the look up is
as described for unqualified names in the definition of the class
granting friendship. \enterexample

\begin{codeblock}
struct A {
	typedef int AT;
	void f1(AT);
	void f2(float);
};
struct B {
	typedef float BT;
	friend void A::f1(AT);  // parameter type is \tcode{A::AT}
	friend void A::f2(BT);  // parameter type is \tcode{B::BT}
};
\end{codeblock}
\exitexampleb

\pnum
During the lookup for a name used as a default
argument~(\ref{dcl.fct.default}) in a function
\grammarterm{parameter-declaration-clause} or used in the
\grammarterm{expression} of a \grammarterm{mem-initializer} for a
constructor~(\ref{class.base.init}), the function parameter names are
visible and hide the names of entities declared in the block, class or
namespace scopes containing the function declaration. \enternote
\ref{dcl.fct.default} further describes the restrictions on the use of
names in default arguments. \ref{class.base.init} further describes the
restrictions on the use of names in a \grammarterm{ctor-initializer}.
\exitnote

\pnum
A name used in the definition of a \tcode{static} data member of class
\tcode{X}~(\ref{class.static.data}) (after the \grammarterm{qualified-id}
of the static member) is looked up as if the name was used in a member
function of \tcode{X}. \enternote \ref{class.static.data} further
describes the restrictions on the use of names in the definition of a
\tcode{static} data member. \exitnote

\pnum
A name used in the handler for a \grammarterm{function-try-block}
(clause~\ref{except}) is looked up as if the name was used in the
outermost block of the function definition. In particular, the function
parameter names shall not be redeclared in the
\grammarterm{exception-declaration} nor in the outermost block of a handler
for the \grammarterm{function-try-block}. Names declared in the outermost
block of the function definition are not found when looked up in the
scope of a handler for the \grammarterm{function-try-block}. \enternote but
function parameter names are found. \exitnote

\pnum
\enternote the rules for name lookup in template definitions are
described in~\ref{temp.res}. \exitnote

\rSec2[basic.lookup.koenig]{Argument-dependent name lookup}%
\indextext{lookup!argument-dependent}

\pnum
When an unqualified name is used as the \grammarterm{postfix-expression} in
a function call~(\ref{expr.call}), other namespaces not considered
during the usual unqualified lookup~(\ref{basic.lookup.unqual}) may be
searched, and namespace-scope friend function
declarations~(\ref{class.friend}) not otherwise visible may be found.
These modifications to the search depend on the types of the arguments
(and for template template arguments, the namespace of the template
argument).

\pnum
For each argument type \tcode{T} in the function call, there is a set of
zero or more associated namespaces and a set of zero or more associated
classes to be considered. The sets of namespaces and classes is
determined entirely by the types of the function arguments (and the
namespace of any template template argument). Typedef names and
\grammarterm{using-declaration}{s} used to specify the types do not
contribute to this set. The sets of namespaces and classes are
determined in the following way:

\begin{itemize}
\item If \tcode{T} is a fundamental type, its associated sets of
namespaces and classes are both empty.

\item If \tcode{T} is a class type (including unions), its associated
classes are: the class itself; the class of which it is a member, if
any; and its direct and indirect base classes. Its associated namespaces
are the namespaces in which its associated classes are defined.

\item If \tcode{T} is an enumeration type, its associated namespace is
the namespace in which it is defined. If it is class member, its
associated class is the member's class; else it has no associated class.

\item If \tcode{T} is a pointer to \tcode{U} or an array of \tcode{U},
its associated namespaces and classes are those associated with
\tcode{U}.

\item If \tcode{T} is a function type, its associated namespaces and
classes are those associated with the function parameter types and those
associated with the return type.

\item If \tcode{T} is a pointer to a member function of a class
\tcode{X}, its associated namespaces and classes are those associated
with the function parameter types and return type, together with those
associated with \tcode{X}.

\item If \tcode{T} is a pointer to a data member of class \tcode{X}, its
associated namespaces and classes are those associated with the member
type together with those associated with \tcode{X}.

\item if \tcode{T} is a \grammarterm{template-id}, its
associated namespaces and classes are the namespace in which the template is
defined; for member templates, the member template's class; the namespaces
and classes associated with the types of the template arguments provided for
template type parameters (excluding template template parameters); the
namespaces in which any template template arguments are defined; and the
classes in which any member templates used as template template
arguments are defined. \enternote non-type template arguments do not
contribute to the set of associated namespaces.\exitnote

\end{itemize}

In addition, if the argument is the name or address of a set of
overloaded functions and/or function templates, its associated classes
and namespaces are the union of those associated with each of the
members of the set: the namespaces in which the function or function template
is defined and the classes and namespaces associated with its (non-dependent)
parameter types and return type.

\pnumalt
If the ordinary unqualified lookup of the name finds the declaration of a
class member function, the associated namespaces and classes are not
considered. Otherwise the set of declarations found by the lookup of the
function name is the union of the set of declarations found using ordinary
unqualified lookup and the set of declarations found in the namespaces and
classes associated with the argument types.
\enternote the namespaces and classes
associated with the argument types can include namespaces and classes
already considered by the ordinary unqualified lookup. \exitnote
\enterexample

\begin{codeblock}
namespace NS {
    class T { };
    void f(T);
}
NS::T parm;
int main() {
    f(parm);                    // OK: calls \tcode{NS::f}
}
\end{codeblock}
\exitexampleb

\pnum
When considering an associated namespace, the lookup is the same as the
lookup performed when the associated namespace is used as a
qualifier~(\ref{namespace.qual}) except that:

\begin{itemize}
\item Any \grammarterm{using-directive}{s} in the associated namespace are
ignored.

\item Any namespace-scope friend functions declared in associated classes
are visible within their respective
namespaces even if they are not visible during an ordinary
lookup~(\ref{class.friend}).

\end{itemize}

\rSec2[basic.lookup.qual]{Qualified name lookup}

\pnum
\indextext{lookup!qualified~name|(}%
\indextext{name!qualified}%
\indextext{qualification!explicit}%
The name of a class or namespace member can be referred to after the
\tcode{::} scope resolution operator~(\ref{expr.prim}) applied to a
\grammarterm{nested-name-specifier} that nominates its class or namespace.
During the lookup for a name preceding the \tcode{::} scope resolution
operator, object, function, and enumerator names are ignored. If the
name found is not a \grammarterm{class-name} (clause~\ref{class})
or \grammarterm{namespace-name}~(\ref{namespace.def}),
the program is ill-formed. \enterexample

\begin{codeblock}
class A {
public:
	static int n;
};
int main()
{
	int A;
	A::n = 42;		// OK
	A b;			// ill-formed: \tcode{A} does not name a type
}
\end{codeblock}
\exitexampleb

\pnum
\enternote Multiply qualified names, such as \tcode{N1::N2::N3::n}, can
be used to refer to members of nested classes~(\ref{class.nest}) or
members of nested namespaces. \exitnote

\pnum
In a declaration in which the \grammarterm{declarator-id} is a
\grammarterm{qualified-id}, names used before the \grammarterm{qualified-id}
being declared are looked up in the defining namespace scope; names
following the \grammarterm{qualified-id} are looked up in the scope of the
member's class or namespace. \enterexample

\begin{codeblock}
class X { };
class C {
	class X { };
	static const int number = 50;
	static X arr[number];
};
X C::arr[number];		// ill-formed:
				// equivalent to: \tcode{::X} \tcode{C::arr[C::number];}
				// not to: \tcode{C::X} \tcode{C::arr[C::number];}
\end{codeblock}
\exitexampleb

\pnum
\indextext{scope~resolution~operator}%
A name prefixed by the unary scope operator \tcode{::}~(\ref{expr.prim})
is looked up in global scope, in the translation unit where it is used.
The name shall be declared in global namespace scope or shall be a name
whose declaration is visible in global scope because of a
\grammarterm{using-directive}~(\ref{namespace.qual}). The use of \tcode{::}
allows a global name to be referred to even if its identifier has been
hidden~(\ref{basic.scope.hiding}).

\pnum
If a \grammarterm{pseudo-destructor-name}~(\ref{expr.pseudo}) contains a
\grammarterm{nested-name-specifier}, the \grammarterm{type-name}{s} are looked
up as types in the scope designated by the
\grammarterm{nested-name-specifier}. In a
\grammarterm{qualified-id} of the form:

\begin{ncbnf}
\terminal{::}\opt nested-name-specifier \terminal{\tilde} class-name
\end{ncbnf}

where the \grammarterm{nested-name-specifier} designates a namespace scope,
and in a \grammarterm{qualified-id} of the form:

\begin{ncbnf}
\terminal{::}\opt nested-name-specifier class-name \terminal{::} \terminal{\tilde} class-name
\end{ncbnf}

the \grammarterm{class-name}{s} are looked up as types in the scope designated
by the \grammarterm{nested-name-specifier}. \enterexample

\begin{codeblock}
struct C {
	typedef int I;
};
typedef int I1, I2;
extern int* p;
extern int* q;
p->C::I::~I();			// \tcode{I} is looked up in the scope of \tcode{C}
q->I1::~I2();			// \tcode{I2} is looked up in the scope of
				// the postfix-expression

struct A {
	~A();
};
typedef A AB;
int main()
{
	AB *p;
	p->AB::~AB();		// explicitly calls the destructor for \tcode{A}
}
\end{codeblock}
\exitexampleb \enternote \ref{basic.lookup.classref} describes how name
lookup proceeds after the \tcode{.} and \tcode{->} operators. \exitnote

\rSec3[class.qual]{Class members}

\pnum
\indextext{lookup!class~member}%
If the \grammarterm{nested-name-specifier} of a \grammarterm{qualified-id}
nominates a class, the name specified after the
\grammarterm{nested-name-specifier} is looked up in the scope of the
class~(\ref{class.member.lookup}), except for the cases listed below.
The name shall represent one or more members of that class or of one of
its base classes (clause~\ref{class.derived}). \enternote a class member
can be referred to using a \grammarterm{qualified-id} at any point in its
potential scope~(\ref{basic.scope.class}). \exitnote The exceptions to
the name lookup rule above are the following:

\begin{itemize}
\item a destructor name is looked up as specified
in~\ref{basic.lookup.qual};

\item a \grammarterm{conversion-type-id} of an
\grammarterm{operator-function-id} is looked up both in the scope of the
class and in the context in which the entire
\grammarterm{postfix-expression} occurs and shall refer to the same type
in both contexts;

\item the \grammarterm{template-argument}{s} of a
\grammarterm{template-id} are looked up in the context in which the entire
\grammarterm{postfix-expression} occurs.

\end{itemize}

\pnumalt
If the \grammarterm{nested-name-specifier} nominates a class \tcode{C},
and the name specified after the \grammarterm{nested-name-specifier},
when looked up in \tcode{C}, is the injected-class-name of
\tcode{C} (clause~\ref{class}), the name is instead considered to name the
constructor of class \tcode{C}. Such a constructor
name shall be used only in the \grammarterm{declarator-id} of a constructor
definition that appears outside of the class definition. \enterexample

\begin{codeblock}
struct A { A(); };
struct B: public A { B(); };

A::A() { }
B::B() { }

B::A ba;			// object of type \tcode{A}
A::A a;				// error, \tcode{A::A} is not a type name
\end{codeblock}
\exitexampleb

\pnum
A class member name hidden by a name in a nested declarative region or
by the name of a derived class member can still be found if qualified by
the name of its class followed by the \tcode{::} operator.

\rSec3[namespace.qual]{Namespace members}

\pnum
\indextext{lookup!namespace~member}%
If the \grammarterm{nested-name-specifier} of a \grammarterm{qualified-id}
nominates a namespace, the name specified after the
\grammarterm{nested-name-specifier} is looked up in the scope of the
namespace, except that the \grammarterm{template-argument}{s} of a
\grammarterm{template-id} are looked up in the context in which the
entire \grammarterm{postfix-expression} occurs.

\pnum
Given \tcode{X::m} (where \tcode{X} is a user-declared namespace), or given
\tcode{::m} (where X is the global namespace), let \tcode{S} be the set of all
declarations of \tcode{m} in \tcode{X} and in the transitive closure of all
namespaces nominated by \grammarterm{using-directive}{s} in \tcode{X} and
its used namespaces, except that \grammarterm{using-directive}{s} are
ignored in any namespace, including \tcode{X}, directly containing one or
more declarations of
\tcode{m}. No namespace is searched more than once in the lookup of a name.
If \tcode{S} is the empty set, the program is ill-formed. Otherwise, if
\tcode{S} has exactly one member, or if the context of the reference is
a \grammarterm{using-declaration}~(\ref{namespace.udecl}), \tcode{S} is the
required set of declarations of \tcode{m}. Otherwise if the use of
\tcode{m} is not one that allows a unique declaration to be chosen from
\tcode{S}, the program is ill-formed. \enterexample

\begin{codeblock}
int x;
namespace Y {
	void f(float);
	void h(int);
}

namespace Z {
	void h(double);
}

namespace A {
	using namespace Y;
	void f(int);
	void g(int);
	int i;
}

namespace B {
	using namespace Z;
	void f(char);
	int i;
}

namespace AB {
	using namespace A;
	using namespace B;
	void g();
}

void h()
{
	AB::g();		// \tcode{g} is declared directly in \tcode{AB,}
				// therefore \tcode{S} is \{ \tcode{AB::g()} \} and \tcode{AB::g()} is chosen
	AB::f(1);		// \tcode{f} is not declared directly in \tcode{AB} so the rules are
				// applied recursively to \tcode{A} and \tcode{B;}
				// namespace \tcode{Y} is not searched and \tcode{Y::f(float)}
				// is not considered;
				// \tcode{S} is \{ \tcode{A::f(int)}, \tcode{B::f(char)} \} and overload
				// resolution chooses \tcode{A::f(int)}
	AB::f('c');		// as above but resolution chooses \tcode{B::f(char)}

	AB::x++;		// \tcode{x} is not declared directly in \tcode{AB}, and
				// is not declared in \tcode{A} or \tcode{B} , so the rules are
				// applied recursively to \tcode{Y} and \tcode{Z},
				// \tcode{S} is \{ \} so the program is ill-formed
	AB::i++;		// \tcode{i} is not declared directly in \tcode{AB} so the rules are
				// applied recursively to \tcode{A} and \tcode{B},
				// \tcode{S} is \{ \tcode{A::i} , \tcode{B::i} \} so the use is ambiguous
				// and the program is ill-formed
	AB::h(16.8);		// \tcode{h} is not declared directly in \tcode{AB} and
				// not declared directly in \tcode{A} or \tcode{B} so the rules are
				// applied recursively to \tcode{Y} and \tcode{Z},
				// \tcode{S} is \{ \tcode{Y::h(int)}, \tcode{Z::h(double)} \} and overload
				// resolution chooses \tcode{Z::h(double)}
}
\end{codeblock}

\pnum
The same declaration found more than once is not an ambiguity (because
it is still a unique declaration). For example:

\begin{codeblock}
namespace A {
	int a;
}

namespace B {
	using namespace A;
}

namespace C {
	using namespace A;
}

namespace BC {
	using namespace B;
	using namespace C;
}

void f()
{
	BC::a++;		// OK: \tcode{S} is \{ \tcode{A::a}, \tcode{A::a} \}
}

namespace D {
	using A::a;
}

namespace BD {
	using namespace B;
	using namespace D;
}

void g()
{
	BD::a++;		// OK: S is \{ \tcode{A::a}, \tcode{A::a} \}
}
\end{codeblock}

\pnum
Because each referenced namespace is searched at most once, the
following is well-defined:

\begin{codeblock}
namespace B {
	int b;
}

namespace A {
	using namespace B;
	int a;
}

namespace B {
	using namespace A;
}

void f()
{
	A::a++;			// OK: \tcode{a} declared directly in \tcode{A}, \tcode{S} is \{\tcode{A::a}\}
	B::a++;			// OK: both \tcode{A} and \tcode{B} searched (once), \tcode{S} is \{\tcode{A::a}\}
	A::b++;			// OK: both \tcode{A} and \tcode{B} searched (once), \tcode{S} is \{\tcode{B::b}\}
	B::b++;			// OK: \tcode{b} declared directly in \tcode{B}, \tcode{S} is \{\tcode{B::b}\}
}
\end{codeblock}
\exitexampleb

\pnum
During the lookup of a qualified namespace member name, if the lookup
finds more than one declaration of the member, and if one declaration
introduces a class name or enumeration name and the other declarations
either introduce the same object, the same enumerator or a set of
functions, the non-type name hides the class or enumeration name if and
only if the declarations are from the same namespace; otherwise (the
declarations are from different namespaces), the program is ill-formed.
\enterexample

\begin{codeblock}
namespace A {
	struct x { };
	int x;
	int y;
}

namespace B {
	struct y { };
}

namespace C {
	using namespace A;
	using namespace B;
	int i = C::x;		// OK, \tcode{A::x} (of type \tcode{int})
	int j = C::y;		// ambiguous, \tcode{A::y} or \tcode{B::y}
}
\end{codeblock}
\exitexampleb

\pnum
In a declaration for a namespace member in which the
\grammarterm{declarator-id} is a \grammarterm{qualified-id}, given that the
\grammarterm{qualified-id} for the namespace member has the form

\begin{ncbnf}
nested-name-specifier unqualified-id
\end{ncbnf}

the
\grammarterm{unqualified-id} shall name a member of the namespace
designated by the \grammarterm{nested-name-specifier}.
\enterexample

\begin{codeblock}
namespace A {
	namespace B {
		void f1(int);
	}
	using namespace B;
}
void A::f1(int) { }		// ill-formed, \tcode{f1} is not a member of \tcode{A}
\end{codeblock}

\exitexampleb However, in such namespace member declarations, the
\grammarterm{nested-name-specifier} may rely on \grammarterm{using-directive}{s}
to implicitly provide the initial part of the
\grammarterm{nested-name-specifier}. \enterexample

\begin{codeblock}
namespace A {
	namespace B {
		void f1(int);
	}
}

namespace C {
	namespace D {
		void f1(int);
	}
}

using namespace A;
using namespace C::D;
void B::f1(int){}		// OK, defines \tcode{A::B::f1(int)}
\end{codeblock}
\exitexampleb
\indextext{lookup!qualified~name|)}%

\rSec2[basic.lookup.elab]{Elaborated type specifiers}%
\indextext{lookup!elaborated~type~specifier|(}%
\indextext{type~specifier!elaborated}

\pnum
An \grammarterm{elaborated-type-specifier} may be
used to refer to a previously declared \grammarterm{class-name} or
\grammarterm{enum-name} even though the name has been hidden by a non-type
declaration~(\ref{basic.scope.hiding}). The \grammarterm{class-name} or
\grammarterm{enum-name} in the \grammarterm{elaborated-type-specifier}
may either be a simple \grammarterm{identifier} or be a
\grammarterm{qualified-id}.

\pnum
If the name in the \grammarterm{elaborated-type-specifier} is a simple
\grammarterm{identifier}, and unless the
\grammarterm{elaborated-type-specifier} has the following form:

\begin{ncbnf}
class-key identifier \terminal{;}
\end{ncbnf}

the \grammarterm{identifier} is looked up according
to~\ref{basic.lookup.unqual} but ignoring any non-type names that have
been declared. If this name lookup finds a \grammarterm{typedef-name}, the
\grammarterm{elaborated-type-specifier} is ill-formed. If the
\grammarterm{elaborated-type-specifier} refers to an
\grammarterm{enum-name} and this lookup does not find a previously
declared \grammarterm{enum-name}, the \grammarterm{elaborated-type-specifier}
is ill-formed. If the \grammarterm{elaborated-type-specifier} refers to an
\grammarterm{class-name} and this lookup does not find a previously
declared \grammarterm{class-name}, or if the
\grammarterm{elaborated-type-specifier} has the form:

\begin{ncbnf}
class-key identifier \terminal{;}
\end{ncbnf}

the \grammarterm{elaborated-type-specifier} is a declaration that
introduces the \grammarterm{class-name} as described
in~\ref{basic.scope.pdecl}.

\pnum
If the name is a \grammarterm{qualified-id}, the name is looked up
according its qualifications, as described in~\ref{basic.lookup.qual},
but ignoring any non-type names that have been declared.
If this name lookup finds a \grammarterm{typedef-name},
the \grammarterm{elaborated-type-specifier} is ill-formed.
If this name lookup does not find a previously declared
\grammarterm{class-name} or \grammarterm{enum-name}, the
\grammarterm{elaborated-type-specifier} is ill-formed. \enterexample

\begin{codeblock}
struct Node {
	struct Node* Next;      // OK: Refers to \tcode{Node} at global scope
	struct Data* Data;      // OK: Declares type \tcode{Data}
				// at global scope and member \tcode{Data}
};

struct Data {
	struct Node* Node;      // OK: Refers to \tcode{Node} at global scope
	friend struct ::Glob;   // error: \tcode{Glob} is not declared
                                // cannot introduce a qualified type~(\ref{dcl.type.elab})
	friend struct Glob;     // OK: Refers to (as yet) undeclared \tcode{Glob}
				// at global scope.
	@\tcode{/* ... */}@
};

struct Base {
	struct Data;			// OK: Declares nested \tcode{Data}
	struct ::Data*     thatData;	// OK: Refers to \tcode{::Data}
	struct Base::Data* thisData;	// OK: Refers to nested \tcode{Data}
	friend class ::Data;		// OK: global \tcode{Data} is a friend
	friend class Data;		// OK: nested \tcode{Data} is a friend
	struct Data @\tcode{\{ /* ... */ \};}@	 // Defines nested \tcode{Data}
};

struct Data;			// OK: Redeclares \tcode{Data} at global scope
struct ::Data;                  // error: cannot introduce a qualified type~(\ref{dcl.type.elab})
struct Base::Data;              // error: cannot introduce a qualified type~(\ref{dcl.type.elab})
struct Base::Datum;             // error: \tcode{Datum} undefined
struct Base::Data* pBase;       // OK: refers to nested \tcode{Data}
\end{codeblock}
\exitexampleb %
\indextext{lookup!elaborated~type~specifier|)}%

\rSec2[basic.lookup.classref]{Class member access}

\pnum
\indextext{lookup!class member}%
In a class member access expression~(\ref{expr.ref}), if the \tcode{.}
or \tcode{->} token is immediately followed by an \grammarterm{identifier}
followed by a \tcode{<}, the identifier must be looked up to determine
whether the \tcode{<} is the beginning of a template argument
list~(\ref{temp.names}) or a less-than operator. The identifier is first
looked up in the class of the object expression. If the identifier is
not found, it is then looked up in the context of the entire
\grammarterm{postfix-expression} and shall name a class or function
template. If the lookup in the class of the object expression finds a
template, the name is also looked up in the context of the entire
\grammarterm{postfix-expression} and

\begin{itemize}
\item if the name is not found, the name found in the class of the object
expression is used, otherwise
\item if the name is found in the context of the entire
\grammarterm{postfix-expression} and does not name a class template,
the name found in the class of the object expression is used, otherwise
\item if the name found is a class template, it must refer to the same
entity as the one found in the class of the object expression, otherwise
the program is ill-formed.
\end{itemize}

\pnum
If the \grammarterm{id-expression} in a class member
access~(\ref{expr.ref}) is an \grammarterm{unqualified-id}, and the type of
the object expression is of a class type \tcode{C} (or of pointer to a
class type \tcode{C}), the
\grammarterm{unqualified-id} is looked up in the scope of class \tcode{C}.
If the type of the object expression is of pointer to scalar type,
the \grammarterm{unqualified-id} is looked up in the context of the complete
\grammarterm{postfix-expression}.

\pnum
If the \grammarterm{unqualified-id} is \grammarterm{\tilde{}type-name},
and the type of the object expression is of a class type \tcode{C} (or
of pointer to a class type \tcode{C}), the
\grammarterm{type-name} is looked up in the context of the entire
\grammarterm{postfix-expression} and in the scope of class \tcode{C}.
The \grammarterm{type-name} shall refer to a \grammarterm{class-name}.
If \grammarterm{type-name} is found in both contexts, the name shall
refer to the same class type. If the type of the object expression
is of scalar type, the \grammarterm{type-name} is
looked up in the scope of the complete \grammarterm{postfix-expression}.

\pnum
If the \grammarterm{id-expression} in a class member access is a
\grammarterm{qualified-id} of the form

\begin{indented}
\tcode{class-name-or-namespace-name::...}
\end{indented}

the \grammarterm{class-name-or-namespace-name} following the \tcode{.} or
\tcode{->} operator is looked up both in the context of the entire
\grammarterm{postfix-expression} and in the scope of the class of
the object expression. If the name is found only in the scope of the
class of the object expression, the name shall refer to a
\grammarterm{class-name}. If the name is found only in the context of the
entire \grammarterm{postfix-expression}, the name shall refer to a
\grammarterm{class-name} or \grammarterm{namespace-name}. If the name is
found in both contexts, the \grammarterm{class-name-or-namespace-name}
shall refer to the same entity. \enternote the result of looking up the
\grammarterm{class-name-or-namespace-name} is not required to be a unique
base class of the class type of the object expression, as long as the
entity or entities named by the \grammarterm{qualified-id} are members
of the class type of the object expression and are not ambiguous
according to~\ref{class.member.lookup}.

\begin{codeblock}
struct A {
	int a;
};
struct B: virtual A { };
struct C: B { };
struct D: B { };
struct E: public C, public D { };
struct F: public A { };

void f() {
	E e;
	e.B::a = 0;		// OK, only one \tcode{A::a} in \tcode{E}

	F f;
	f.A::a = 1;		// OK, \tcode{A::a} is a member of \tcode{F}
}
\end{codeblock}

\exitnoteb

\pnum
If the \grammarterm{qualified-id} has the form

\begin{indented}
\tcode{::class-name-or-namespace-name::...}
\end{indented}

the \grammarterm{class-name-or-namespace-name} is looked up in global scope
as a \grammarterm{class-name} or \grammarterm{namespace-name}.

\pnum
If the \grammarterm{nested-name-specifier} contains a class
\grammarterm{template-id}~(\ref{temp.names}), its
\grammarterm{template-argument}{s} are evaluated in the context in which the
entire \grammarterm{postfix-expression} occurs.

\pnum
If the \grammarterm{id-expression} is a \grammarterm{conversion-function-id},
its \grammarterm{conversion-type-id} shall denote the same type in both
the context in which the entire \grammarterm{postfix-expression} occurs
and in the context of the class of the object expression (or the class
pointed to by the pointer expression).

\rSec2[basic.lookup.udir]{Using-directives and namespace aliases}

\pnum
\indextext{lookup!using-directives~and}%
\indextext{lookup!namespace~aliases~and}%
When looking up a \grammarterm{namespace-name} in a
\grammarterm{using-directive} or \grammarterm{namespace-alias-definition},
only namespace names are considered.%
\indextext{lookup!name|)}%
\indextext{scope!name~lookup~and|)}

\rSec1[basic.link]{Program and linkage}%
\indextext{linkage|(}

\pnum
\indextext{program}%
A \defn{program} consists of one or more \defn{translation
units} (clause~\ref{lex}) linked together. A translation unit consists
of a sequence of declarations.

\begin{bnf}
\nontermdef{translation-unit}\br
    declaration-seq\opt
\end{bnf}

\pnum
\indextext{linkage}%
\indextext{translation~unit}%
\indextext{linkage!internal}%
\indextext{linkage!external}%
A name is said to have \defn{linkage} when it might denote the same
object, reference, function, type, template, namespace or value as a
name introduced by a declaration in another scope:

\begin{itemize}
\item When a name has \defn{external linkage}\indextext{linkage!external},
the entity it denotes
can be referred to by names from scopes of other translation units or
from other scopes of the same translation unit.

\item When a name has \defn{internal linkage}\indextext{linkage!internal},
the entity it denotes
can be referred to by names from other scopes in the same translation
unit.

\item When a name has \defn{no linkage}\indextext{linkage!no}, the entity it denotes
cannot be referred to by names from other scopes.
\end{itemize}

\pnum
\indextext{linkage!\idxcode{static}~and}%
\indextext{\idxcode{static}!linkage~of}%
\indextext{linkage!\idxcode{const}~and}%
\indextext{\idxcode{const}!linkage~of}%
\indextext{linkage!\idxcode{inline}~and}%
\indextext{\idxcode{inline}!linkage~of}%
A name having namespace scope~(\ref{basic.scope.namespace}) has internal
linkage if it is the name of

\begin{itemize}
\item an object, reference, function or function template that is
explicitly declared \tcode{static} or,

\item an object or reference that is explicitly declared \tcode{const}
and neither explicitly declared \tcode{extern} nor previously declared
to have external linkage; or

\item a data member of an anonymous union.
\end{itemize}

\pnum
A name having namespace scope has external linkage if it is the name of

\begin{itemize}
\item an object or reference, unless it has internal linkage; or

\item a function, unless it has internal linkage; or

\item \indextext{class!linkage~of}%
a named class (clause~\ref{class}), or an unnamed class defined in a
typedef declaration in which the class has the typedef name for linkage
purposes~(\ref{dcl.typedef}); or

\item \indextext{enumeration!linkage~of}%
a named enumeration~(\ref{dcl.enum}), or an unnamed enumeration defined
in a typedef declaration in which the enumeration has the typedef name
for linkage purposes~(\ref{dcl.typedef}); or

\item an enumerator belonging to an enumeration with external linkage; or

\item a template, unless it is a function template that has internal
linkage (clause~\ref{temp}); or

\item a namespace~(\ref{basic.namespace}), unless it is declared within
an unnamed namespace.
\end{itemize}

\pnum
In addition, a member function, static data member, class or
enumeration of class scope has
external linkage if the name of the class has external linkage.

\pnum
The name of a function declared in block scope, and the name of an object declared by a
block scope \tcode{extern} declaration, have linkage. If there is a visible declaration
of an entity with linkage having the same name and type, ignoring entities declared
outside the innermost enclosing namespace scope, the block scope declaration declares
that same entity and receives the linkage of the previous declaration. If there is more
than one such matching entity, the program is ill-formed. Otherwise, if no matching
entity is found, the block scope entity receives external linkage.\\
\enterexample

\begin{codeblock}
static void f();
static int i = 0;			// 1
void g() {
	extern void f();		// internal linkage
	int i;				// 2: \tcode{i} has no linkage
	{
		extern void f();        // internal linkage
		extern int i;           // 3: external linkage
	}
}
\end{codeblock}

There are three objects named \tcode{i} in this program. The object with
internal linkage introduced by the declaration in global scope (line
\tcode{//1}), the object with automatic storage duration and no linkage
introduced by the declaration on line \tcode{//2}, and the object with
static storage duration and external linkage introduced by the
declaration on line \tcode{//3}. \exitexample

\pnum
When a block scope declaration of an entity with linkage is not found to
refer to some other declaration, then that entity is a member of the
innermost enclosing namespace. However such a declaration does not
introduce the member name in its namespace scope. \enterexample

\begin{codeblock}
namespace X {
	void p()
	{
		q();                    // error: \tcode{q} not yet declared
		extern void q();        // \tcode{q} is a member of namespace \tcode{X}
	}

	void middle()
	{
		q();                    // error: \tcode{q} not yet declared
	}

	void q() @\tcode{\{ /* ... */ \}}@         // definition of \tcode{X::q}        
}

void q() @\tcode{\{ /* ... */ \}}@		  // some other, unrelated \tcode{q}
\end{codeblock}
\exitexampleb

\pnum
\indextext{linkage!no}%
Names not covered by these rules have no linkage. Moreover, except as
noted, a name declared in a local scope~(\ref{basic.scope.local}) has no
linkage. A name with no linkage (notably, the name of a class or
enumeration declared in a local scope~(\ref{basic.scope.local})) shall
not be used to declare an entity with linkage. If a declaration uses
a typedef name, it is the linkage of the type name to which the typedef
refers that is considered. \enterexample

\begin{codeblock}
void f()
{
    struct A { int x; };	// no linkage
    extern A a;			// ill-formed
    typedef A B;
    extern B b;			// ill-formed
}
\end{codeblock}

\exitexampleb This implies that names with no linkage cannot be used
as template arguments~(\ref{temp.names}).

\pnum
Two names that are the same (clause~\ref{basic}) and that are declared
in different scopes shall denote the same object, reference, function,
type, enumerator, template or namespace if

\begin{itemize}
\item both names have external linkage or else both names have internal
linkage and are declared in the same translation unit; and

\item both names refer to members of the same namespace or to members,
not by inheritance, of the same class; and

\item when both names denote functions, the function types are identical
for purposes of overloading; and

\item when both names denote function templates, the
signatures~(\ref{temp.over.link}) are the same.
\end{itemize}

\pnum
\indextext{consistency!type declaration}%
\indextext{declaration!multiple}%
After all adjustments of types (during which
typedefs~(\ref{dcl.typedef}) are replaced by their definitions), the
types specified by all declarations referring to a given object or
function shall be identical, except that declarations for an array
object can specify array types that differ by the presence or absence of
a major array bound~(\ref{dcl.array}). A violation of this rule on type
identity does not require a diagnostic.

\pnum
\enternote linkage to non-\Cpp declarations can be achieved using a
\grammarterm{linkage-specification}~(\ref{dcl.link}). \exitnote%
\indextext{linkage|)}

\rSec1[basic.start]{Start and termination}

\rSec2[basic.start.main]{Main function}

\pnum
\indextext{program!start|(}%
\indextext{\idxcode{main()}}%
A program shall contain a global function called \tcode{main}, which is the designated
start of the program. It is \impldef{defining \tcode{main} in freestanding environment}
whether a program in a freestanding environment is required to define a \tcode{main}
function. \enternote in a freestanding environment, start-up and termination is
\impldef{start-up and termination in freestanding environment}; start-up contains the
execution of constructors for objects of namespace scope with static storage duration;
termination contains the execution of destructors for objects with static storage
duration. \exitnote

\pnum
An implementation shall not predefine the \tcode{main} function. This
function shall not be overloaded. It shall have a return type of type
\tcode{int}, but otherwise its type is \impldef{parameters to \tcode{main}}.
\indextext{\idxcode{main()}!implementation-defined parameters~to}%
All implementations shall allow both of the following definitions of
\tcode{main}:

\begin{codeblock}
int main() @\tcode{\{ /* ... */ \}}@
\end{codeblock}

and

\indextext{\idxcode{argc}}%
\indextext{\idxcode{argv}}%
\begin{codeblock}
int main(int argc, char* argv[]) @\tcode{\{ /* ... */ \}}@
\end{codeblock}

\indextext{\idxcode{main()}!parameters~to}%
\indextext{environment!program}%
In the latter form \tcode{argc} shall be the number of arguments passed
to the program from the environment in which the program is run. If
\tcode{argc} is nonzero these arguments shall be supplied in
\tcode{argv[0]} through \tcode{argv[argc-1]} as pointers to the initial
characters of null-terminated multibyte strings (\ntmbs%
s)~(\ref{lib.multibyte.strings}) and \tcode{argv[0]} shall be the pointer to
the initial character of a \ntmbs that represents the name used to
invoke the program or \tcode{""}. The value of \tcode{argc} shall be
nonnegative. The value of \tcode{argv[argc]} shall be 0. \enternote it
is recommended that any further (optional) parameters be added after
\tcode{argv}. \exitnote

\pnum
The function \tcode{main} shall not be used~(\ref{basic.def.odr}) within
a program.
\indextext{\idxcode{main()}!implementation-defined linkage~of}%
The linkage~(\ref{basic.link}) of \tcode{main} is
\impldef{linkage of \tcode{main}}. A program that declares \tcode{main} to be
\tcode{inline} or \tcode{static} is ill-formed. The name \tcode{main} is
not otherwise reserved. \enterexample member functions, classes, and
enumerations can be called \tcode{main}, as can entities in other
namespaces. \exitexample

\pnum
\indextext{\idxcode{exit}}%
\indexlibrary{\idxcode{exit}}%
\indextext{termination!program}%
Calling the function

\begin{codeblock}
void exit(int);
\end{codeblock}

declared in \tcode{<cstdlib>}~(\ref{lib.support.start.term}) terminates
the program
without leaving the current block and hence without destroying any
objects with automatic storage duration~(\ref{class.dtor}). If
\tcode{exit} is called to end a program during the destruction of
an object with static storage duration, the program has undefined
behavior.

\pnum
\indextext{termination!program}%
\indextext{\idxcode{main()}!return from}%
A return statement in \tcode{main} has the effect of leaving the main
function (destroying any objects with automatic storage duration) and
calling \tcode{exit} with the return value as the argument. If
control reaches the end of \tcode{main} without encountering a
\tcode{return} statement, the effect is that of executing

\begin{codeblock}
return 0;
\end{codeblock}

\rSec2[basic.start.init]{Initialization of non-local variables}

\pnum
\indextext{initialization!\idxcode{static object}}%
\indextext{initialization!dynamic}%
\indextext{initialization!run-time}%
\indextext{start!program}%
\indextext{initialization!order~of}%
Objects with static storage duration~(\ref{basic.stc.static})
shall be zero-initialized~(\ref{dcl.init}) before
any other initialization takes place.
\indextext{initialization!constant}%
Zero-initialization and initialization with a constant expression
are collectively called \defn{static
initialization}; all other initialization is \defn{dynamic initialization}.
Objects of POD types~(\ref{basic.types}) with static storage duration
initialized with constant expressions~(\ref{expr.const}) shall be
initialized before any dynamic initialization takes place. Objects with
static storage duration defined in namespace scope in the same translation
unit and dynamically initialized shall be initialized in the order in which
their definition appears in the translation unit.
\enternote \ref{dcl.init.aggr} describes the order in which aggregate
members are initialized. The initialization of local static objects
is described in~\ref{stmt.dcl}. \exitnote

\pnum
An implementation is permitted to perform the initialization of an
object of namespace scope with static storage duration as a static
initialization even if such initialization is not required to be done
statically, provided that

\begin{itemize}
\item
the dynamic version of the initialization does not change the
value of any other object of namespace scope with static storage
duration prior to its initialization, and

\item
the static version of the initialization produces the same value
in the initialized object as would be produced by the dynamic
initialization if all objects not required to be initialized statically
were initialized dynamically.
\end{itemize}

% \item
\enternote as a consequence, if the initialization of an object \tcode{obj1} refers to an
object \tcode{obj2} of namespace scope with static storage duration
potentially requiring dynamic initialization and defined
later in the same translation unit, it is unspecified whether the value of \tcode{obj2} used
will be the value of the fully initialized \tcode{obj2} (because \tcode{obj2} was statically
initialized) or will be the value of \tcode{obj2} merely zero-initialized. For example,

\begin{codeblock}
inline double fd() { return 1.0; }
extern double d1;
double d2 = d1;			// unspecified:
				// may be statically initialized to \tcode{0.0} or
				// dynamically initialized to \tcode{1.0}
double d1 = fd();		// may be initialized statically to \tcode{1.0}
\end{codeblock}
\exitnoteb

\pnum
\indextext{evaluation!unspecified order~of}%
It is \impldef{dynamic initialization of static objects before \tcode{main}} whether or not the
dynamic initialization (\ref{dcl.init}, \ref{class.static}, \ref{class.ctor},
\ref{class.expl.init}) of an object of namespace scope is
done before the first statement of \tcode{main}. If the initialization is deferred to
some point in time after the first statement of \tcode{main}, it shall occur before the
first use of any function or object
defined in the same translation unit as the object
to be initialized.\footnote{An object defined in namespace scope
having initialization
with side-effects must be initialized even if it is not
used~(\ref{basic.stc.static}).}
\enterexample 

\begin{codeblock}
// - File 1 -
#include "a.h"
#include "b.h"
B b;
A::A(){
	b.Use();
}

// - File 2 -
#include "a.h"
A a;

// - File 3 -
#include "a.h"
#include "b.h"
extern A a;
extern B b;

int main() {
	a.Use();
	b.Use();
}
\end{codeblock}

It is implementation-defined whether either \tcode{a} or \tcode{b} is
initialized before \tcode{main} is entered or whether the
initializations are delayed until \tcode{a} is first used in
\tcode{main}. In particular, if \tcode{a} is initialized before
\tcode{main} is entered, it is not guaranteed that \tcode{b} will be
initialized before it is used by the initialization of \tcode{a}, that
is, before \tcode{A::A} is called. If, however, \tcode{a} is initialized
at some point after the first statement of \tcode{main}, \tcode{b} will
be initialized prior to its use in \tcode{A::A}. \exitexample

\pnum
If construction or destruction of a non-local static object ends
in throwing an uncaught exception, the result is to call
\tcode{terminate}~(\ref{lib.terminate}).%
\indextext{program!start|)}

\rSec2[basic.start.term]{Termination}

\pnum
\indextext{program!termination|(}%
\indextext{object!destructor static}%
\indextext{\idxcode{main()}!return from}%
Destructors~(\ref{class.dtor}) for initialized objects
of static storage duration (declared at block scope or at namespace scope)
are called as a result of returning from \tcode{main} and as a result of calling
\indextext{\idxcode{exit}}%
\indexlibrary{\idxcode{exit}}%
\tcode{exit}~(\ref{lib.support.start.term}).
These objects are destroyed in the reverse order of the completion of
their constructor or of the completion of their dynamic initialization.
If an object is
initialized statically, the object is destroyed in the same order as if
the object was dynamically initialized. For an object of array or class
type, all subobjects of that object are destroyed before any local
object with static storage duration initialized during the construction
of the subobjects is destroyed.

\pnum
If a function contains a local object of static storage duration that has been
destroyed and the function is called during the destruction of an object with static
storage duration, the program has undefined behavior if the flow of control
passes through the definition of the previously destroyed local object.

\pnum
\indextext{\idxcode{atexit}}%
\indexlibrary{\idxcode{atexit}}%
If a function is registered with \tcode{atexit}~(see
\tcode{<cstdlib>},~\ref{lib.support.start.term}), then following the call to
\tcode{exit}, any objects with static storage duration initialized prior
to the registration of that function shall not be destroyed until the
registered function is called from the termination process and has
completed. For an object with static storage duration constructed after
a function is registered with \tcode{atexit}, then following the
call to \tcode{exit}, the registered function is not called until the
execution of the object's destructor has completed. If \tcode{atexit}
is called during the construction of an object, the complete object to
which it belongs shall be destroyed before the registered function is called.

\pnum
\indextext{\idxcode{abort}}%
\indexlibrary{\idxcode{abort}}%
\indextext{termination!program}%
Calling the function

\begin{codeblock}
void abort();
\end{codeblock}

declared in
\indextext{\idxhdr{cstdlib}}%
\tcode{<cstdlib>} terminates the program without executing destructors
for objects of automatic or static storage duration and without calling
the functions passed to \tcode{atexit()}.%
\indextext{program!termination|)}

\rSec1[basic.stc]{Storage duration}

\pnum
\indextext{storage~duration|(}%
Storage duration is the property of an object that defines the minimum
potential lifetime of the storage containing the object. The storage
duration is determined by the construct used to create the object and is
one of the following:

\begin{itemize}
\item static storage duration
\item automatic storage duration
\item dynamic storage duration
\end{itemize}

\pnum
\indextext{storage~duration!static}%
\indextext{storage~duration!automatic}%
\indextext{storage~duration!dynamic}%
Static and automatic storage durations are associated with objects
introduced by declarations~(\ref{basic.def}) and implicitly created by
the implementation~(\ref{class.temporary}). The dynamic storage duration
is associated with objects created with \tcode{operator}
\tcode{new}~(\ref{expr.new}).

\pnum
The storage class specifiers \tcode{static} and \tcode{auto} are related
to storage duration as described below.

\pnum
The storage duration categories apply to references as well. The
lifetime of a reference is its storage duration.

\rSec2[basic.stc.static]{Static storage duration}

\pnum
\indextext{storage~duration!static}%
All objects which neither have dynamic storage duration nor are local
have \defn{static storage duration}. The
storage for these objects shall last for the duration of the
program~(\ref{basic.start.init}, \ref{basic.start.term}).

\pnum
If an object of static storage duration has initialization or a
destructor with side effects, it shall not be eliminated even if it
appears to be unused, except that a class object or its copy may be
eliminated as specified in~\ref{class.copy}.

\pnum
\indextext{object!\idxcode{local static}}%
The keyword \tcode{static} can be used to declare a local variable with
static storage duration. \enternote \ref{stmt.dcl} describes the
initialization of local \tcode{static} variables; \ref{basic.start.term}
describes the destruction of local \tcode{static} variables. \exitnote

\pnum
\indextext{member!\idxcode{class static}}%
The keyword \tcode{static} applied to a class data member in a class
definition gives the data member static storage duration.

\rSec2[basic.stc.auto]{Automatic storage duration}

\pnum
\indextext{storage~duration!automatic}%
\indextext{storage~duration!\idxcode{auto}}%
\indextext{storage~duration!\idxcode{register}}%
\indextext{storage~duration!local object}%
Local objects explicitly declared \tcode{auto} or \tcode{register} or
not explicitly declared \tcode{static} or \tcode{extern} have
\defn{automatic storage duration}. The storage
for these objects lasts until the block in which they are created exits.

\pnum
\enternote 
these objects are initialized and destroyed as described in~\ref{stmt.dcl}.
\exitnote 

\pnum
If a named automatic object has initialization or a destructor with side
effects, it shall not be destroyed before the end of its block, nor
shall it be eliminated as an optimization even if it appears to be
unused, except that a class object or its copy may be eliminated as
specified in~\ref{class.copy}.

\rSec2[basic.stc.dynamic]{Dynamic storage duration}%
\indextext{storage~duration!dynamic|(}

\pnum
Objects can be created dynamically during program
execution~(\ref{intro.execution}), using
\indextext{\idxcode{new}}%
\grammarterm{new-expression}{s}~(\ref{expr.new}), and destroyed using
\indextext{\idxcode{delete}}%
\grammarterm{delete-expression}{s}~(\ref{expr.delete}). A \Cpp implementation
provides access to, and management of, dynamic storage via the global
\defn{allocation functions} \tcode{operator new} and \tcode{operator
new[]} and the global \defn{deallocation functions} \tcode{operator
delete} and \tcode{operator delete[]}.

\pnum
The library provides default definitions for the global allocation and
deallocation functions. Some global allocation and deallocation
functions are replaceable~(\ref{lib.new.delete}). A \Cpp program shall
provide at most one definition of a replaceable allocation or
deallocation function. Any such function definition replaces the default
version provided in the library~(\ref{lib.replacement.functions}). The
following allocation and deallocation functions~(\ref{lib.support.dynamic})
are implicitly declared in global scope in each translation unit of a
program.

\begin{codeblock}
void* operator new(std::size_t) throw(std::bad_alloc);
void* operator new[](std::size_t) throw(std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
\end{codeblock}

These implicit declarations introduce only the function names
\tcode{operator} \tcode{new}, \tcode{operator} \tcode{new[]},
\tcode{op\-er\-a\-tor} \tcode{delete}, \tcode{operator}
\tcode{delete[]}. \enternote the implicit declarations do not introduce
the names \tcode{std}, \tcode{std::bad_alloc}, and
\tcode{std\colcol{}size_t}, or any other names that the library uses to
declare these names. Thus, a \grammarterm{new-expression},
\grammarterm{delete-expression} or function call that refers to one of
these functions without including the header \tcode{<new>} is
well-formed. However, referring to \tcode{std}, \tcode{std::bad_alloc},
and \tcode{std::size_t} is ill-formed unless the name has been declared
by including the appropriate header. \exitnote Allocation and/or
deallocation functions can also be declared and defined for any
class~(\ref{class.free}).

\pnum
Any allocation and/or deallocation functions defined in a \Cpp program,
including the default versions in the library, shall conform to the
semantics specified in~\ref{basic.stc.dynamic.allocation}
and~\ref{basic.stc.dynamic.deallocation}.

\rSec3[basic.stc.dynamic.allocation]{Allocation functions}

\pnum
\indextext{function!allocation}%
An allocation function shall be a class member function or a global
function; a program is ill-formed if an allocation function is declared
in a namespace scope other than global scope or declared static in
global scope. The return type shall be \tcode{void*}. The first
parameter shall have type \tcode{size_t}~(\ref{lib.support.types}). The
first parameter shall not have an associated default
argument~(\ref{dcl.fct.default}). The value of the first parameter shall
be interpreted as the requested size of the allocation. An allocation
function can be a function template. Such a template shall declare its
return type and first parameter as specified above (that is, template
parameter types shall not be used in the return type and first parameter
type). Template allocation functions shall have two or more parameters.

\pnum
The allocation function attempts to allocate the requested amount of
storage. If it is successful, it shall return the address of the start
of a block of storage whose length in bytes shall be at least as large
as the requested size. There are no constraints on the contents of the
allocated storage on return from the allocation function. The order,
contiguity, and initial value of storage allocated by successive calls
to an allocation function are unspecified. The pointer returned shall be
suitably aligned so that it can be converted to a pointer of any
complete object type and then used to access the object or array in the
storage allocated (until the storage is explicitly deallocated by a call
to a corresponding deallocation function). Even if the size of the space
requested is zero, the request can fail. If the request succeeds, the
value returned shall be a non-null pointer value~(\ref{conv.ptr})
\tcode{p0} different from any previously returned value \tcode{p1},
unless that value \tcode{p1} was subsequently passed to an
\tcode{operator} \tcode{delete}. The effect of dereferencing a pointer
returned as a request for zero size is undefined.\footnote{The intent is
to have \tcode{operator new()} implementable by
calling \tcode{malloc()} or \tcode{calloc()}, so the rules are
substantially the same. \Cpp differs from C in requiring a zero request
to return a non-null pointer.}

\pnum
An allocation function that fails to allocate storage can invoke the
currently installed \tcode{new_handler}~(\ref{lib.new.handler}), if any.
\enternote
\indextext{\idxcode{new_handler}}%
A program-supplied allocation function can obtain the address of the
currently installed \tcode{new_handler} using the
\tcode{get_new_handler} function~(\ref{lib.set.new.handler}). \exitnote
If an allocation function declared with an empty
\grammarterm{exception-specification}~(\ref{except.spec}), \tcode{throw()},
fails to allocate storage, it shall return a null pointer. Any other
allocation function that fails to allocate storage shall only indicate
failure by throwing an exception of class
\tcode{std::bad_alloc}~(\ref{lib.bad.alloc}) or a class derived from
\tcode{std::bad_alloc}.

\pnum
A global allocation function is only called as the result of a new
expression~(\ref{expr.new}), or called directly using the function call
syntax~(\ref{expr.call}), or called indirectly through calls to the
functions in the \Cpp standard library. \enternote in particular, a
global allocation function is not called to allocate storage for objects
with static storage duration~(\ref{basic.stc.static}), for objects of
type \tcode{type_info}~(\ref{expr.typeid}), for the copy of an
object thrown by a \tcode{throw} expression~(\ref{except.throw}).
\exitnote

\rSec3[basic.stc.dynamic.deallocation]{Deallocation functions}

\pnum
\indextext{function!deallocation}%
Deallocation functions shall be class member functions or global
functions; a program is ill-formed if deallocation functions are
declared in a namespace scope other than global scope or declared static
in global scope.

\pnum
\indextext{\idxcode{delete}!overloading~and}%
Each deallocation function shall return \tcode{void} and its first
parameter shall be \tcode{void*}. A deallocation function can have more
than one parameter. If a class \tcode{T} has a member deallocation
function named \tcode{operator} \tcode{delete} with exactly one
parameter, then that function is a usual (non-placement) deallocation
function. If class \tcode{T} does not declare such an \tcode{operator}
\tcode{delete} but does declare a member deallocation function named
\tcode{operator} \tcode{delete} with exactly two parameters, the second
of which has type \tcode{std::size_t}~(\ref{lib.support.types}), then this
function is a usual deallocation function. Similarly, if a class
\tcode{T} has a member deallocation function named \tcode{operator}
\tcode{delete[]} with exactly one parameter, then that function is a
usual (non-placement) deallocation function. If class \tcode{T} does not
declare such an \tcode{operator} \tcode{delete[]} but does declare a
member deallocation function named \tcode{operator} \tcode{delete[]}
with exactly two parameters, the second of which has type
\tcode{std::size_t}, then this function is a usual deallocation
function. A deallocation function can be an instance of a function
template. Neither the first parameter nor the return type shall depend
on a template parameter. \enternote that is, a deallocation function
template shall have a first parameter of type \tcode{void*} and a return
type of \tcode{void} (as specified above). \exitnote A deallocation
function template shall have two or more function parameters. A template
instance is never a usual deallocation function, regardless of its
signature.

\pnum
The value of the first argument supplied to one of the deallocation
functions provided in the standard library may
be a null pointer value; if so, the call to the deallocation function
has no effect. Otherwise, the
value supplied to \tcode{operator} \tcode{delete(void*)} in the standard
library shall be one of the values returned by a previous invocation of
either \tcode{operator} \tcode{new(size_t)} or \tcode{operator}
\tcode{new(size_t,} \tcode{const} \tcode{std::nothrow_t\&)} in the
standard library, and the value supplied to \tcode{operator}
\tcode{delete[](void*)} in the standard library shall be one of the
values returned by a previous invocation of either \tcode{operator}
\tcode{new[](size_t)} or \tcode{operator}
\tcode{new[](size_t,} \tcode{const} \tcode{std::nothrow_t\&)} in
the standard library.

\pnum
If the argument given to a deallocation function in the standard library
is a pointer that is not the null pointer value~(\ref{conv.ptr}), the
deallocation function shall deallocate the storage referenced by the
pointer, rendering invalid all pointers referring to any part of the
\term{deallocated storage}.
\indextext{object!undefined deleted}%
The effect of using an invalid pointer value (including
passing it to a deallocation function) is undefined.\footnote{On some
implementations, it causes a system-generated runtime
fault.}

\rSec2[basic.stc.inherit]{Duration of subobjects}

\pnum
\indextext{storage~duration!class member}%
The storage duration of member subobjects, base class subobjects and
array elements is that of their complete object~(\ref{intro.object}).
\indextext{storage~duration|)}%

\rSec1[basic.life]{Object lifetime}

\pnum
\indextext{object~lifetime|(}%
The \defn{lifetime} of an object is a runtime property of the
object. The lifetime of an object of type \tcode{T} begins when:

\begin{itemize}
\item storage with the proper alignment and size for type \tcode{T} is
obtained, and

\item if \tcode{T} is a class type with a non-trivial
constructor~(\ref{class.ctor}), the constructor call has completed.
\end{itemize}

The lifetime of an object of type \tcode{T} ends when:

\begin{itemize}
\item if \tcode{T} is a class type with a non-trivial
destructor~(\ref{class.dtor}), the destructor call starts, or

\item the storage which the object occupies is reused or released.
\end{itemize}

\pnum
\enternote the lifetime of an array object or of an object of POD
type~(\ref{basic.types}) starts as soon as storage with proper size and
alignment is obtained, and its lifetime ends when the storage which the
array or object occupies is reused or released. \ref{class.base.init}
describes the lifetime of base and member subobjects. \exitnote

\pnum
The properties ascribed to objects throughout this International
Standard apply for a given object only during its lifetime. \enternote
in particular, before the lifetime of an object starts and after its
lifetime ends there are significant restrictions on the use of the
object, as described below, in~\ref{class.base.init} and
in~\ref{class.cdtor}. Also, the behavior of an object under construction
and destruction might not be the same as the behavior of an object whose
lifetime has started and not ended. \ref{class.base.init}
and~\ref{class.cdtor} describe the behavior of objects during the
construction and destruction phases. \exitnote

\pnum
A program may end the lifetime of any object by reusing the storage
which the object occupies or by explicitly calling the destructor for an
object of a class type with a non-trivial destructor. For an object of a
class type with a non-trivial destructor, the program is not required to
call the destructor explicitly before the storage which the object
occupies is reused or released; however, if there is no explicit call to
the destructor or if a \grammarterm{delete-expression}~(\ref{expr.delete})
is not used to release the storage, the destructor shall not be
implicitly called and any program that depends on the side effects
produced by the destructor has undefined behavior.

\pnum
Before the lifetime of an object has started but after the storage which
the object will occupy has been allocated\footnote{For example, before the
construction of a global object of
non-POD class type~(\ref{class.cdtor}).}
or, after the lifetime of an object has ended and before the storage
which the object occupied is reused or released, any pointer that refers
to the storage location where the object will be or was located may be
used but only in limited ways. Such a pointer refers to allocated
storage~(\ref{basic.stc.dynamic.deallocation}), and using the pointer as
if the pointer were of type \tcode{void*}, is well-defined. Such a
pointer may be dereferenced but the resulting lvalue may only be used in
limited ways, as described below. If the object will be or was of a
class type with a non-trivial destructor, and the pointer is used as the
operand of a \grammarterm{delete-expression}, the program has undefined
behavior. If the object will be or was of a non-POD class type, the
program has undefined behavior if:

\begin{itemize}
\item the pointer is used to access a non-static data member or call a
non-static member function of the object, or

\item the pointer is implicitly converted~(\ref{conv.ptr}) to a pointer
to a base class type, or

\item the pointer is used as the operand of a
\tcode{static_cast}~(\ref{expr.static.cast}) (except when the conversion
is to \tcode{void*}, or to \tcode{void*} and subsequently to
\tcode{char*}, or \tcode{unsigned} \tcode{char*}).

\item the pointer is used as the operand of a
\tcode{dynamic_cast}~(\ref{expr.dynamic.cast}). \enterexample

\begin{codeblock}
struct B {
	virtual void f();
	void mutate();
	virtual ~B();
};

struct D1 : B { void f(); };
struct D2 : B { void f(); };

void B::mutate() {
	new (this) D2;		// reuses storage --- ends the lifetime of \tcode{*this}
	f();			// undefined behavior
	... = this;		// OK, \tcode{this} points to valid memory
}

void g() {
	void* p = malloc(sizeof(D1) + sizeof(D2));
	B* pb = new (p) D1;
	pb->mutate();
	&pb;			// OK: \tcode{pb} points to valid memory
	void* q = pb;		// OK: \tcode{pb} points to valid memory
	pb->f();		// undefined behavior, lifetime of \tcode{*pb} has ended
}
\end{codeblock}
\exitexampleb
\end{itemize}

\pnum
Similarly, before the lifetime of an object has started but after the
storage which the object will occupy has been allocated or, after the
lifetime of an object has ended and before the storage which the object
occupied is reused or released, any lvalue which refers to the original
object may be used but only in limited ways. Such an lvalue refers to
allocated storage~(\ref{basic.stc.dynamic.deallocation}), and using the
properties of the lvalue which do not depend on its value is
well-defined. If an lvalue-to-rvalue conversion~(\ref{conv.lval}) is
applied to such an lvalue, the program has undefined behavior; if the
original object will be or was of a non-POD class type, the program
has undefined behavior if:

\begin{itemize}
\item the lvalue is used to access a non-static data member or call a
non-static member function of the object, or

\item the lvalue is implicitly converted~(\ref{conv.ptr}) to a reference
to a base class type, or

\item the lvalue is used as the operand of a
\tcode{static_cast}~(\ref{expr.static.cast}) (except when the conversion
is ultimately to \tcode{char\&} or \tcode{unsigned} \tcode{char\&}), or

\item the lvalue is used as the operand of a
\tcode{dynamic_cast}~(\ref{expr.dynamic.cast}) or as the operand of
\tcode{typeid}.
\end{itemize}

\pnum
If, after the lifetime of an object has ended and before the storage
which the object occupied is reused or released, a new object is created
at the storage location which the original object occupied, a pointer
that pointed to the original object, a reference that referred to the
original object, or the name of the original object will automatically
refer to the new object and, once the lifetime of the new object has
started, can be used to manipulate the new object, if:

\begin{itemize}
\item the storage for the new object exactly overlays the storage
location which the original object occupied, and

\item the new object is of the same type as the original object
(ignoring the top-level cv-qualifiers), and

\item the type of the original object is not const-qualified, and, if a
class type, does not contain any non-static data member whose type is
const-qualified or a reference type, and

\item the original object was a most derived object~(\ref{intro.object})
of type \tcode{T} and the new object is a most derived object of type
\tcode{T} (that is, they are not base class subobjects). \enterexample

\begin{codeblock}
struct C {
	int i;
	void f();
	const C& operator=( const C& );
};

const C& C::operator=( const C& other)
{
	if ( this != &other ) {
		this->~C();             // lifetime of \tcode{*this} ends
		new (this) C(other);	// new object of type \tcode{C} created
		f();                    // well-defined
	}
	return *this;
}

C c1;
C c2;
c1 = c2;                        // well-defined
c1.f();                         // well-defined; \tcode{c1} refers to a new object of type \tcode{C}
\end{codeblock}

\exitexampleb
\end{itemize}

\pnum
If a program ends the lifetime of an object of type \tcode{T} with
static~(\ref{basic.stc.static}) or automatic~(\ref{basic.stc.auto})
storage duration and if \tcode{T} has a non-trivial destructor,\footnote{that
is, an object for which a destructor will be called
implicitly---either either upon exit from the block for an object with
automatic storage duration or upon exit from the program for an object
with static storage duration.}
the program must ensure that an object of the original type occupies
that same storage location when the implicit destructor call takes
place; otherwise the behavior of the program is undefined. This is true
even if the block is exited with an exception. \enterexample

\begin{codeblock}
class T { };
struct B {
	~B();
};

void h() {
	B b;
	new (&b) T;
}                               // undefined behavior at block exit
\end{codeblock}
\exitexampleb

\pnum
Creating a new object at the storage location that a \tcode{const}
object with static or automatic storage duration occupies or, at the
storage location that such a \tcode{const} object used to occupy before
its lifetime ended results in undefined behavior. \enterexample

\begin{codeblock}
struct B {
	B();
	~B();
};

const B b;

void h() {
	b.~B();
	new (&b) const B;	// undefined behavior
}
\end{codeblock}
\exitexampleb%
\indextext{object~lifetime|)}

\rSec1[basic.types]{Types}%
\indextext{type|(}

\pnum
\enternote
\ref{basic.types} and the subclauses thereof
impose requirements on implementations regarding the representation
of types.
There are two kinds of types: fundamental types and compound types.
Types describe objects (\ref{intro.object}),
references (\ref{dcl.ref}),
or functions (\ref{dcl.fct}).
\exitnote

\pnum
\indextext{object!byte~copying~and|(}%
\indextext{type!trivially~copyable}%
For any object (other than a base-class subobject) of POD type
\tcode{T}, whether or not the object holds a valid value of type
\tcode{T}, the underlying bytes~(\ref{intro.memory}) making up the
object can be copied into an array of \tcode{char} or \tcode{unsigned}
\tcode{char}.\footnote{By using, for example, the library
functions~(\ref{lib.headers}) \tcode{memcpy} or \tcode{memmove}.}
If the content of the array of \tcode{char} or \tcode{unsigned}
\tcode{char} is copied back into the object, the object shall
subsequently hold its original value. \enterexample

\begin{codeblock}
#define N sizeof(T)
char buf[N];
T obj;                          // \tcode{obj} initialized to its original value
memcpy(buf, &obj, N);		// between these two calls to \tcode{memcpy},
                                // \tcode{obj} might be modified
memcpy(&obj, buf, N);		// at this point, each subobject of \tcode{obj} of scalar type
                                // holds its original value
\end{codeblock}
\exitexampleb

\pnum
For any POD type \tcode{T}, if two pointers to \tcode{T} point to
distinct \tcode{T} objects \tcode{obj1} and \tcode{obj2}, where neither
\tcode{obj1} nor \tcode{obj2} is a base-class subobject, if the value of
\tcode{obj1} is copied into \tcode{obj2}, using the \tcode{memcpy}
library function, \tcode{obj2} shall subsequently hold the same value as
\tcode{obj1}. \enterexample

\begin{codeblock}
T* t1p;
T* t2p;
				// provided that \tcode{t2p} points to an initialized object ...
memcpy(t1p, t2p, sizeof(T));	// at this point, every subobject of POD type in \tcode{*t1p} contains
				// the same value as the corresponding subobject in \tcode{*t2p}
\end{codeblock}
\exitexampleb%
\indextext{object!byte~copying~and|)}

\pnum
The \defn{object representation}
\indextext{representation!object}%
of an object of type \tcode{T} is the
sequence of \term{N} \tcode{unsigned} \tcode{char} objects taken up
by the object of type \tcode{T}, where \term{N} equals
\tcode{sizeof(T)}. The
\indextext{representation!value}%
\defn{value representation}
of an object is the set of bits that hold
the value of type \tcode{T}. For POD types, the value representation is
a set of bits in the object representation that determines a
\defn{value}, which is one discrete element of an
\impldef{values of a trivially copyable type} set of values.\footnote{The
intent is that the memory model of \Cpp is compatible
with that of ISO/IEC 9899 Programming Language C.}

\pnum
Object types have
\indextext{requirements!alignment}%
\defn{alignment requirements}~(\ref{basic.fundamental}, \ref{basic.compound}).
The \defn{alignment} of a complete object type is an
\impldef{integer value representing alignment} integer value representing
a number of bytes; an object is allocated at an address that meets
the alignment requirements of its object type.

\pnum
\indextext{type!incomplete}%
A class that has been declared but not defined, or an array of unknown
size or of incomplete element type, is an incompletely-defined object
type.\footnote{The size and layout of an instance of an incompletely-defined
object type is unknown.}
Incompletely-defined object types and the void types are incomplete
types~(\ref{basic.fundamental}). Objects shall not be defined to have an
incomplete type.

\pnum
A class type (such as ``\tcode{class X}'') might be incomplete at one
point in a translation unit and complete later on; the type
``\tcode{class X}'' is the same type at both points. The declared type
of an array object might be an array of incomplete class type and
therefore incomplete; if the class type is completed later on in the
translation unit, the array type becomes complete; the array type at
those two points is the same type. The declared type of an array object
might be an array of unknown size and therefore be incomplete at one
point in a translation unit and complete later on; the array types at
those two points (``array of unknown bound of \tcode{T}'' and ``array of
N \tcode{T}'') are different types. The type of a pointer to array of
unknown size, or of a type defined by a \tcode{typedef} declaration to
be an array of unknown size, cannot be completed. \enterexample

\indextext{type!example~of incomplete}%
\begin{codeblock}
class X;                        // \tcode{X} is an incomplete type
extern X* xp;                   // \tcode{xp} is a pointer to an incomplete type
extern int arr[];               // the type of arr is incomplete
typedef int UNKA[];             // \tcode{UNKA} is an incomplete type
UNKA* arrp;                     // \tcode{arrp} is a pointer to an incomplete type
UNKA** arrpp;

void foo()
{
    xp++;                       // ill-formed: \tcode{X} is incomplete
    arrp++;                     // ill-formed: incomplete type
    arrpp++;                    // OK: sizeof \tcode{UNKA*} is known
}

struct X { int i; };            // now \tcode{X} is a complete type
int  arr[10];                   // now the type of \tcode{arr} is complete

X x;
void bar()
{
    xp = &x;                    // OK; type is ``pointer to \tcode{X}''
    arrp = &arr;                // ill-formed: different types
    xp++;                       // OK:  \tcode{X} is complete
    arrp++;                     // ill-formed: \tcode{UNKA} can't be completed
}
\end{codeblock}
\exitexampleb

\pnum
\enternote the rules for declarations and expressions describe in which
contexts incomplete types are prohibited. \exitnote

\pnum
\indextext{object~type}%
An \defn{object type} is a (possibly cv-qualified) type that is not
a function type, not a reference type, and not a void type.

\pnum
Arithmetic types~(\ref{basic.fundamental}), enumeration types, pointer
types, and pointer to member types~(\ref{basic.compound}), and
\grammarterm{cv-qualified} versions of these
types~(\ref{basic.type.qualifier}) are collectively called
\indextext{scalar~type}%
\term{scalar types}. Scalar types, POD struct types, POD-union types
(clause~\ref{class}), arrays of such types and
\grammarterm{cv-qualified} versions of these
types~(\ref{basic.type.qualifier}) are collectively called
\indextext{type!POD}%
\term{POD types}.

\pnum
\indextext{layout-compatible~type}%
If two types \tcode{T1} and \tcode{T2} are the same type, then
\tcode{T1} and \tcode{T2} are \grammarterm{layout-compatible} types.
\enternote Layout-compatible enumerations are described
in~\ref{dcl.enum}. Layout-compatible POD-structs and POD-unions are
described in~\ref{class.mem}. \exitnote

\rSec2[basic.fundamental]{Fundamental types}

\pnum
\indextext{type!fundamental}%
\indextext{type!integral}%
\indextext{type!floating point}%
\indextext{type!implementation-defined @\tcode{sizeof}}%
\indextext{type!Boolean}%
\indextext{type!\idxcode{char}}%
\indextext{type!character}%
Objects declared as characters (\tcode{char}) shall be large enough to
store any member of the implementation's basic character set. If a
character from this set is stored in a character object, the integral
value of that character object is equal to the value of the single
character literal form of that character. It is \impldef{signedness of \tcode{char}}
whether a \tcode{char} object can hold negative values.
\indextext{\idxcode{char}!implementation-defined sign~of}%
\indextext{type!\idxcode{signed char}}%
\indextext{type!\idxcode{unsigned char}}%
Characters can be explicitly declared \tcode{unsigned} or
\tcode{signed}.
\indextext{character!\idxcode{signed}}%
Plain \tcode{char}, \tcode{signed char}, and \tcode{unsigned char} are
three distinct types. A \tcode{char}, a \tcode{signed char}, and an
\tcode{unsigned char} occupy the same amount of storage and have the
same alignment requirements~(\ref{basic.types}); that is, they have the
same object representation. For character types, all bits of the object
representation participate in the value representation. For unsigned
character types, all possible bit patterns of the value representation
represent numbers. These requirements do not hold for other types. In
any particular implementation, a plain \tcode{char} object can take on
either the same values as a \tcode{signed char} or an \tcode{unsigned
char}; which one is \impldef{representation of \tcode{char}}.

\pnum
\indextext{type!signed~integer}%
\indextext{signed~integer~type}%
There are four \term{signed integer types} :
\indextext{type!\idxcode{signed char}}%
\indextext{type!\idxcode{short}}%
\indextext{type!\idxcode{int}}%
\indextext{type!\idxcode{long}}%
``\tcode{signed char}'', ``\tcode{short int}'', ``\tcode{int}'', and
``\tcode{long int}''. In
this list, each type provides at least as much storage as those
preceding it in the list.
\indextext{integral~type!implementation-defined @\tcode{sizeof}}%
Plain
\tcode{int}s have the natural size suggested by the architecture of the
execution environment\footnote{that is, large enough to contain any value in the range of
\tcode{INT_MIN} and \tcode{INT_MAX}, as defined in the header
\tcode{<climits>}.};
the other signed integer types are provided to meet special needs.

\pnum
\indextext{type!\idxcode{unsigned}}%
For each of the signed integer types,
there exists a corresponding (but different)
\indextext{type!unsigned~integer}%
\indextext{unsigned~integer~type}%
\term{unsigned integer type}:
\indextext{type!\idxcode{unsigned char}}%
\indextext{type!\idxcode{unsigned short}}%
\indextext{type!\idxcode{unsigned int}}%
\indextext{type!\idxcode{unsigned long}}%
``\tcode{unsigned char}'', ``\tcode{unsigned short int}'',
``\tcode{unsigned int}'', and ``\tcode{unsigned long int}'', each of
which occupies the same amount of storage and has the same alignment
requirements~(\ref{basic.types}) as the corresponding signed integer
type\footnote{See~\ref{dcl.type.simple} regarding the correspondence between types and
the sequences of \grammarterm{type-specifier}{s} that designate them.};
that is, each signed integer type has the same object representation as
its corresponding unsigned integer type. The range of nonnegative
values of a \term{signed integer} type is a subrange of the corresponding
\term{unsigned integer} type, and the value
representation of each corresponding signed/unsigned type shall be the
same.

\pnum
\indextext{arithmetic!\idxcode{unsigned}}%
Unsigned integers, declared \tcode{unsigned}, shall obey the laws of
arithmetic modulo $2^n$ where $n$ is the number of bits in the value
representation of that particular size of integer.\footnote{This implies that
unsigned arithmetic does not overflow because a result
that cannot be represented by the resulting unsigned integer type is
reduced modulo the number that is one greater than the largest value
that can be represented by the resulting unsigned integer type.}

\pnum
\indextext{\idxcode{wchar_t}!implementation-defined}%
\indextext{type!\idxcode{wchar_t}}%
\indextext{type!underlying wchar_t@underlying \tcode{wchar_t}}%
Type \tcode{wchar_t} is a distinct type whose values can represent
distinct codes for all members of the largest extended character set
specified among the supported locales~(\ref{lib.locale}). Type
\tcode{wchar_t} shall have the same size, signedness, and alignment
requirements~(\ref{basic.types}) as one of the other integral types,
called its \defn{underlying type}.

\pnum
\indextext{Boolean~type}%
Values of type \tcode{bool} are either \tcode{true} or
\tcode{false}.\footnote{Using a \tcode{bool} value in ways described by this International
Standard as ``undefined,'' such as by examining the value of an
uninitialized automatic variable, might cause it to behave as if it is
neither \tcode{true} nor \tcode{false}.}
\enternote there are no \tcode{signed}, \tcode{unsigned}, \tcode{short},
or \tcode{long bool} types or values. \exitnote As described below,
\tcode{bool} values behave as integral types. Values of type
\tcode{bool} participate in integral promotions~(\ref{conv.prom}).

\pnum
Types \tcode{bool}, \tcode{char},
\tcode{wchar_t}, and the signed and unsigned integer types are
collectively called
\indextext{integral~type}%
\term{integral} types.\footnote{Therefore, enumerations~(\ref{dcl.enum})
are not integral; however, enumerations can be promoted to
\tcode{int}, \tcode{unsigned int}, \tcode{long}, or \tcode{unsigned long}
as specified in~\ref{conv.prom}.}
A synonym for integral type is
\indextext{integer~type}%
\term{integer type}. The representations of integral types shall
define values by use of  a pure binary numeration system.\footnote{A positional
representation for integers that uses the binary digits 0
and 1, in which the values represented by successive bits are additive,
begin with 1, and are multiplied by successive integral power of 2,
except perhaps for the bit with the highest position. (Adapted from the
\doccite{American National Dictionary for Information Processing Systems}.)}
\enterexample this International Standard permits 2's complement, 1's
complement and signed magnitude representations for integral types.
\exitexample

\pnum
\indextext{floating~point~type}%
There are three \term{floating point} types:
\indextext{type!\idxcode{float}}%
\tcode{float},
\indextext{type!\idxcode{double}}%
\tcode{double},
and
\indextext{type!\idxcode{long double}}%
\tcode{long double}. The type \tcode{double} provides at least as much
precision as \tcode{float}, and the type \tcode{long double} provides at
least as much precision as \tcode{double}. The set of values of the type
\tcode{float} is a subset of the set of values of the type
\tcode{double}; the set of values of the type \tcode{double} is a subset
of the set of values of the type \tcode{long} \tcode{double}. The value
representation of floating-point types is \impldef{value representation of
floating-point types}.
\indextext{floating~point~type!implementation-defined}%
\indextext{type!arithmetic}%
\term{Integral} and \term{floating} types are collectively
called \term{arithmetic} types.
\indextext{\idxcode{numeric_limits}}%
Specializations of the standard template
\tcode{numeric_limits}~(\ref{lib.support.limits}) shall specify the
maximum and minimum values of each arithmetic type for an
implementation.

\pnum
\indextext{type!\idxcode{void}}%
The \tcode{void} type has an empty set of values. The \tcode{void} type
is an incomplete type that cannot be completed. It is used as the return
type for functions that do not return a value. Any expression can be
explicitly converted to type \term{cv}
\tcode{void}~(\ref{expr.cast}). An expression of type \tcode{void} shall
be used only as an expression statement~(\ref{stmt.expr}), as an operand
of a comma expression~(\ref{expr.comma}), as a second or third operand
of \tcode{?:}~(\ref{expr.cond}), as the operand of \tcode{typeid}, or as
the expression in a return statement~(\ref{stmt.return}) for a function
with the return type \tcode{void}.

\pnum
\enternote 
even if the implementation defines two or more basic types to have the
same value representation, they are nevertheless different types.
\exitnote 

\rSec2[basic.compound]{Compound types}

\pnum
\indextext{type!compound}%
Compound types can be constructed in the following ways:

\begin{itemize}
\item \indextext{type!array}%
\term{arrays} of objects of a given type,~\ref{dcl.array};

\item \indextext{type!function}%
\term{functions}, which have parameters of given types and return
\tcode{void} or references or objects of a given type,~\ref{dcl.fct};

\item \indextext{type!pointer}%
\term{pointers} to \tcode{void} or objects or functions (including
static members of classes) of a given type,~\ref{dcl.ptr};

\item %
\indextext{reference}%
\term{references} to objects or functions of a given type,~\ref{dcl.ref};

\item \indextext{class}%
\term{classes} containing a sequence of objects of various types
(clause~\ref{class}), a set of types, enumerations and functions for
manipulating these objects~(\ref{class.mfct}), and a set of restrictions
on the access to these entities (clause~\ref{class.access});

\item \indextext{\idxcode{union}}%
\term{unions}, which are classes capable of containing objects of
different types at different times,~\ref{class.union};

\item \indextext{\idxcode{enum}}%
\term{enumerations}, which comprise a set of named constant values.
Each distinct enumeration constitutes a different
\indextext{type!enumerated}%
\term{enumerated type},~\ref{dcl.enum};

\item \indextext{member~pointer~to|see{pointer to member}}%
\indextext{pointer~to~member}%
\term{pointers to non-static}
\footnote{Static class members are objects or functions, and pointers to them are
ordinary pointers to objects or functions.}
\term{class members}, which identify members of a given
type within objects of a given class,~\ref{dcl.mptr}.
\end{itemize}

\pnum
These methods of constructing types can be applied recursively;
restrictions are mentioned in~\ref{dcl.ptr}, \ref{dcl.array},
\ref{dcl.fct}, and~\ref{dcl.ref}.

\pnum
\indextext{terminology!pointer}%
A pointer to objects of type \tcode{T} is referred to as a ``pointer to
\tcode{T}.'' \enterexample a pointer to an object of type \tcode{int} is
referred to as ``pointer to \tcode{int} '' and a pointer to an object of
class \tcode{X} is called a ``pointer to \tcode{X}.'' \exitexample
Except for pointers to static members, text referring to ``pointers''
does not apply to pointers to members. Pointers to incomplete types are
allowed although there are restrictions on what can be done with
them~(\ref{basic.types}).
\indextext{address}%
A valid value of an object
pointer type represents either the address of a byte in
memory~(\ref{intro.memory}) or a null pointer~(\ref{conv.ptr}). If an
object of type \tcode{T} is located at an address \tcode{A}, a pointer
of type \term{cv} \tcode{T*} whose value is the address \tcode{A} is
said to \term{point to} that object, regardless of how the value was
obtained. \enternote for instance, the address one past the end of an
array~(\ref{expr.add}) would be considered to point to an unrelated
object of the array's element type that might be located at that
address. \exitnote The value representation of
pointer types is \impldef{value representation of pointer types}. Pointers to
cv-qualified and cv-unqualified
versions~(\ref{basic.type.qualifier}) of layout-compatible types shall
have the same value representation and alignment
requirements~(\ref{basic.types}).

\pnum
\indextext{pointer|seealso{\tcode{void*}}}%
\indextext{\idxcode{void*}!type}%
Objects of cv-qualified~(\ref{basic.type.qualifier}) or cv-unqualified
type \tcode{void*} (pointer to void), can be used to point to objects of
unknown type. A \tcode{void*} shall be able to hold any object pointer.
A cv-qualified or cv-unqualified~(\ref{basic.type.qualifier})
\tcode{void*} shall have the same representation and alignment
requirements as a cv-qualified or cv-unqualified \tcode{char*}.

\rSec2[basic.type.qualifier]{CV-qualifiers}

\pnum
\indextext{cv-qualifier}%
\indextext{\idxcode{const}}%
\indextext{\idxcode{volatile}}%
A type mentioned in~\ref{basic.fundamental} and~\ref{basic.compound} is
a \term{cv-unqualified type}. Each type which is a
cv-unqualified complete or incomplete object type or is
\tcode{void}~(\ref{basic.types}) has three corresponding cv-qualified
versions of its type: a \grammarterm{const-qualified} version, a
\term{volatile-qualified} version, and a
\term{const-volatile-qualified} version. The term
\term{object type}~(\ref{intro.object}) includes the cv-qualifiers
specified when the object is created. The presence of a \tcode{const}
specifier in a \grammarterm{decl-specifier-seq} declares an object of
\term{const-qualified object type}; such
object is called a \term{const object}. The presence of a
\tcode{volatile} specifier in a \grammarterm{decl-specifier-seq} declares
an object of \grammarterm{volatile-qualified} \term{object type}; such object
is called a \term{volatile object}. The presence of both \grammarterm{cv-qualifiers} in a
\grammarterm{decl-specifier-seq} declares an object of
\term{const-volatile-qualified object type};
such object is called a \term{const volatile object}. The cv-qualified or
cv-unqualified versions of a type
are distinct types; however, they shall have the same representation and
alignment requirements~(\ref{basic.types}).\footnote{The same representation
and alignment requirements are meant to imply
interchangeability as arguments to functions, return values from
functions, and members of unions.}

\pnum
\indextext{array!\idxcode{const}}%
A compound type~(\ref{basic.compound}) is not cv-qualified by the
cv-qualifiers (if any) of the types from which it is compounded. Any
cv-qualifiers applied to an array type affect the array element type,
not the array type~(\ref{dcl.array}).

\pnum
\indextext{class~object!\idxcode{const}}%
Each non-static, non-mutable, non-reference data member of a
const-qualified class object is const-qual\-i\-fied, each non-static,
non-reference data member of a volatile-qualified class object is
volatile-qualified and similarly for members of a const-volatile class.
See~\ref{dcl.fct} and~\ref{class.this} regarding cv-qualified function
types.

\pnum
There is a (partial) ordering on cv-qualifiers, so that a type can be
said to be \grammarterm{more cv-qualified} than another.
Table~\ref{tab:relations.on.const.and.volatile} shows the relations that
constitute this ordering.

\begin{floattable}{relations on \tcode{const} and \tcode{volatile}}{tab:relations.on.const.and.volatile}
{ccc}
\topline
\cvqual{no cv-qualifier}    &<& \tcode{const}           \\
\cvqual{no cv-qualifier}    &<& \tcode{volatile}        \\
\cvqual{no cv-qualifier}    &<& \tcode{const volatile}  \\
\tcode{const}               &<& \tcode{const volatile}  \\
\tcode{volatile}            &<& \tcode{const volatile}  \\
\end{floattable}

\pnum
In this International Standard, the notation \term{cv} (or
\term{cv1}, \term{cv2}, etc.), used in the description of types,
represents an arbitrary set of cv-qualifiers, i.e., one of
\{\tcode{const}\}, \{\tcode{volatile}\}, \{\tcode{const},
\tcode{volatile}\}, or the empty set. Cv-qualifiers applied to an array
type attach to the underlying element type, so the notation
``\term{cv} \tcode{T},'' where \tcode{T} is an array type, refers to
an array whose elements are so-qualified. Such array types can be said
to be more (or less) cv-qualified than other types based on the
cv-qualification of the underlying element types.%
\indextext{type|)}

\rSec1[basic.lval]{Lvalues and rvalues}
\pnum
Every expression is either an \defn{lvalue} or an \defn{rvalue}.

\pnum
An lvalue refers to an object or function. Some rvalue expressions---those
of class or cv-qualified class type---also refer to objects.%
\footnote{Expressions such as invocations of constructors and of functions
that return a class type refer to objects, and the implementation can
invoke a member function upon such objects, but the expressions are
not lvalues.}

\pnum
\enternote some built-in operators and function calls yield lvalues.
\enterexample if \tcode{E} is an expression of pointer type, then \tcode{*E} is
an lvalue expression referring to the object or function to which \tcode{E} points.
As another example, the function

\begin{codeblock}
int& f();
\end{codeblock}

yields an lvalue, so the call \tcode{f()} is an lvalue expression. \exitexample
\exitnote

\pnum
\enternote some built-in operators expect lvalue operands.
\enterexample built-in assignment operators all expect their left hand
operands to be lvalues. \exitexample
Other built-in operators yield rvalues, and some expect them.
\enterexample the unary and binary \tcode{+} operators expect rvalue
arguments and yield rvalue results. \exitexample
The discussion of each built-in operator in clause~\ref{expr} indicates
whether it expects lvalue operands and whether it yields an lvalue.
\exitnote

\pnum
The result of calling a function that does not return a reference is an
rvalue. User defined operators are functions, and whether such operators
expect or yield lvalues is determined by their parameter and return types.

\pnum
An expression which holds a temporary object resulting from a cast to a
nonreference type is an rvalue (this includes the explicit creation of an
object using functional notation~(\ref{expr.type.conv})).

\pnum
Whenever an lvalue appears in a context where an rvalue is expected,
the lvalue is converted to an rvalue; see~\ref{conv.lval}, \ref{conv.array},
and~\ref{conv.func}.

\pnum
The discussion of reference initialization in~\ref{dcl.init.ref} and of
temporaries in~\ref{class.temporary} indicates the behavior of lvalues
and rvalues in other significant contexts.

\pnum
Class rvalues can have cv-qualified types; non-class rvalues always have
cv-unqualified types. Rvalues shall always have complete types or the
\tcode{void} type; in addition to these types, lvalues can also have
incomplete types.

\pnum
An lvalue for an object is necessary in order to modify the object
except that an rvalue of class type can also be used to modify its
referent under certain circumstances. \enterexample a member function
called for an object~(\ref{class.mfct}) can modify the object.
\exitexample

\pnum
Functions cannot be modified, but pointers to functions can be
modifiable.

\pnum
A pointer to an incomplete type can be modifiable. At some point in the
program when the pointed to type is complete, the object at which the
pointer points can also be modified.

\pnum
The referent of a \tcode{const}-qualified expression shall not be
modified (through that expression), except that if it is of class type
and has a \tcode{mutable} component, that component can be
modified~(\ref{dcl.type.cv}).

\pnum
If an expression can be used to modify the object to which it refers,
the expression is called \term{modifiable}. A program that attempts
to modify an object through a nonmodifiable lvalue or rvalue expression
is ill-formed.

\pnum
If a program attempts to access the stored value of an object through an lvalue
of other than one of the following types the behavior is
undefined\footnote{The intent of this list is to specify those circumstances in which an object may or may not be aliased.}:

\begin{itemize}
\item the dynamic type of the object,

\item a cv-qualified version of the dynamic type of the object,

\item a type that is the signed or unsigned type corresponding to the
dynamic type of the object,

\item a type that is the signed or unsigned type corresponding to a
cv-qualified version of the dynamic type of the object,

\item an aggregate or union type that includes one of the aforementioned
types among its members (including, recursively, a member of a
subaggregate or contained union),

\item a type that is a (possibly cv-qualified) base class type of the dynamic type of
the object,

\item a \tcode{char} or \tcode{unsigned} \tcode{char} type.
\end{itemize}
