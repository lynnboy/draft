\rSec0[stmt.stmt]{Statements}%
\indextext{statement|(}

%gram: \rSec1[gram.stmt.stmt]{Statements}
%gram:

\indextext{block statement|see{statement, compound}}

\pnum
Except as indicated, statements are executed in sequence.

\begin{bnf}
\nontermdef{statement}\br
    labeled-statement\br
    expression-statement\br
    compound-statement\br
    selection-statement\br
    iteration-statement\br
    jump-statement\br
    declaration-statement\br
    try-block
\end{bnf}

\rSec1[stmt.label]{Labeled statement}%
\indextext{statement!labeled}

\pnum
\indextext{statement!labeled}%
\indextext{\idxcode{:}!label~specifier}%
A statement can be labeled.

\begin{bnf}
\nontermdef{labeled-statement}\br
    identifier \terminal{:} statement\br
    \terminal{case} constant-expression \terminal{:} statement\br
    \terminal{default :} statement
\end{bnf}

An identifier label declares the identifier. The only use of an
identifier label is as the target of a
\indextext{statement!\idxcode{goto}}%
\tcode{goto}.
\indextext{label!scope~of}%
The scope of a label is the function in which it appears. Labels shall
not be redeclared within a function. A label can be used in a
\tcode{goto} statement before its definition.
\indextext{name~space!label}%
Labels have their own name space and do not interfere with other
identifiers.

\pnum
\indextext{label!\idxcode{case}}%
\indextext{label!\idxcode{default}}%
Case labels and default labels shall occur only in switch statements.


\rSec1[stmt.expr]{Expression statement}%
\indextext{statement!expression}

\pnum
Expression statements have the form

\begin{bnf}
\nontermdef{expression-statement}\br
    expression\opt \terminal{;}
\end{bnf}

The expression is evaluated and its value is discarded. The
lvalue-to-rvalue~(\ref{conv.lval}), array-to-pointer~(\ref{conv.array}),
and function-to-pointer~(\ref{conv.func}) standard conversions are not
applied to the expression. All
\indextext{side effects}%
side effects from an expression statement
are completed before the next statement is executed.
\indextext{statement!null}%
\indextext{statement!empty}%
An expression statement with the expression missing is called a null
statement.
\enternote
Most statements are expression statements --- usually assignments or
function calls. A null statement is useful to carry a label just before
the \tcode{\}} of a compound statement and to supply a null body to an
iteration statement such as a \tcode{while}
statement~(\ref{stmt.while}).
\exitnote

\rSec1[stmt.block]{Compound statement or block}%
\indextext{statement!compound}%
\indextext{\idxcode{\{\}}!block statement}%

\pnum
So that several statements can be used where one is expected, the
compound statement (also, and equivalently, called ``block'') is
provided.

\begin{bnf}
\nontermdef{compound-statement}\br
    \terminal{\{} statement-seq\opt \terminal{\}}
\end{bnf}

\begin{bnf}
\nontermdef{statement-seq}\br
    statement\br
    statement-seq statement
\end{bnf}

A compound statement defines a block scope~(\ref{basic.scope}).
\enternote
a declaration is a \grammarterm{}{statement}~(\ref{stmt.dcl}).
\exitnote

\rSec1[stmt.select]{Selection statements}%
\indextext{statement!selection|(}

\pnum
Selection statements choose one of several flows of control.

\indextext{statement!\idxcode{if}}%
\indextext{statement!\idxcode{switch}}%
%
\begin{bnf}
\nontermdef{selection-statement}\br
    \terminal{if (} condition \terminal{)} statement\br
    \terminal{if (} condition \terminal{)} statement \terminal{else} statement\br
    \terminal{switch (} condition \terminal{)} statement
\end{bnf}

\begin{bnf}
\nontermdef{condition}\br
    expression\br
    type-specifier-seq declarator \terminal{=} assignment-expression
\end{bnf}

In clause~\ref{stmt.stmt}, the term \term{substatement} refers to
the contained \grammarterm{statement} or \grammarterm{statement}{s} that appear
in the syntax notation.
\indextext{scope!\idxgram{selection-statement}}%
The substatement in a \grammarterm{selection-statement} (each substatement,
in the \tcode{else} form of the \tcode{if} statement) implicitly defines
a local scope~(\ref{basic.scope}). If the substatement in a
selection-statement is a single statement and not a
\grammarterm{compound-statement,} it is as if it was rewritten to be a
compound-statement containing the original substatement.
\enterexample

\begin{codeblock}
if (x)
    int i;
\end{codeblock}

can be equivalently rewritten as

\begin{codeblock}
if (x) {
    int i;
}
\end{codeblock}

Thus after the \tcode{if} statement, \tcode{i} is no longer in scope.
\exitexample

\pnum
\indextext{\idxgram{condition}{s}!rules~for}%
The rules for \grammarterm{condition}{s} apply both to
\grammarterm{selection-statement}{s} and to the \tcode{for} and \tcode{while}
statements~(\ref{stmt.iter}). The \grammarterm{declarator} shall not
specify a function or an array. The \nonterminal{type-specifier-seq} shall
not contain \tcode{typedef} and shall not declare a new class or
enumeration.

\pnum
\indextext{statement!declaration in \tcode{if}}%
\indextext{statement!declaration in \tcode{switch}}%
A name introduced by a declaration in a \grammarterm{condition} (either
introduced by the \grammarterm{type-specifier-seq} or the
\grammarterm{declarator} of the condition) is in scope from its point of
declaration until the end of the substatements controlled by the
condition. If the name is re-declared in the outermost block of a
substatement controlled by the condition, the declaration that
re-declares the name is ill-formed.
\enterexample

\begin{codeblock}
if (int x = f()) {
	int x;			// ill-formed, redeclaration of \tcode{x}
}
else {
	int x;			// ill-formed, redeclaration of \tcode{x}
}
\end{codeblock}
\exitexampleb

\pnum
The value of a \grammarterm{condition} that is an initialized declaration
in a statement other than a \tcode{switch} statement is the value of the
declared variable implicitly converted to type \tcode{bool}. If that
conversion is ill-formed, the program is ill-formed. The value of a
\grammarterm{condition} that is an initialized declaration in a
\tcode{switch} statement is the value of the declared variable if it has
integral or enumeration type, or of that variable implicitly converted
to integral or enumeration type otherwise. The value of a
\grammarterm{condition} that is an expression is the value of the
expression, implicitly converted to \tcode{bool} for statements other
than \tcode{switch}; if that conversion is ill-formed, the program is
ill-formed. The value of the condition will be referred to as simply
``the condition'' where the usage is unambiguous.

\pnum
If a \grammarterm{condition} can be syntactically resolved as either an
expression or the declaration of a local name, it is interpreted as a
declaration.

\rSec2[stmt.if]{The \tcode{if} statement}%
\indextext{statement!\idxcode{if}}

\pnum
If the condition~(\ref{stmt.select}) yields \tcode{true} the first
substatement is executed. If the \tcode{else} part of the selection
statement is present and the condition yields \tcode{false}, the second
substatement is executed. In the second form of \tcode{if} statement
(the one including \tcode{else}), if the first substatement is also an
\tcode{if} statement then that inner \tcode{if} statement shall contain
an \tcode{else} part.\footnote{In other words, the \tcode{else} is associated with the nearest un-elsed
\tcode{if}.}

\rSec2[stmt.switch]{The \tcode{switch} statement}%
\indextext{statement!\idxcode{switch}}

\pnum
The \tcode{switch} statement causes control to be transferred to one of
several statements depending on the value of a condition.

\pnum
The condition shall be of integral type, enumeration type, or of a class
type for which a single conversion function to integral or enumeration
type exists~(\ref{class.conv}). If the condition is of class type, the
condition is converted by calling that conversion function, and the
result of the conversion is used in place of the original condition for
the remainder of this section. Integral promotions are performed. Any
statement within the \tcode{switch} statement can be labeled with one or
more case labels as follows:

\begin{ncbnf}
\indextext{label!\idxcode{case}}%
\terminal{case} constant-expression \terminal{:}
\end{ncbnf}

where the \grammarterm{constant-expression} shall be an integral
\grammarterm{constant-expression}. The integral
constant-expression~(\ref{expr.const}) is implicitly converted to the
prompted type of the switch condition. No two of the case constants in
the same switch shall have the same value after conversion to the
promoted type of the switch condition.

\pnum
\indextext{label!\idxcode{default}}%
There shall be at most one label of the form

\begin{codeblock}
default :
\end{codeblock}

within a \tcode{switch} statement.

\pnum
Switch statements can be nested; a \tcode{case} or \tcode{default} label
is associated with the smallest switch enclosing it.

\pnum
When the \tcode{switch} statement is executed, its condition is
evaluated and compared with each case constant.
\indextext{label!\idxcode{case}}%
If one of the case constants is equal to the value of the condition,
control is passed to the statement following the matched case label. If
no case constant matches the condition, and if there is a
\indextext{label!\idxcode{default}}%
\tcode{default} label, control passes to the statement labeled by the
default label. If no case matches and if there is no \tcode{default}
then none of the statements in the switch is executed.

\pnum
\tcode{case} and \tcode{default} labels in themselves do not alter the
flow of control, which continues unimpeded across such labels. To exit
from a switch, see \tcode{break},~\ref{stmt.break}.
\enternote
usually, the substatement that is the subject of a switch is compound
and \tcode{case} and \tcode{default} labels appear on the top-level
statements contained within the (compound) substatement, but this is not
required.
\indextext{statement!declaration~in \tcode{switch}}%
Declarations can appear in the substatement of a
\grammarterm{switch-statement}.
\exitnote%
\indextext{statement!selection|)}

\rSec1[stmt.iter]{Iteration statements}%
\indextext{statement!iteration|(}

\pnum
Iteration statements specify looping.

\indextext{statement!\idxcode{while}}%
\indextext{statement!\idxcode{do}}%
\indextext{statement!\idxcode{for}}%
%
\begin{bnf}
\nontermdef{iteration-statement}\br
    \terminal{while (} condition \terminal{)} statement\br
    \terminal{do} statement \terminal{while (} expression \terminal{) ;}\br
    \terminal{for (} for-init-statement condition\opt \terminal{;} expression\opt \terminal{)} statement\br
\end{bnf}

\begin{bnf}
\nontermdef{for-init-statement}\br
    expression-statement\br
    simple-declaration
\end{bnf}

\enternote
a \grammarterm{for-init-statement} ends with a semicolon.
\exitnote

\pnum
The substatement in an \grammarterm{iteration-statement} implicitly defines
a local scope~(\ref{basic.scope}) which is entered and exited each time
through the loop.

\pnum
\indextext{scope!\idxgram{iteration-statement}}%
If the substatement in an iteration-statement is a single statement and
not a \grammarterm{compound-statement,} it is as if it was rewritten to be
a compound-statement containing the original statement.
\enterexample

\begin{codeblock}
while (--x >= 0)
    int i;
\end{codeblock}

can be equivalently rewritten as

\begin{codeblock}
while (--x >= 0) {
    int i;
}
\end{codeblock}

Thus after the \tcode{while} statement, \tcode{i} is no longer in scope.
\exitexample

\pnum
\enternote
The requirements on \grammarterm{condition}{s} in iteration statements are
described in~\ref{stmt.select}.
\exitnoteb

\rSec2[stmt.while]{The \tcode{while} statement}%
\indextext{statement!\idxcode{while}}

\pnum
In the \tcode{while} statement the substatement is executed repeatedly
until the value of the condition~(\ref{stmt.select}) becomes
\tcode{false}. The test takes place before each execution of the
substatement.

\pnum
\indextext{statement!declaration~in \tcode{while}}%
When the condition of a \tcode{while} statement is a declaration, the scope of
the variable that is declared extends from its point of
declaration~(\ref{basic.scope.pdecl}) to the end of the \tcode{while}
\grammarterm{statement}. A \tcode{while} statement of the form

\begin{codeblock}
while (T t = x) @\grammarterm{statement}@
\end{codeblock}

is equivalent to

\begin{codeblock}
label:
{				// start of condition scope
    T t = x;
    if (t) {
	@\grammarterm{statement}@
	goto label;
    }
}				// end of condition scope
\end{codeblock}

The object created in a condition is destroyed and created with each
iteration of the loop.
\enterexample

\begin{codeblock}
struct A {
    int val;
    A(int i) : val(i) { }
    ~A() { }
    operator bool() { return val != 0; }
};
int i = 1;
while (A a = i) {
    // ...
    i = 0;
}
\end{codeblock}

In the while-loop, the constructor and destructor are each called twice,
once for the condition that succeeds and once for the condition that
fails.
\exitexample

\rSec2[stmt.do]{The \tcode{do} statement}%
\indextext{statement!\idxcode{do}}

\pnum
The expression is implicitly converted to \tcode{bool};
if that is not possible, the program is ill-formed.

\pnum
In the \tcode{do} statement the substatement is executed repeatedly
until the value of the expression becomes \tcode{false}. The test takes
place after each execution of the statement.

\rSec2[stmt.for]{The \tcode{for} statement}%
\indextext{statement!\idxcode{for}}

\pnum
The \tcode{for} statement

\begin{ncbnf}
\terminal{for (} for-init-statement condition\opt \terminal{;} expression\opt \terminal{)} statement
\end{ncbnf}

is equivalent to

\begin{ncbnftab}
\terminal{\{}\br
\>for-init-statement\br
\>\terminal{while (} condition \terminal{) \{}\br
\>\>statement\br
\>\>expression \terminal{;}\br
\>\terminal{\}}\br
\terminal{\}}
\end{ncbnftab}

except that names declared in the \grammarterm{for-init-statement} are in
the same declarative-region as those declared in the
\grammarterm{condition}, and except that a
\indextext{statement!\tcode{continue}~in \tcode{for}}%
\tcode{continue} in \grammarterm{statement} (not enclosed in another
iteration statement) will execute \grammarterm{expression} before
re-evaluating \grammarterm{condition}.
\enternote
Thus the first statement specifies initialization for the loop; the
condition~(\ref{stmt.select}) specifies a test, made before each
iteration, such that the loop is exited when the condition becomes
\tcode{false}; the expression often specifies incrementing that is done
after each iteration.
\exitnote

\pnum
Either or both of the condition and the expression can be omitted. A
missing \grammarterm{condition} makes the implied \tcode{while} clause
equivalent to \tcode{while(true)}.

\pnum
\indextext{statement!declaration~in \tcode{for}}%
\indextext{\idxcode{for}!scope~of declaration~in}%
If the \grammarterm{for-init-statement} is a declaration, the scope of the
name(s) declared extends to the end of the \grammarterm{for-statement}.
\enterexample

\begin{codeblock}
int i = 42;
int a[10];

for (int i = 0; i < 10; i++)
	a[i] = i;

int j = i;			// \tcode{j = 42}
\end{codeblock}
\exitexampleb

\rSec1[stmt.jump]{Jump statements}%
\indextext{statement!jump}

\pnum
Jump statements unconditionally transfer control.
\indextext{statement!jump}%

\indextext{statement!\idxcode{break}}%
\indextext{statement!\idxcode{continue}}%
\indextext{return statement@\tcode{return} statement|see{\tcode{return}}}%
\indextext{\idxcode{return}}%
\indextext{statement!\idxcode{goto}}%
%
\begin{bnf}
\nontermdef{jump-statement}\br
    \terminal{break ;}\br
    \terminal{continue ;}\br
    \terminal{return} expression\opt \terminal{;}\br
    \terminal{goto} identifier \terminal{;}
\end{bnf}

\pnum
\indextext{local~variable!destruction~of}%
\indextext{scope!destructor~and exit~from}%
On exit from a scope (however accomplished), destructors~(\ref{class.dtor})
are called for all constructed objects with automatic storage
duration~(\ref{basic.stc.auto}) (named objects or temporaries) that are
declared in that scope, in the reverse order of their declaration.
Transfer out of a loop, out of a block, or back past an initialized
variable with automatic storage duration involves the destruction of
variables with automatic storage duration that are in scope at the point
transferred from but not at the point transferred to.
(See~\ref{stmt.dcl} for transfers into blocks).
\enternote
However, the program can be terminated (by calling
\indextext{\idxcode{exit}}%
\indexlibrary{\idxcode{exit}}%
\tcode{exit()} or
\indextext{\idxcode{abort}}%
\indexlibrary{\idxcode{abort}}%
\tcode{abort()}~(\ref{lib.support.start.term}), for example) without
destroying class objects with automatic storage duration.
\exitnote

\rSec2[stmt.break]{The \tcode{break} statement}%
\indextext{statement!\idxcode{break}}

\pnum
The \tcode{break} statement shall occur only in an
\indextext{\idxgram{iteration-statement}}%
\indextext{statement!\idxcode{switch}}%
\grammarterm{iteration-statement} or a \tcode{switch} statement and causes
termination of the smallest enclosing \grammarterm{iteration-statement} or
\tcode{switch} statement; control passes to the statement following the
terminated statement, if any.

\rSec2[stmt.cont]{The \tcode{continue} statement}%
\indextext{statement!\idxcode{continue}}

\pnum
The
\tcode{continue}
statement shall occur only in an
\indextext{\idxgram{iteration-statement}}%
\grammarterm{iteration-statement}
and causes control to pass to the loop-continuation portion of the
smallest enclosing \grammarterm{iteration-statement}, that is, to the end
of the loop. More precisely, in each of the statements

\begin{minipage}{.30\hsize}
\begin{codeblock}
while (foo) {
  {
    // ...
  }
contin: ;
}
\end{codeblock}
\end{minipage}
\begin{minipage}{.30\hsize}
\begin{codeblock}
do {
  {
    // ...
  }
contin: ;
} while (foo);
\end{codeblock}
\end{minipage}
\begin{minipage}{.30\hsize}
\begin{codeblock}
for (;;) {
  {
    // ...
  }
contin: ;
}
\end{codeblock}
\end{minipage}

a \tcode{continue} not contained in an enclosed iteration statement is
equivalent to \tcode{goto} \tcode{contin}.

\rSec2[stmt.return]{The \tcode{return} statement}%
\indextext{\idxcode{return}}%
\indextext{function~return|see{\tcode{return}}}%

\pnum
A function returns to its caller by the \tcode{return} statement.

\pnum
A return statement without an expression can be used only in functions
that do not return a value, that is, a function with the return type
\tcode{void}, a constructor~(\ref{class.ctor}), or a
destructor~(\ref{class.dtor}).
\indextext{\idxcode{return}!constructor~and}%
\indextext{\idxcode{return}!constructor~and}%
A return statement with an expression of non-void type can be used only
in functions returning a value; the value of the expression is returned
to the caller of the function.
\indextext{conversion!return~type}%
The expression is implicitly converted to the return type of the
function in which it appears. A return statement can involve the
construction and copy of a temporary object~(\ref{class.temporary}).
Flowing off the end of a function is equivalent to a \tcode{return} with
no value; this results in undefined behavior in a value-returning
function.

\pnum
A return statement with an expression of type ``\cv~\tcode{void}''
can be used only in functions with a return type of
\cvqual{cv} \tcode{void}; the expression is evaluated just before the function
returns to its caller.

\rSec2[stmt.goto]{The \tcode{goto} statement}%
\indextext{statement!\idxcode{goto}}

\pnum
The \tcode{goto} statement unconditionally transfers control to the
statement labeled by the identifier. The identifier shall be a
\indextext{label}%
label~(\ref{stmt.label}) located in the current function.

\rSec1[stmt.dcl]{Declaration statement}%
\indextext{statement!declaration}

\pnum
A declaration statement introduces one or more new identifiers into a
block; it has the form

\begin{bnf}
\nontermdef{declaration-statement}\br
    block-declaration
\end{bnf}

If an identifier introduced by a declaration was previously declared in
an outer block,
\indextext{declaration~hiding|see{name~hiding}}%
\indextext{name~hiding}%
\indextext{block~structure}%
the outer declaration is hidden for the remainder of the block, after
which it resumes its force.

\pnum
\indextext{block!initialization~in}%
\indextext{initialization!automatic}%
Variables with automatic storage duration~(\ref{basic.stc.auto}) are
initialized each time their \grammarterm{declaration-statement} is executed.
\indextext{local~variable!destruction~of}%
Variables with automatic storage duration declared in the block are
destroyed on exit from the block~(\ref{stmt.jump}).

\pnum
\indextext{initialization!jump~past}%
\indextext{\idxcode{goto}!initialization~and}%
It is possible to transfer into a block, but not in a way that bypasses
declarations with initialization. A program that jumps\footnote{The transfer from the condition of a \tcode{switch} statement to a
\tcode{case} label is considered a jump in this respect.}
from a point where a local variable with automatic storage duration is
not in scope to a point where it is in scope is ill-formed unless the
variable has POD type~(\ref{basic.types}) and is declared without an
\grammarterm{}{initializer}~(\ref{dcl.init}).\\
\enterexample

\begin{codeblock}
void f()
{
    // ... 
    goto lx;			// ill-formed: jump into scope of \tcode{a}
    // ...
ly:
    X a = 1;
    // ...
lx:
    goto ly;			// OK, jump implies destructor
				// call for \tcode{a} followed by construction
				// again immediately following label \tcode{ly}
}
\end{codeblock}
\exitexampleb

\pnum
\indextext{initialization!automatic}%
\indextext{initialization!local \tcode{static}}%
The zero-initialization~(\ref{dcl.init}) of all local objects with
static storage duration~(\ref{basic.stc.static}) is performed before any
other initialization takes place. A local object of POD
type~(\ref{basic.types}) with static storage duration initialized with
\grammarterm{constant-expression}{s} is initialized before its block is
first entered. An implementation is permitted to perform early initialization
of other local objects with static storage duration under the same
conditions that an implementation is permitted to statically initialize
an object with static storage duration in namespace
scope~(\ref{basic.start.init}). Otherwise such an object is initialized
the first time control passes through its declaration; such an object is
considered initialized upon the completion of its initialization. If the
initialization exits by throwing an exception, the initialization is not
complete, so it will be tried again the next time control enters the
declaration. If control re-enters the declaration (recursively) while
the object is being initialized, the behavior is undefined.
\enterexample

\begin{codeblock}
int foo(int i)
{
    static int s = foo(2*i);    // recursive call - undefined
    return i+1;
}
\end{codeblock}
\exitexampleb

\pnum
\indextext{\idxcode{static}!destruction~of local}%
The destructor for a local object with static storage duration will be
executed if and only if the variable was constructed.
\enternote
\ref{basic.start.term} describes the order in which local objects with
static storage duration are destroyed.
\exitnote

\rSec1[stmt.ambig]{Ambiguity resolution}%
\indextext{ambiguity!declaration~versus expression}

\pnum
There is an ambiguity in the grammar involving
\grammarterm{expression-statement}{s} and \grammarterm{declaration}{s}: An
\grammarterm{expression-statement} with a function-style explicit type
conversion~(\ref{expr.type.conv}) as its leftmost subexpression can be
indistinguishable from a \grammarterm{declaration} where the first
\grammarterm{declarator} starts with a \tcode{(}. In those cases the
\grammarterm{statement} is a \grammarterm{declaration}. \enternote To
disambiguate, the whole \grammarterm{statement} might have to be examined
to determine if it is an \grammarterm{expression-statement} or a
\grammarterm{declaration}. This disambiguates many examples.
\enterexample
assuming \tcode{T} is a
\grammarterm{simple-type-specifier}~(\ref{dcl.type}),

\begin{codeblock}
	T(a)->m = 7;		// expression-statement
	T(a)++;			// expression-statement
	T(a,5)<<c;		// expression-statement

	T(*d)(int);		//  declaration
	T(e)[5];		//  declaration
	T(f) = { 1, 2 };	//  declaration
	T(*g)(double(3));	//  declaration
\end{codeblock}

In the last example above, \tcode{g}, which is a pointer to \tcode{T},
is initialized to \tcode{double(3)}. This is of course ill-formed for
semantic reasons, but that does not affect the syntactic analysis.
\exitexampleb

\pnum
The remaining cases are \grammarterm{declaration}{s}.
\enterexample

\begin{codeblock}
	class T {
		// ...
	public:
		T();
		T(int);
		T(int, int);
	};
	T(a);			//  declaration
	T(*b)();		//  declaration
	T(c)=7;			//  declaration
	T(d),e,f=3;		//  declaration
	extern int h;
	T(g)(h,2);		//  declaration
\end{codeblock}
\exitexampleb
\exitnoteb

\pnum
The disambiguation is purely syntactic; that is, the meaning of the
names occurring in such a statement, beyond whether they are
\grammarterm{type-name}{s} or not, is not generally used in or changed by the
disambiguation. Class templates are instantiated as necessary to
determine if a qualified name is a \grammarterm{type-name}. Disambiguation
precedes parsing, and a statement disambiguated as a declaration may be
an ill-formed declaration. If, during parsing, a name in a template
parameter is bound differently than it would be bound during a trial
parse, the program is ill-formed. No diagnostic is required.
\enternote
This can occur only when the name is declared earlier in the
declaration.
\exitnote
\enterexample

\begin{codeblock}
struct T1 {
	T1 operator()(int x) { return T1(x); }
	int operator=(int x) { return x; }
	T1(int) { }
};
struct T2 { T2(int){ } };
int a, (*(*b)(T2))(int), c, d;

void f() {
	// disambiguation requires this to be parsed
	// as a declaration
	T1(a) = 3,
	T2(4),                  // \tcode{T2} will be declared as
	(*(*b)(T2(c)))(int(d)); // a variable of type \tcode{T1}
                                // but this will not allow
                                // the last part of the
                                // declaration to parse
                                // properly since it depends
                                // on \tcode{T2} being a type-name
}
\end{codeblock}
\exitexampleb%
\indextext{statement|)}
