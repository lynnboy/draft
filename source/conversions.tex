\rSec0[conv]{Standard conversions}

\indextext{implicit~conversion|see{conversion, implicit}}
\indextext{rvalue!lvalue conversion to|see{conversion, lvalue to rvalue}}%

\pnum
\indextext{conversion!standard|(}%
\indextext{conversion!implicit}%
Standard conversions are implicit conversions defined for built-in types.
Clause~\ref{conv} enumerates the full set of such conversions. A
\indextext{sequence!standard conversion}%
\term{standard conversion sequence} is a sequence of standard
conversions in the following order:

\begin{itemize}
\item Zero or one conversion from the following set: lvalue-to-rvalue
conversion, array-to-pointer conversion, and function-to-pointer
conversion.

\item Zero or one conversion from the following set: integral
promotions, floating point promotion, integral conversions, floating
point conversions, floating-integral conversions, pointer conversions,
pointer to member conversions, and boolean conversions.

\item Zero or one qualification conversion.
\end{itemize}

\enternote
a standard conversion sequence can be empty, i.e., it can consist of no
conversions. \exitnote A standard conversion sequence will be applied to
an expression if necessary to convert it to a required destination type.

\pnum
\enternote 
expressions with a given type will be implicitly converted to other
types in several contexts:

\begin{itemize}
\item When used as operands of operators. The operator's requirements
for its operands dictate the destination type (clause~\ref{expr}).

\item When used in the condition of an \tcode{if} statement or iteration
statement~(\ref{stmt.select}, \ref{stmt.iter}). The destination type is
\tcode{bool}.

\item When used in the expression of a \tcode{switch} statement. The
destination type is integral~(\ref{stmt.select}).

\item When used as the source expression for an initialization (which
includes use as an argument in a function call and use as the expression
in a \tcode{return} statement). The type of the entity being initialized
is (generally) the destination type.
See~\ref{dcl.init},~\ref{dcl.init.ref}.
\end{itemize}
\exitnoteb

\pnum
An expression \tcode{e} can be
\indextext{conversion!implicit}%
\term{implicitly converted} to a type \tcode{T} if and only if the
declaration ``\tcode{T t=e;}'' is well-formed, for some invented temporary
variable \tcode{t}~(\ref{dcl.init}). The effect of the implicit
conversion is the same as performing the declaration and initialization
and then using the temporary variable as the result of the conversion.
The result is an lvalue if \tcode{T} is a reference type~(\ref{dcl.ref}),
and an rvalue otherwise. The expression \tcode{e}
is used as an lvalue if and only if the initialization uses it as an lvalue.

\pnum
\enternote 
For user-defined types, user-defined conversions are considered as well;
see~\ref{class.conv}. In general, an implicit conversion
sequence~(\ref{over.best.ics}) consists of a standard conversion
sequence followed by a user-defined conversion followed by another
standard conversion sequence.

\pnum
There are some contexts where certain conversions are suppressed. For
example, the lvalue-to-rvalue conversion is not done on the operand of
the unary \tcode{\&} operator. Specific exceptions are given in the
descriptions of those operators and contexts.
\exitnote 

\rSec1[conv.lval]{Lvalue-to-rvalue conversion}

\pnum
\indextext{conversion!lvalue-to-rvalue}%
\indextext{type!incomplete}%
An lvalue~(\ref{basic.lval}) of a non-function, non-array type \tcode{T}
can be converted to an rvalue. If \tcode{T} is an incomplete type, a
program that necessitates this conversion is ill-formed. If the object
to which the lvalue refers is not an object of type \tcode{T} and is not
an object of a type derived from \tcode{T}, or if the object is
uninitialized, a program that necessitates this conversion has undefined
behavior. If \tcode{T} is a non-class type, the type of the rvalue is
the cv-unqualified version of \tcode{T}. Otherwise, the type of the
rvalue is \tcode{T}.\footnote{In \Cpp class rvalues can have cv-qualified types (because they are
objects). This differs from ISO C, in which non-lvalues never have
cv-qualified types.}

\pnum
The value contained in the object indicated by the lvalue is the
rvalue result. When an lvalue-to-rvalue conversion occurs within the
operand of \tcode{sizeof}~(\ref{expr.sizeof}) the value contained
in the referenced object is not accessed, since that operator does
not evaluate its operand.

\pnum
\enternote 
See also~\ref{basic.lval}.\exitnote 

\rSec1[conv.array]{Array-to-pointer conversion}

\pnum
\indextext{conversion!array-to-pointer}%
\indextext{decay|see{conversion, array to pointer; conversion, function to pointer}}%
An lvalue or rvalue of type ``array of \tcode{N} \tcode{T}'' or ``array
of unknown bound of \tcode{T}'' can be converted to an rvalue of type
``pointer to \tcode{T}.'' The result is a pointer to the first element
of the array.

\pnum
A string literal~(\ref{lex.string}) that is not a wide string literal
can be converted to an rvalue of type ``pointer to \tcode{char}'';
a wide string literal can be converted to an rvalue of type ``pointer to
\tcode{wchar_t}''. In either case, the result is a pointer to the first
element of the array. This conversion is considered only when there is
an explicit appropriate pointer target type, and not when there is a
general need to convert from an lvalue to an rvalue. \enternote this
conversion is deprecated. See Annex~\ref{depr}. \exitnote For the
purpose of ranking in overload resolution~(\ref{over.ics.scs}), this
conversion is considered an array-to-pointer conversion followed by
a qualification conversion~(\ref{conv.qual}). \enterexample \tcode{"abc"}
is converted to ``pointer to \tcode{const} \tcode{char}'' as an
array-to-pointer conversion, and then to ``pointer to \tcode{char}''
as a qualification conversion. \exitexample

\rSec1[conv.func]{Function-to-pointer conversion}

\pnum
\indextext{conversion!function-to-pointer}%
An lvalue of function type \tcode{T} can be converted to an rvalue of
type ``pointer to \tcode{T}.'' The result is a pointer to the
function.\footnote{This conversion never applies to nonstatic member functions because an
lvalue that refers to a nonstatic member function cannot be obtained.}

\pnum
\enternote 
See~\ref{over.over} for additional rules for the case where the function
is overloaded.
\exitnote 

\rSec1[conv.qual]{Qualification conversions}

\pnum
\indextext{conversion!qualification|(}%
An rvalue of type ``pointer to \cvqual{cv1} \tcode{T}'' can be
converted to an rvalue of type ``pointer to \cvqual{cv2} \tcode{T}'' if
``\cvqual{cv2} \tcode{T}'' is more cv-qualified than ``\cvqual{cv1}
\tcode{T}.''

\pnum
An rvalue of type ``pointer to member of \tcode{X} of type \cvqual{cv1}
\tcode{T}'' can be converted to an rvalue of type ``pointer to member
of \tcode{X} of type \cvqual{cv2} \tcode{T}'' if ``\cvqual{cv2}
\tcode{T}'' is more cv-qualified than ``\cvqual{cv1} \tcode{T}.''

\pnum
\enternote 
Function types (including those used in pointer to member function
types) are never cv-qualified~(\ref{dcl.fct}).
\exitnote 

\pnum
A conversion can add cv-qualifiers at levels other than the first in
multi-level pointers, subject to the following rules:\footnote{These rules ensure that const-safety is preserved by the conversion.}
\begin{indented}
Two pointer types T1 and T2 are \term{similar} if there exists a
type \cvqual{T} and integer $n > 0$ such that:

\begin{indented}
\term{T1} is $\mathit{cv}_{1,0}$ pointer to $\mathit{cv}_{1,1}$ pointer
to $\cdots$ $\mathit{cv}_{1,n-1}$ pointer to $\mathit{cv}_{1,n}$
\term{T}
\end{indented}

and
\begin{indented}
\term{T2} is $\mathit{cv}_{2,0}$ pointer to $\mathit{cv}_{2,1}$ pointer
to $\cdots$ $\mathit{cv}_{2,n-1}$ pointer to $\mathit{cv}_{2,n}$
\term{T}
\end{indented}

where each $\mathit{cv}_{i,j}$ is \tcode{const}, \tcode{volatile},
\tcode{const volatile}, or nothing. The n-tuple of cv-qualifiers after
the first in a pointer type, e.g.,
$\mathit{cv}_{1,1}$, $\mathit{cv}_{1,2}$, $\cdots$, $\mathit{cv}_{1,n}$
in the pointer type \term{T1}, is called the \term{cv-qualification
signature} of the pointer type. An expression of type \term{T1} can be
converted to type \term{T2} if and only if the following conditions are
satisfied:

\begin{itemize}
\item the pointer types are similar.

\item for every $j > 0$, if \tcode{const} is in $\mathit{cv}_{1,j}$ then \tcode{const} is in $\mathit{cv}_{2,j}$, and similarly for \tcode{volatile}.

\item if the $\mathit{cv}_{1,j}$ and $\mathit{cv}_{2,j}$ are different,
then \tcode{const} is in every $\mathit{cv}_{2,k}$ for $0 < k < j$.
\end{itemize}
\end{indented}

\enternote 
if a program could assign a pointer of type \tcode{T**} to a pointer of
type \tcode{const} \tcode{T**} (that is, if line \tcode{//1} below was
allowed), a program could inadvertently modify a \tcode{const} object
(as it is done on line \tcode{//2}). For example,

\begin{codeblock}
int main() {
	const char c = 'c';
	char* pc;
	const char** pcc = &pc;		// 1: not allowed
	*pcc = &c;
	*pc = 'C';              // 2: modifies a \tcode{const} object
}
\end{codeblock}
\exitnoteb


\pnum
\indextext{type!multi-level pointer to member}%
\indextext{type!multi-level mixed pointer and pointer to member}%
A \term{multi-level} pointer to member type, or a
\term{multi-level mixed} pointer and pointer to member type has the
form:

\begin{indented}
$\mathit{cv}_0 P_0$ to $\mathit{cv}_1P_1$ to $\cdots$ $\mathit{cv}_{n-1}P_{n-1}$
to $\mathit{cv}_n$ \term{T}
\end{indented}

where $P_i$ is either a pointer or pointer to member and where \term{T}
is not a pointer type or pointer to member type.

\pnum
Two multi-level pointer to member types or two multi-level mixed pointer
and pointer to member types T1 and T2 are \term{similar} if there
exists a type \term{T} and integer $n > 0$ such that:

\begin{indented}
\term{T1} is $\mathit{cv}_{1,0}P_0$ to $\mathit{cv}_{1,1}P_1$
to $\cdots$ $\mathit{cv}_{1,n-1}P_{n-1}$ to $\mathit{cv}_{1,n}$ \term{T}
\end{indented}

and

\begin{indented}
\term{T2} is $\mathit{cv}_{2,0}P_0$ to $\mathit{cv}_{2,1}P_1$
to $\cdots$ $\mathit{cv}_{2,n-1}P_{n-1}$ to $\mathit{cv}_{2,n}$ \term{T}
\end{indented}

\pnum
For similar multi-level pointer to member types and similar multi-level
mixed pointer and pointer to member types, the rules for adding
cv-qualifiers are the same as those used for similar pointer types.%
\indextext{conversion!qualification|)}

\rSec1[conv.prom]{Integral promotions}

\pnum
\indextext{promotion!integral}%
An rvalue of type \tcode{char}, \tcode{signed char}, \tcode{unsigned char},
\tcode{short int}, or \tcode{unsigned short int} can be
converted to an rvalue of type \tcode{int} if \tcode{int} can represent
all the values of the source type; otherwise, the source rvalue can be
converted to an rvalue of type \tcode{unsigned int}.

\pnum
An rvalue of type \tcode{wchar_t}~(\ref{basic.fundamental}) or an
enumeration type~(\ref{dcl.enum}) can be converted to an rvalue of
the first of the following types that can represent all the values
of its underlying type: \tcode{int}, \tcode{unsigned int},
\tcode{long}, or \tcode{unsigned long}.

\pnum
An rvalue for an integral bit-field~(\ref{class.bit}) can be converted
to an rvalue of type \tcode{int} if \tcode{int} can represent all the
values of the bit-field; otherwise, it can be converted to
\tcode{unsigned int} if \tcode{unsigned int} can represent all the
values of the bit-field. If the bit-field is larger yet, no integral
promotion applies to it. If the bit-field has an enumerated type, it is
treated as any other value of that type for promotion purposes.

\pnum
\indextext{promotion!bool to int}%
An rvalue of type \tcode{bool} can be converted to an rvalue of type
\tcode{int}, with \tcode{false} becoming zero and \tcode{true} becoming
one.

\pnum
These conversions are called \term{integral promotions}.

\rSec1[conv.fpprom]{Floating point promotion}

\pnum
\indextext{promotion!floating~point}%
An rvalue of type \tcode{float} can be converted to an rvalue of type
\tcode{double}. The value is unchanged.

\pnum
This conversion is called \term{floating point promotion}.

\rSec1[conv.integral]{Integral conversions}

\pnum
\indextext{conversion!integral}%
An rvalue of an integer type can be converted to an rvalue of another
integer type. An rvalue of an enumeration type can be converted to
an rvalue of an integer type.

\pnum
\indextext{conversion!to unsigned}%
If the destination type is unsigned, the resulting value is the least
unsigned integer congruent to the source integer (modulo $2^n$ where $n$
is the number of bits used to represent the unsigned type).
\enternote 
In a two's complement representation, this conversion is conceptual and
there is no change in the bit pattern (if there is no truncation).
\exitnote 

\pnum
\indextext{conversion!to signed}%
If the destination type is signed, the value is unchanged if it can be
represented in the destination type (and bit-field width); otherwise,
the value is \impldef{value of result of unsigned to signed conversion}.

\pnum
\indextext{conversion!bool@\tcode{bool}}%
If the destination type is \tcode{bool}, see~\ref{conv.bool}. If the
source type is \tcode{bool}, the value \tcode{false} is converted to
zero and the value \tcode{true} is converted to one.

\pnum
The conversions allowed as integral promotions are excluded from the set
of integral conversions.

\rSec1[conv.double]{Floating point conversions}

\pnum
\indextext{conversion!floating~point}%
An rvalue of floating point type can be converted to an rvalue of
another floating point type. If the source value can be exactly
represented in the destination type, the result of the conversion is
that exact representation. If the source value is between two adjacent
destination values, the result of the conversion is an
\impldef{result of inexact floating-point conversion} choice of either of those values.
Otherwise, the behavior is undefined.

\pnum
The conversions allowed as floating point promotions are excluded from
the set of floating point conversions.

\rSec1[conv.fpint]{Floating-integral conversions}

\pnum
\indextext{conversion!floating~to~integral}%
An rvalue of a floating point type can be converted to an rvalue of an
integer type. The conversion truncates; that is, the fractional part is
discarded.
\indextext{value!undefined unrepresentable integral}%
The behavior is undefined if the truncated value cannot be represented
in the destination type.
\enternote 
If the destination type is \tcode{bool}, see~\ref{conv.bool}.
\exitnote 

\pnum
\indextext{conversion!integral~to~floating}%
\indextext{truncation}%
\indextext{rounding}%
An rvalue of an integer type or of an enumeration type can be converted to
an rvalue of a floating point type. The result is exact if possible.
Otherwise, it is an \impldef{value of result of inexact integer to
floating-point conversion} choice of either the next lower or higher representable
value. \enternote loss of precision occurs if the integral value cannot be represented
exactly as a value of the floating type. \exitnote If the
source type is \tcode{bool}, the value \tcode{false} is converted to zero and the value
\tcode{true} is converted to one.

\rSec1[conv.ptr]{Pointer conversions}

\pnum
\indextext{conversion!pointer}%
\indextext{pointer!zero}%
\indextext{constant!null pointer}%
\indextext{value!null pointer}%
A \term{null pointer constant} is an integral constant
expression~(\ref{expr.const}) rvalue of integer type that evaluates to zero.
A null pointer constant can be converted to a pointer type; the
result is the \term{null pointer value} of that type and is
distinguishable from every other value of
pointer to object or pointer to function type.
Two null pointer values of the same type shall compare
equal. The conversion of a null pointer constant to a pointer to
cv-qualified type is a single conversion, and not the sequence of a
pointer conversion followed by a qualification
conversion~(\ref{conv.qual}).

\pnum
An rvalue of type ``pointer to \cvqual{cv} \tcode{T},'' where \tcode{T}
is an object type, can be converted to an rvalue of type ``pointer to
\cvqual{cv} \tcode{void}.'' The result of converting a ``pointer to
\cvqual{cv} \tcode{T}'' to a ``pointer to \cvqual{cv} \tcode{void}''
points to the start of the storage location where the object of type
\tcode{T} resides, as if the object is a most derived
object~(\ref{intro.object}) of type \tcode{T} (that is, not a base class
subobject).

\pnum
An rvalue of type ``pointer to \cvqual{cv} \tcode{D},'' where \tcode{D}
is a class type, can be converted to an rvalue of type ``pointer to
\cvqual{cv} \tcode{B},'' where \tcode{B} is a base class
(clause~\ref{class.derived}) of \tcode{D}. If \tcode{B} is an
inaccessible (clause~\ref{class.access}) or
ambiguous~(\ref{class.member.lookup}) base class of \tcode{D}, a program
that necessitates this conversion is ill-formed. The result of the
conversion is a pointer to the base class sub-object of the derived class
object. The null pointer value is converted to the null pointer value of
the destination type.

\rSec1[conv.mem]{Pointer to member conversions}

\pnum
\indextext{conversion!pointer to member}%
\indextext{constant!null pointer}%
\indextext{value!null member pointer}%
A null pointer constant~(\ref{conv.ptr}) can be converted to a pointer
to member type; the result is the \term{null member pointer value}
of that type and is distinguishable from any pointer to member not
created from a null pointer constant. Two null member pointer values of
the same type shall compare equal. The conversion of a null pointer
constant to a pointer to member of cv-qualified type is a single
conversion, and not the sequence of a pointer to member conversion
followed by a qualification conversion~(\ref{conv.qual}).

\pnum
An rvalue of type ``pointer to member of \tcode{B} of type \cvqual{cv}
\tcode{T},'' where \tcode{B} is a class type, can be converted to
an rvalue of type ``pointer to member of \tcode{D} of type \cvqual{cv}
\tcode{T},'' where \tcode{D} is a derived class
(clause~\ref{class.derived}) of \tcode{B}. If \tcode{B} is an
inaccessible (clause~\ref{class.access}),
ambiguous~(\ref{class.member.lookup}), or virtual~(\ref{class.mi}) base
class of \tcode{D}, a program that necessitates this conversion is ill-formed.
The result of the conversion refers to the same member as the pointer to
member before the conversion took place, but it refers to the base class
member as if it were a member of the derived class. The result refers to
the member in \tcode{D}'s instance of \tcode{B}. Since the result has
type ``pointer to member of \tcode{D} of type \cvqual{cv} \tcode{T},''
it can be dereferenced with a \tcode{D} object. The result is the same
as if the pointer to member of \tcode{B} were dereferenced with the
\tcode{B} sub-object of \tcode{D}. The null member pointer value is
converted to the null member pointer value of the destination
type.\footnote{The rule for conversion of pointers to members (from pointer to member
of base to pointer to member of derived) appears inverted compared to
the rule for pointers to objects (from pointer to derived to pointer to
base)~(\ref{conv.ptr}, clause~\ref{class.derived}). This inversion is
necessary to ensure type safety. Note that a pointer to member is not
a pointer to object or a pointer to function and the rules for conversions
of such pointers do not apply to pointers to members.
\indextext{conversion!pointer to member!\idxcode{void*}}%
In particular, a pointer to member cannot be converted to a
\tcode{void*}.}

\rSec1[conv.bool]{Boolean conversions}

\pnum
\indextext{conversion!boolean}%
An rvalue of arithmetic, enumeration, pointer, or pointer to member
type can be converted to an rvalue of type \tcode{bool}. A zero value, null
pointer value, or null member pointer value is converted to \tcode{false}; any
other value is converted to \tcode{true}.
