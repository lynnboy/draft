\rSec0[lib.utilities]{General utilities library}

\pnum
This clause describes components used by other elements of the
Standard \Cpp library.
These components may also be used by \Cpp programs.

\pnum
The following clauses describe utility and allocator requirements, utility
components, function objects, dynamic memory management utilities, and date/time
utilities, as summized in Table~\ref{tab:util.lib.summary}:

\begin{libsumtab}{General utilities library summary}{tab:util.lib.summary}
\ref{lib.utility.requirements}  & Requirements           & \\ \rowsep
\ref{lib.utility}               & Utility components                & \tcode{<utility>}     \\ \rowsep
\ref{lib.function.objects}      & Function objects                  & \tcode{<functional>}  \\ \rowsep
\ref{lib.memory}                & Memory                            & \tcode{<memory>}     \\ \rowsep
\ref{lib.date.time}             & Date and time                     & \tcode{<ctime>}       \\
\end{libsumtab}

\rSec1[lib.utility.requirements]{Requirements}

\pnum
\ref{lib.utility.requirements}
describes requirements on template arguments.
\ref{lib.equalitycomparable} through
\ref{lib.copyconstructible}
describe requirements on types used to instantiate templates.
\ref{lib.allocator.requirements} describes the requirements on storage
allocators.

\rSec2[lib.equalitycomparable]{Equality comparison}

\pnum
In Table~\ref{equalitycomparable}, \tcode{T} is a type to be supplied by a
\Cpp program instantiating a template, \tcode{a}, \tcode{b} and \tcode{c}
are values of type \tcode{T}.

\indextext{requirements!\idxcode{EqualityComparable}}%
\begin{concepttable}{\tcode{EqualityComparable} requirements}{equalitycomparable}
{x{1in}x{1in}p{3in}}
\topline
expression  &   return type &   \multicolumn{1}{c|}{requirement} \\ \capsep
\tcode{a == b}  &
convertible to \tcode{bool} &
\tcode{==} is an equivalence relation,
that is, it satisfies the following properties:
\begin{itemize}
\item
For all \tcode{a}, \tcode{a == a}.
\item
If \tcode{a == b}, then \tcode{b == a}.
\item
If \tcode{a == b} and \tcode{b == c}, then \tcode{a == c}.
\end{itemize} \\
\end{concepttable}

\rSec2[lib.lessthancomparable]{Less than comparison}

\pnum
In the following Table~\ref{lessthancomparable}, \tcode{T} is a type to be supplied by a
\Cpp program instantiating a template, \tcode{a} and \tcode{b}
are values of type \tcode{T}.

\indextext{requirements!\idxcode{LessThanComparable}}%
\begin{concepttable}{\tcode{LessThanComparable} requirements}{lessthancomparable}
{x{1in}x{1in}p{3in}}
\topline
expression  &   return type &   requirement \\ \capsep
\tcode{a < b}   &
convertible to \tcode{bool} &
\tcode{<} is a strict weak ordering relation~(\ref{lib.alg.sorting})    \\
\end{concepttable}

\rSec2[lib.copyconstructible]{Copy constructible}

\pnum
In the following Table~\ref{copyconstructible}, \tcode{T} is a type to be supplied by a
\Cpp program instantiating a template, \tcode{t} is a value of type \tcode{T},
and \tcode{u} is a value of type \tcode{const T}.

\indextext{requirements!\idxcode{CopyConstructible}}%
\begin{concepttable}{\tcode{CopyConstructible} requirements}{copyconstructible}
{x{1in}x{1in}p{3in}}
\topline
expression          &   return type     & requirement  \\ \capsep
\tcode{T(t)}        &  & \tcode{t} is equivalent to \tcode{T(t)} \\ \capsep
\tcode{T(u)}        &  & \tcode{u} is equivalent to \tcode{T(u)} \\ \capsep
\tcode{t.~T()}        &  &  \\ \capsep
\tcode{\&t}         &  \tcode{T*} & denotes the address of \tcode{t} \\ \capsep
\tcode{\&u}         &  \tcode{const T*} & denotes the address of \tcode{u} \\
\end{concepttable}

\rSec2[lib.default.con.req]{Default construction}

\pnum
The default constructor is not required.
Certain container class member function signatures specify the
default constructor as a default argument.
\tcode{T()} shall be a well-defined expression~(\ref{dcl.init}) if one of
those signatures is called using the default argument~(\ref{dcl.fct.default}).

\rSec2[lib.allocator.requirements]{Allocator requirements}

\indextext{requirements!\idxcode{Allocator}}%
\pnum
The library describes a standard set of requirements for \techterm{allocators},
which are objects that encapsulate the information about an allocation model.
This information includes the knowledge of pointer types, the type of their
difference, the type of the size of objects in this allocation model, as well
as the memory allocation and deallocation primitives for it. All of the
containers (clause~\ref{lib.containers}) are parameterized in terms of
allocators.

\pnum
Table~\ref{tab:desc.var.def} describes the requirements on types manipulated
through allocators. All the operations on the allocators are expected to be
amortized constant time.
Table~\ref{tab:utilities.allocator.requirements}
describes the requirements on allocator types.

\begin{libreqtab2}
{Descriptive variable definitions}
{tab:desc.var.def}
\\ \topline
\lhdr{Variable} &   \rhdr{Definition}   \\  \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{Variable} &   \rhdr{Definition}   \\  \capsep
\endhead
\tcode{T, U}    &   any type       \\ \rowsep
\tcode{X}       &   an Allocator class for type \tcode{T}   \\ \rowsep
\tcode{Y}       &   the corresponding Allocator class for type \tcode{U}    \\ \rowsep
\tcode{t}       &   a value of type \tcode{const T\&}   \\ \rowsep
\tcode{a, a1, a2}   &   values of type \tcode{X\&}      \\ \rowsep
\tcode{b}       &   a value of type \tcode{Y}           \\ \rowsep
\tcode{p}       &   a value of type \tcode{X::pointer}, obtained
by calling \tcode{a1.allocate}, where \tcode{a1 == a}   \\ \rowsep
\tcode{q}       &   a value of type \tcode{X::const_pointer}
obtained by conversion from a value \tcode{p}.          \\ \rowsep
\tcode{r}       &   a value of type \tcode{X::reference}
obtained by the expression \tcode{*p}.                  \\ \rowsep
\tcode{s}       &   a value of type \tcode{X::const_reference}
obtained by the expression \tcode{*q} or by conversion from
a value \tcode{r}.                                      \\ \rowsep
\tcode{u}       &   a value of type \tcode{Y::const_pointer}
obtained by calling \tcode{Y::allocate}, or else 0. \\ \rowsep
\tcode{n}       &   a value of type \tcode{X::size_type}.   \\
\end{libreqtab2}

\begin{libreqtab3d}
{Allocator requirements}
{tab:utilities.allocator.requirements}
\\ \topline
\lhdr{expression}   &   \chdr{return type}  &   \chdr{assertion/note}      \\
                    &                       &   \chdr{pre/post-condition}  \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{expression}   &   \chdr{return type}  &   \chdr{assertion/note}       \\
                    &                       &   \chdr{pre/post-condition}  \\ \capsep
\endhead
\tcode{X::pointer}          &
  Pointer to \tcode{T}.     &   \\ \rowsep
\tcode{X::const_pointer}    &
  Pointer to \tcode{const T}.    &   \\ \rowsep
\tcode{X::reference}        &
  \tcode{T\&}.              &   \\ \rowsep
\tcode{X::const_reference}  &
  \tcode{T const\&}.        &   \\ \rowsep
\tcode{X::value_type}       &
  Identical to \tcode{T}    &   \\ \rowsep
\tcode{X::size_type}        &
  unsigned integer type     &
  a type that can represent the size of the largest object in the allocation model. \\ \rowsep
\tcode{X::difference_type}  &
  signed integer type       &
  a type that can represent the difference between any two pointers
    in the allocation model.\\ \rowsep
\tcode{typename X::template rebind<U>::other}   &
  \tcode{Y}                 &
  For all \tcode{U} (including \tcode{T}), \tcode{Y::template rebind<T>::other}
    is \tcode{X}.           \\ \rowsep
\tcode{a.address(r)}        &
  \tcode{X::pointer}        &  \\ \rowsep
\tcode{a.address(s)}        &
  \tcode{X::const_pointer}  &  \\ \rowsep
\tcode{a.allocate(n)} \br
\tcode{a.allocate(n, u)}    &
  \tcode{X::pointer}  &
  Memory is allocated for \tcode{n} objects of type \tcode{T} but objects
    are not constructed. \tcode{allocate} may raise an appropriate exception.
    The result is a random access iterator.\footnotemark
    \enternote
    If \tcode{n == 0}, the return value is unspecified.
    \exitnote               \\ \rowsep
\tcode{a.deallocate(p, n)}   &
  (not used)                &
  All \tcode{n T} objects in the area pointed to by \tcode{p} shall be
    destroyed prior to this call. \tcode{n} shall match the value passed to
    \tcode{allocate} to obtain this memory. Does not throw exceptions.
    \enternote \tcode{p} shall not be null. \exitnote   \\ \rowsep
\tcode{a.max_size()}        &
  \tcode{X::size_type}      &
  the largest value that can meaningfully be passed to \tcode{X::allocate()}  \\ \rowsep
\tcode{a1 == a2}            &
  \tcode{bool}              &
  returns \tcode{true} iff storage allocated from each can
    be deallocated via the other. \\ \rowsep
\tcode{a1 != a2}            &
  \tcode{bool}              &
  same as \tcode{!(a1 == a2)}     \\ \rowsep
\tcode{X()};                &
                            &
  creates a default instance. Note: a destructor is assumed.  \\ \rowsep
\tcode{X a(b);}             &
                            &
  post: \tcode{Y(a) == b}   \\ \rowsep

\tcode{a.construct(p,t)}    &
  (not used)                &
  Effect: \tcode{new((void*)p) T(t)}  \\ \rowsep
\tcode{a.destroy(p)}        &
  (not used)                &
  Effect: \tcode{((T*)p)->\~{}T()}    \\

\end{libreqtab3d}

\footnotetext{It is intended that \tcode{a.allocate} be an efficient means
of allocating a single object of type \tcode{T}, even when \tcode{sizeof(T)}
is small. That is, there is no need for a container to maintain its own
``free list''.}

\pnum
The member class template \tcode{rebind} in the table above is
effectively a typedef template: if
the name \tcode{Allocator} is bound to \tcode{SomeAllocator<T>}, then
\tcode{Allocator::rebind<U>::other} is the same type as
\tcode{SomeAllocator<U>}.

\pnum
Implementations of containers described in this International Standard are
permitted to assume that their Allocator template parameter meets the following
two additional requirements beyond those in Table~\ref{tab:utilities.allocator.requirements}.

\begin{itemize}
\item All instances of a given allocator type are required to be interchangeable
and always compare equal to each other.
\item The typedef members \tcode{pointer}, \tcode{const_pointer},
\tcode{size_type}, and \tcode{difference_type} are required to be \tcode{T*},
\tcode{T const*}, \tcode{size_t}, and \tcode{ptrdiff_t}, respectively.
\end{itemize}

\pnum
Implementors are encouraged to supply libraries that can accept allocators that
encapsulate more general memory models and that support non-equal instances.
In such implementations, any requirements imposed on allocators by containers
beyond those requirements that appear in Table~\ref{tab:utilities.allocator.requirements},
and the semantics of containers and algorithms when allocator instances compare
non-equal, are implementation-defined.

\rSec1[lib.utility]{Utility components}

\pnum
This subclause contains some basic function and class templates that are used
throughout the rest of the library.

\indexlibrary{\idxhdr{utility}}%
\indexlibrary{\idxcode{rel_ops}}%
\synopsis{Header \tcode{<utility>} synopsis}

\begin{codeblock}
namespace std {
  // \ref{lib.operators}, operators:
  namespace rel_ops {
    template<class T> bool operator!=(const T&, const T&);
    template<class T> bool operator> (const T&, const T&);
    template<class T> bool operator<=(const T&, const T&);
    template<class T> bool operator>=(const T&, const T&);
  }

  // \ref{lib.pairs}, pairs:
  template <class T1, class T2> struct pair;
  template <class T1, class T2>
    bool operator==(const pair<T1,T2>&, const pair<T1,T2>&);
  template <class T1, class T2>
    bool operator< (const pair<T1,T2>&, const pair<T1,T2>&);
  template <class T1, class T2>
    bool operator!=(const pair<T1,T2>&, const pair<T1,T2>&);
  template <class T1, class T2>
    bool operator> (const pair<T1,T2>&, const pair<T1,T2>&);
  template <class T1, class T2>
    bool operator>=(const pair<T1,T2>&, const pair<T1,T2>&);
  template <class T1, class T2>
    bool operator<=(const pair<T1,T2>&, const pair<T1,T2>&);
  template <class T1, class T2> pair<T1,T2> make_pair(T1, T2);
}
\end{codeblock}

\rSec2[lib.operators]{Operators}

\pnum
To avoid redundant definitions of \tcode{operator!=} out of \tcode{operator==}
and operators \tcode{>}, \tcode{<=}, and \tcode{>=} out of \tcode{operator<},
the library provides the following:

\indexlibrary{\idxcode{operator"!=}}%
\begin{itemdecl}
template <class T> bool operator!=(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Type \tcode{T} is \tcode{EqualityComparable} (\ref{lib.equalitycomparable}).

\pnum
\returns
\tcode{!(x == y)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>}}%
\begin{itemdecl}
template <class T> bool operator>(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Type \tcode{T} is \tcode{LessThanComparable} (\ref{lib.lessthancomparable}).

\pnum
\returns
\tcode{y < x}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}}%
\begin{itemdecl}
template <class T> bool operator<=(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Type \tcode{T} is \tcode{LessThanComparable} (\ref{lib.lessthancomparable}).

\pnum
\returns
\tcode{!(y < x)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}}%
\begin{itemdecl}
template <class T> bool operator>=(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
Type \tcode{T} is \tcode{LessThanComparable} (\ref{lib.lessthancomparable}).

\pnum
\returns
\tcode{!(x < y)}.
\end{itemdescr}

\pnum
In this library, whenever a declaration is provided for an \tcode{operator!=},
\tcode{operator>}, \tcode{operator>=}, or \tcode{operator<=},
and requirements and semantics are not explicitly provided,
the requirements and semantics are as specified in this clause.

\rSec2[lib.pairs]{Pairs}

\pnum
The library provides a template for heterogeneous pairs of values.
The library also provides a matching function template to simplify
their construction.%
\indexlibrary{\idxcode{pair}}%

\begin{codeblock}
template <class T1, class T2>
struct pair {
  typedef T1 first_type;
  typedef T2 second_type;

  T1 first;
  T2 second;
  pair();
  pair(const T1& x, const T2& y);
  template<class U, class V> pair(const pair<U, V> &p);
};
\end{codeblock}

\indexlibrary{\idxcode{pair}!\idxcode{pair}}
\indexlibrary{\idxcode{pair}!\idxcode{pair}}
\begin{itemdecl}
pair();
\end{itemdecl}

\pnum
\begin{itemdescr}
\effects
Initializes its members as if implemented:
\tcode{pair() : first(T1()), second(T2())}
\end{itemdescr}

\indexlibrary{\idxcode{pair}!\idxcode{pair}}
\indexlibrary{\idxcode{pair}!\idxcode{pair}}
\begin{itemdecl}
pair(const T1& x, const T2& y);
\end{itemdecl}

\pnum
\begin{itemdescr}
\effects
The constructor initializes \tcode{first} with \tcode{x} and \tcode{second}
with \tcode{y}.
\end{itemdescr}

\indexlibrary{\idxcode{pair}!\idxcode{pair}}
\indexlibrary{\idxcode{pair}!\idxcode{pair}}
\begin{itemdecl}
template<class U, class V> pair(const pair<U, V> &p);
\end{itemdecl}

\pnum
\begin{itemdescr}
\effects
Initializes members from the corresponding members of the argument,
performing implicit conversions as needed.
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\tcode{pair}}%
\begin{itemdecl}
template <class T1, class T2>
  bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.first == y.first \&\& x.second == y.second}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\tcode{pair}}%
\begin{itemdecl}
template <class T1, class T2>
  bool operator<(const pair<T1, T2>& x, const pair<T1, T2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.first < y.first || (!(y.first < x.first) \&\& x.second < y.second)}.
\end{itemdescr}

\indexlibrary{\idxcode{make_pair}}%
\begin{itemdecl}
template <class T1, class T2>
  pair<T1, T2> make_pair(T1 x, T2 y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{pair<T1, T2>(x, y)}.\footnote[214]
{According to (\ref{class.copy}),
an implementation is permitted to not perform a copy of an argument, thus
avoiding unnecessary copies.}$^a$

\pnum
\enterexample
In place of:

\begin{codeblock}
  return pair<int, double>(5, 3.1415926);   // explicit types
\end{codeblock}

a \Cpp program may contain:

\begin{codeblock}
  return make_pair(5, 3.1415926);           // types are deduced
\end{codeblock}
\exitexampleb
\end{itemdescr}

\rSec1[lib.function.objects]{Function objects}

\pnum
Function objects are objects with an \tcode{operator()} defined. They are
important for the effective use of the library. In the places where one would
expect to pass a pointer to a function to an algorithmic template
(clause~\ref{lib.algorithms}), the interface is specified to accept an object
with an \tcode{operator()} defined. This not only makes
algorithmic templates work with pointers to functions, but also enables them to
work with arbitrary function objects.

\synopsis{Header \tcode{<functional>} synopsis}

\indexlibrary{\idxhdr{functional}}%
\begin{codeblock}
namespace std {
  // \ref{lib.base}, base:
  template <class Arg, class Result> struct unary_function;
  template <class Arg1, class Arg2, class Result> struct binary_function;

  // \ref{lib.arithmetic.operations}, arithmetic operations:
  template <class T> struct plus;
  template <class T> struct minus;
  template <class T> struct multiplies;
  template <class T> struct divides;
  template <class T> struct modulus;
  template <class T> struct negate;

  // \ref{lib.comparisons}, comparisons:
  template <class T> struct equal_to;
  template <class T> struct not_equal_to;
  template <class T> struct greater;
  template <class T> struct less;
  template <class T> struct greater_equal;
  template <class T> struct less_equal;

  // \ref{lib.logical.operations}, logical operations:
  template <class T> struct logical_and;
  template <class T> struct logical_or;
  template <class T> struct logical_not;

  // \ref{lib.negators}, negators:
  template <class Predicate> struct unary_negate;
  template <class Predicate>
    unary_negate<Predicate>  not1(const Predicate&);
  template <class Predicate> struct binary_negate;
  template <class Predicate>
    binary_negate<Predicate> not2(const Predicate&);

  // \ref{lib.binders}, binders:
  template <class Operation>  class binder1st;
  template <class Operation, class T>
    binder1st<Operation> bind1st(const Operation&, const T&);
  template <class Operation> class binder2nd;
  template <class Operation, class T>
    binder2nd<Operation> bind2nd(const Operation&, const T&);

  // \ref{lib.function.pointer.adaptors}, adaptors:
  template <class Arg, class Result> class pointer_to_unary_function;
  template <class Arg, class Result>
    pointer_to_unary_function<Arg,Result> ptr_fun(Result (*)(Arg));
  template <class Arg1, class Arg2, class Result>
    class pointer_to_binary_function;
  template <class Arg1, class Arg2, class Result>
    pointer_to_binary_function<Arg1,Arg2,Result>
      ptr_fun(Result (*)(Arg1,Arg2));

  // \ref{lib.member.pointer.adaptors}, adaptors:
  template<class S, class T> class mem_fun_t;
  template<class S, class T, class A> class mem_fun1_t;
  template<class S, class T>
      mem_fun_t<S,T> mem_fun(S (T::*f)());
  template<class S, class T, class A>
      mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A));
  template<class S, class T> class mem_fun_ref_t;
  template<class S, class T, class A> class mem_fun1_ref_t;
  template<class S, class T>
      mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)());
  template<class S, class T, class A>
      mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A));

  template <class S, class T> class const_mem_fun_t;
  template <class S, class T, class A> class const_mem_fun1_t;
  template <class S, class T>
    const_mem_fun_t<S,T> mem_fun(S (T::*f)() const);
  template <class S, class T, class A>
    const_mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A) const);
  template <class S, class T> class const_mem_fun_ref_t;
  template <class S, class T, class A> class const_mem_fun1_ref_t;
  template <class S, class T>
    const_mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)() const);
  template <class S, class T, class A>
    const_mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A) const);
}
\end{codeblock}

\pnum
Using function objects together with function templates increases the
expressive power of the library as well as making the resulting code much
more efficient.

\pnum
\enterexample
If a \Cpp program wants to have a by-element addition of two vectors \tcode{a}
and \tcode{b} containing \tcode{double} and put the result into \tcode{a},
it can do:

\begin{codeblock}
transform(a.begin(), a.end(), b.begin(), a.begin(), plus<double>());
\end{codeblock}
\exitexampleb

\pnum
\enterexample
To negate every element of \tcode{a}:

\begin{codeblock}
transform(a.begin(), a.end(), a.begin(), negate<double>());
\end{codeblock}

The corresponding functions will inline the addition and the negation.
\exitexampleb

\pnum
To enable adaptors and other components to manipulate function objects that take
one or two arguments it is required that the function objects
correspondingly provide typedefs
\tcode{argument_type}
and
\tcode{result_type}
for function objects that take one argument and \tcode{first_argument_type},
\tcode{second_argument_type}, and \tcode{result_type} for function objects
that take two arguments.

\rSec2[lib.base]{Base}

\pnum
The following classes are provided to simplify the typedefs of the argument
and result types.

\indexlibrary{\idxcode{unary_function}}%
\begin{codeblock}
template <class Arg, class Result>
struct unary_function {
  typedef Arg    argument_type;
  typedef Result result_type;
};
\end{codeblock}

\indexlibrary{\idxcode{binary_function}}%
\begin{codeblock}
template <class Arg1, class Arg2, class Result>
struct binary_function {
  typedef Arg1   first_argument_type;
  typedef Arg2   second_argument_type;
  typedef Result result_type;
};
\end{codeblock}

\rSec2[lib.arithmetic.operations]{Arithmetic operations}

\pnum
The library provides basic function object classes for all of the arithmetic
operators in the language~(\ref{expr.mul}, \ref{expr.add}).

\indexlibrary{\idxcode{plus}}%
\begin{itemdecl}
template <class T> struct plus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()}
returns
\tcode{x + y}.
\end{itemdescr}

\indexlibrary{\idxcode{minus}}%
\begin{itemdecl}
template <class T> struct minus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()}
returns
\tcode{x - y}.
\end{itemdescr}

\indexlibrary{\idxcode{multiplies}}%
\begin{itemdecl}
template <class T> struct multiplies : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()}
returns
\tcode{x * y}.
\end{itemdescr}

\indexlibrary{\idxcode{divides}}%
\begin{itemdecl}
template <class T> struct divides : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()}
returns
\tcode{x / y}.
\end{itemdescr}

\indexlibrary{\idxcode{modulus}}%
\begin{itemdecl}
template <class T> struct modulus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{x \% y}.
\end{itemdescr}

\indexlibrary{\idxcode{negate}}%
\begin{itemdecl}
template <class T> struct negate : unary_function<T,T> {
  T operator()(const T& x) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{-x}.
\end{itemdescr}

\rSec2[lib.comparisons]{Comparisons}

\pnum
The library provides basic function object classes for all of the comparison
operators in the language~(\ref{expr.rel}, \ref{expr.eq}).

\indexlibrary{\idxcode{equal_to}}%
\begin{itemdecl}
template <class T> struct equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{x == y}.
\end{itemdescr}

\indexlibrary{\idxcode{not_equal_to}}%
\begin{itemdecl}
template <class T> struct not_equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{x != y}.
\end{itemdescr}

\indexlibrary{\idxcode{greater}}%
\begin{itemdecl}
template <class T> struct greater : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{x > y}.
\end{itemdescr}

\indexlibrary{\idxcode{less}}%
\begin{itemdecl}
template <class T> struct less : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{x < y}.
\end{itemdescr}

\indexlibrary{\idxcode{greater_equal}}%
\begin{itemdecl}
template <class T> struct greater_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{x >= y}.
\end{itemdescr}

\indexlibrary{\idxcode{less_equal}}%
\begin{itemdecl}
template <class T> struct less_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{x <= y}.
\end{itemdescr}

\pnum
For templates \tcode{greater}, \tcode{less}, \tcode{greater_equal}, and
\tcode{less_equal}, the specializations for any pointer type yield a total order,
even if the built-in operators \tcode{<}, \tcode{>}, \tcode{<=}, \tcode{>=}
do not.

\rSec2[lib.logical.operations]{Logical operations}

\pnum
The library provides basic function object classes for all of the logical
operators in the language~(\ref{expr.log.and}, \ref{expr.log.or}, \ref{expr.unary.op}).

\indexlibrary{\idxcode{logical_and}}%
\begin{itemdecl}
template <class T> struct logical_and : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{x \&\& y}.
\end{itemdescr}

\indexlibrary{\idxcode{logical_or}}%
\begin{itemdecl}
template <class T> struct logical_or : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{x || y}.
\end{itemdescr}

\indexlibrary{\idxcode{logical_not}}%
\begin{itemdecl}
template <class T> struct logical_not : unary_function<T,bool> {
  bool operator()(const T& x) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{!x}.
\end{itemdescr}

\rSec2[lib.negators]{Negators}

\pnum
Negators \tcode{not1} and \tcode{not2} take a unary and a binary predicate,
respectively, and return their complements~(\ref{expr.unary.op}).

\indexlibrary{\idxcode{unary_negate}}%
\begin{itemdecl}
template <class Predicate>
  class unary_negate
    : public unary_function<typename Predicate::argument_type,bool> {
public:
  explicit unary_negate(const Predicate& pred);
  bool operator()(const typename Predicate::argument_type& x) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{!pred(x)}.
\end{itemdescr}

\indexlibrary{\idxcode{not1}}%
\begin{itemdecl}
template <class Predicate>
  unary_negate<Predicate> not1(const Predicate& pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{unary_negate<Predicate>(pred)}.
\end{itemdescr}

\indexlibrary{\idxcode{binary_negate}}%
\begin{itemdecl}
template <class Predicate>
  class binary_negate
    : public binary_function<typename Predicate::first_argument_type,
        typename Predicate::second_argument_type, bool> {
  public:
    explicit binary_negate(const Predicate& pred);
    bool operator()(const typename Predicate::first_argument_type&  x,
        const typename Predicate::second_argument_type& y) const;
  };
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{!pred(x,y)}.
\end{itemdescr}

\indexlibrary{\idxcode{not2}}%
\begin{itemdecl}
template <class Predicate>
  binary_negate<Predicate> not2(const Predicate& pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{binary_negate<Predicate>(pred)}.
\end{itemdescr}

\rSec2[lib.binders]{Binders}

\pnum
Binders \tcode{bind1st} and \tcode{bind2nd} take a function object \tcode{f}
of two arguments and a value \tcode{x} and return a function object of one
argument constructed out of \tcode{f} with the first or second argument
correspondingly bound to \tcode{x}.

\rSec3[lib.binder.1st]{Class template \tcode{binder1st}}

\indexlibrary{\idxcode{binder1st}}%
\begin{itemdecl}
  template <class Operation>
  class binder1st
    : public unary_function<typename Operation::second_argument_type,
                            typename Operation::result_type> {
  protected:
    Operation                      op;
    typename Operation::first_argument_type value;

  public:
    binder1st(const Operation& x,
              const typename Operation::first_argument_type& y);
    typename Operation::result_type
      operator()(const typename Operation::second_argument_type& x) const;
  };
\end{itemdecl}

\begin{itemdescr}
\pnum
The constructor initializes \tcode{op} with \tcode{x} and \tcode{value}
with \tcode{y}.

\pnum
\tcode{operator()} returns \tcode{op}\tcode{(value,x)}.
\end{itemdescr}

\rSec3[lib.bind.1st]{\tcode{bind1st}}

\indexlibrary{\idxcode{bind1st}}%
\begin{itemdecl}
template <class Operation, class T>
  binder1st<Operation> bind1st(const Operation& op, const T& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{binder1st<Operation>(op, typename Operation::first_argument_type(x))}.
\end{itemdescr}

\rSec3[lib.binder.2nd]{Class template \tcode{binder2nd}}

\indexlibrary{\idxcode{binder2nd}}%
\begin{itemdecl}
  template <class Operation>
  class binder2nd
    : public unary_function<typename Operation::first_argument_type,
                            typename Operation::result_type> {
  protected:
    Operation                       op;
    typename Operation::second_argument_type value;

  public:
    binder2nd(const Operation& x,
              const typename Operation::second_argument_type& y);
    typename Operation::result_type
      operator()(const typename Operation::first_argument_type& x) const;
  };
\end{itemdecl}

\begin{itemdescr}
\pnum
The constructor initializes \tcode{op} with \tcode{x} and \tcode{value}
with \tcode{y}.

\pnum
\tcode{operator()} returns \tcode{op}\tcode{(x,value)}.
\end{itemdescr}

\rSec3[lib.bind.2nd]{\tcode{bind2nd}}

\indexlibrary{\idxcode{bind2nd}}%
\begin{itemdecl}
template <class Operation, class T>
  binder2nd<Operation> bind2nd(const Operation& op, const T& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{binder2nd<Operation>(op, typename Operation::second_argument_type(x))}.

\pnum
\enterexample
\begin{codeblock}
find_if(v.begin(), v.end(), bind2nd(greater<int>(), 5));
\end{codeblock}

finds the first integer in vector \tcode{v} greater than 5;

\begin{codeblock}
find_if(v.begin(), v.end(), bind1st(greater<int>(), 5));
\end{codeblock}

finds the first integer in \tcode{v} less than 5.
\exitexampleb
\end{itemdescr}

\rSec2[lib.function.pointer.adaptors]{Adaptors for pointers to functions}

\pnum
To allow pointers to (unary and binary) functions to work with function adaptors
the library provides:

\indexlibrary{\idxcode{pointer_to_unary_function}}%
\begin{itemdecl}
  template <class Arg, class Result>
  class pointer_to_unary_function : public unary_function<Arg, Result> {
  public:
    explicit pointer_to_unary_function(Result (*f)(Arg));
    Result operator()(Arg x) const;
  };
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{f(x)}.
\end{itemdescr}

\indexlibrary{\idxcode{ptr_fun}}%
\begin{itemdecl}
template <class Arg, class Result>
  pointer_to_unary_function<Arg, Result> ptr_fun(Result (*f)(Arg));
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{pointer_to_unary_function<Arg, Result>(f)}.
\end{itemdescr}

\indexlibrary{\idxcode{pointer_to_binary_function}}%
\begin{itemdecl}
    template <class Arg1, class Arg2, class Result>
    class pointer_to_binary_function :
      public binary_function<Arg1,Arg2,Result> {
    public:
      explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));
      Result operator()(Arg1 x, Arg2 y) const;
    };
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{f(x,y)}.
\end{itemdescr}

\indexlibrary{\idxcode{ptr_fun}}%
\begin{itemdecl}
template <class Arg1, class Arg2, class Result>
  pointer_to_binary_function<Arg1,Arg2,Result>
    ptr_fun(Result (*f)(Arg1, Arg2));
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{pointer_to_binary_function<Arg1,Arg2,Result>(f)}.

\pnum
\enterexample
\begin{codeblock}
replace_if(v.begin(), v.end(), not1(bind2nd(ptr_fun(strcmp), "C")), "C++");
\end{codeblock}

replaces each \tcode{C} with \tcode{C++} in sequence \tcode{v}.%
\footnote{Implementations that have multiple pointer to function types
provide additional \tcode{ptr_fun} function templates.}
\exitexampleb
\end{itemdescr}

\rSec2[lib.member.pointer.adaptors]{Adaptors for pointers to members}

\pnum
The purpose of the following is to provide the same facilities for pointer to
members as those provided for pointers to functions
in~\ref{lib.function.pointer.adaptors}.

\indexlibrary{\idxcode{mem_fun_t}}%
\begin{itemdecl}
template <class S, class T> class mem_fun_t
        : public unary_function<T*, S> {
public:
  explicit mem_fun_t(S (T::*p)());
  S operator()(T* p) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{mem_fun_t} calls the member function it is initialized with given a pointer
argument.
\end{itemdescr}

\indexlibrary{\idxcode{mem_fun1_t}}%
\begin{itemdecl}
  template <class S, class T, class A> class mem_fun1_t
        : public binary_function<T*, A, S> {
  public:
    explicit mem_fun1_t(S (T::*p)(A));
    S operator()(T* p, A x) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{mem_fun1_t} calls the member function it is initialized with given
a pointer argument and an additional argument of the appropriate type.
\end{itemdescr}

\indexlibrary{\idxcode{mem_fun}}%
\begin{itemdecl}
  template<class S, class T> mem_fun_t<S,T>
     mem_fun(S (T::*f)());

  template<class S, class T, class A> mem_fun1_t<S,T,A>
     mem_fun(S (T::*f)(A));
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{mem_fun(\&X::f)} returns an object through which \tcode{X::f} can be
called given a pointer to an \tcode{X} followed by the argument required for
\tcode{f} (if any).
\end{itemdescr}

\indexlibrary{\idxcode{mem_fun_ref_t}}%
\begin{itemdecl}
  template <class S, class T> class mem_fun_ref_t
        : public unary_function<T, S> {
  public:
    explicit mem_fun_ref_t(S (T::*p)());
    S operator()(T& p) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{mem_fun_ref_t} calls the member function it is initialized with given
a reference argument.
\end{itemdescr}

\indexlibrary{\idxcode{mem_fun1_ref_t}}%
\begin{itemdecl}
  template <class S, class T, class A> class mem_fun1_ref_t
        : public binary_function<T, A, S> {
  public:
    explicit mem_fun1_ref_t(S (T::*p)(A));
    S operator()(T& p, A x) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{mem_fun1_ref_t} calls the member function it is initialized with
given a reference argument and an additional argument of the appropriate type.
\end{itemdescr}

\indexlibrary{\idxcode{mem_fun_ref}}%
\begin{itemdecl}
  template<class S, class T> mem_fun_ref_t<S,T>
     mem_fun_ref(S (T::*f)());

  template<class S, class T, class A> mem_fun1_ref_t<S,T,A>
     mem_fun_ref(S (T::*f)(A));
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{mem_fun_ref(\&X::f)} returns an object through which \tcode{X::f}
can be called given a reference to an \tcode{X} followed by the argument
required for \tcode{f} (if any).
\end{itemdescr}

\indexlibrary{\idxcode{const_mem_fun_t}}%
\begin{itemdecl}
template <class S, class T> class const_mem_fun_t
      : public unary_function<T*, S> {
public:
  explicit const_mem_fun_t(S (T::*p)() const);
  S operator()(const T* p) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{const_mem_fun_t} calls the member function it is initialized with
given a pointer argument.
\end{itemdescr}

\indexlibrary{\idxcode{const_mem_fun1_t}}%
\begin{itemdecl}
template <class S, class T, class A> class const_mem_fun1_t
      : public binary_function<T*, A, S> {
public:
  explicit const_mem_fun1_t(S (T::*p)(A) const);
  S operator()(const T* p, A x) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{const_mem_fun1_t} calls the member function it is initialized with
given a pointer argument and an additional argument of the appropriate type.
\end{itemdescr}

\indexlibrary{\idxcode{mem_fun}}%
\begin{itemdecl}
  template<class S, class T> const_mem_fun_t<S,T>
     mem_fun(S (T::*f)() const);

  template<class S, class T, class A> const_mem_fun1_t<S,T,A>
     mem_fun(S (T::*f)(A) const);
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{mem_fun(\&X::f)} returns an object through which \tcode{X::f} can be
called given a pointer to an \tcode{X} followed by the argument required for
\tcode{f} (if any).
\end{itemdescr}

\indexlibrary{\idxcode{const_mem_fun_ref_t}}%
\begin{itemdecl}
  template <class S, class T> class const_mem_fun_ref_t
        : public unary_function<T, S> {
  public:
    explicit const_mem_fun_ref_t(S (T::*p)() const);
    S operator()(const T& p) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{const_mem_fun_ref_t} calls the member function it is initialized with
given a reference argument.
\end{itemdescr}

\indexlibrary{\idxcode{const_mem_fun1_ref_t}}%
\begin{itemdecl}
  template <class S, class T, class A> class const_mem_fun1_ref_t
        : public binary_function<T, A, S> {
  public:
    explicit const_mem_fun1_ref_t(S (T::*p)(A) const);
    S operator()(const T& p, A x) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{const_mem_fun1_ref_t} calls the member function it is initialized
with given a reference argument and an additional argument of the appropriate
type.
\end{itemdescr}

\indexlibrary{\idxcode{mem_fun_ref}}%
\begin{itemdecl}
  template<class S, class T> const_mem_fun_ref_t<S,T>
     mem_fun_ref(S (T::*f)() const);

  template<class S, class T, class A> const_mem_fun1_ref_t<S,T,A>
      mem_fun_ref(S (T::*f)(A) const);
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{mem_fun_ref(\&X::f)} returns an object through which \tcode{X::f}
can be called given a reference to an \tcode{X} followed by the argument
required for \tcode{f} (if any).
\end{itemdescr}

\rSec1[lib.memory]{Memory}

\synopsis{Header \tcode{<memory>} synopsis}

\indexlibrary{\idxhdr{memory}}%
\begin{codeblock}
namespace std {
  // \ref{lib.default.allocator}, the default allocator:
  template <class T> class allocator;
  template <> class allocator<void>;
  template <class T, class U>
    bool operator==(const allocator<T>&, const allocator<U>&) throw();
  template <class T, class U>
    bool operator!=(const allocator<T>&, const allocator<U>&) throw();

  // \ref{lib.storage.iterator}, raw storage iterator:
  template <class OutputIterator, class T> class raw_storage_iterator;

  // \ref{lib.temporary.buffer}, temporary buffers:
  template <class T>
    pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n);
  template <class T>
    void return_temporary_buffer(T* p);

  // \ref{lib.specialized.algorithms}, specialized algorithms:
  template <class InputIterator, class ForwardIterator>
    ForwardIterator
      uninitialized_copy(InputIterator first, InputIterator last,
                         ForwardIterator result);
  template <class ForwardIterator, class T>
    void uninitialized_fill(ForwardIterator first, ForwardIterator last,
                            const T& x);
  template <class ForwardIterator, class Size, class T>
    void uninitialized_fill_n(ForwardIterator first, Size n, const T& x);
  // \ref{lib.auto.ptr}, pointers:
  template<class X> class auto_ptr;
}
\end{codeblock}

\rSec2[lib.default.allocator]{The default allocator}

\indexlibrary{\idxcode{allocator}}%
\begin{codeblock}
namespace std {
  template <class T> class allocator;

  // specialize for \tcode{void}:
  template <> class allocator<void> {
  public:
    typedef void*       pointer;
    typedef const void* const_pointer;
    // reference-to-\tcode{void} members are impossible.
    typedef void  value_type;
    template <class U> struct rebind { typedef allocator<U> other; };
  };

  template <class T> class allocator {
   public:
    typedef size_t    size_type;
    typedef ptrdiff_t difference_type;
    typedef T*        pointer;
    typedef const T*  const_pointer;
    typedef T&        reference;
    typedef const T&  const_reference;
    typedef T         value_type;
    template <class U> struct rebind { typedef allocator<U> other; };

    allocator() throw();
    allocator(const allocator&) throw();
    template <class U> allocator(const allocator<U>&) throw();
   ~allocator() throw();

    pointer address(reference x) const;
    const_pointer address(const_reference x) const;

    pointer allocate(
      size_type, allocator<void>::const_pointer hint = 0);
    void deallocate(pointer p, size_type n);
    size_type max_size() const throw();

    void construct(pointer p, const T& val);
    void destroy(pointer p);
  };
}
\end{codeblock}

\rSec3[lib.allocator.members]{\tcode{allocator} members}

\indexlibrary{\idxcode{address}!\idxcode{allocator}}
\indexlibrary{\idxcode{allocator}!\idxcode{address}}
\begin{itemdecl}
pointer address(reference x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{\&x}.
\end{itemdescr}

\indexlibrary{\idxcode{address}!\idxcode{allocator}}
\indexlibrary{\idxcode{allocator}!\idxcode{address}}
\begin{itemdecl}
const_pointer address(const_reference x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{\&x}.
\end{itemdescr}

\indexlibrary{\idxcode{allocate}!\idxcode{allocator}}
\indexlibrary{\idxcode{allocator}!\idxcode{allocate}}
\begin{itemdecl}
pointer allocate(size_type n, allocator<void>::const_pointer hint = 0);
\end{itemdecl}

\begin{itemdescr}
\pnum
\notes
Uses \tcode{::operator new(size_t)}~(\ref{lib.new.delete}).

\pnum
\requires
\tcode{hint} either 0 or previously obtained from member \tcode{allocate}
and not yet passed to member \tcode{deallocate}. The value \tcode{hint}
may be used by an implementation to help improve performance\footnote{In a
container member function, the address of an adjacent element is often a
good choice to pass for this argument.}.

\pnum
\returns
a pointer to the initial element of an array of storage of size \tcode{n}
\tcode{* sizeof(T)}, aligned appropriately for objects of type \tcode{T}.

\pnum
\note
the storage is obtained by calling \tcode{::operator
new(size_t)}, but it is unspecified when or how often this
function is called. The use of \tcode{hint} is unspecified, but intended as an aid to
locality if an implementation so desires.

\pnum
\throws
\tcode{bad_alloc} if the storage cannot be obtained.
\end{itemdescr}

\indexlibrary{\idxcode{deallocate}!\idxcode{allocator}}
\indexlibrary{\idxcode{allocator}!\idxcode{deallocate}}
\begin{itemdecl}
void deallocate(pointer p, size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{p} shall be a pointer value obtained from \tcode{allocate()}.
\tcode{n} shall equal the value passed as the first argument
to the invocation of allocate which returned \tcode{p}.

\pnum
\effects
Deallocates the storage referenced by \tcode{p} .

\pnum
\notes
Uses
\tcode{::operator delete(void*)}~(\ref{lib.new.delete}), but it is unspecified when this function is called.
\end{itemdescr}

\indexlibrary{\idxcode{max_size}!\idxcode{allocator}}
\indexlibrary{\idxcode{allocator}!\idxcode{max_size}}
\begin{itemdecl}
size_type max_size() const throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
the largest value \textit{N} for which the call \tcode{allocate(N,0)}
might succeed.
\end{itemdescr}

\indexlibrary{\idxcode{allocator}!constructor}%
\begin{itemdecl}
void construct(pointer p, const_reference val);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{new((void *)p) T(val)}
\end{itemdescr}

\indexlibrary{\idxcode{allocator}!destructor}%
\begin{itemdecl}
void destroy(pointer p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{((T*)p)->\~{}T()}
\end{itemdescr}

\rSec3[lib.allocator.globals]{\tcode{allocator} globals}

\indexlibrary{\idxcode{operator==}!\idxcode{allocator}}%
\indexlibrary{\idxcode{allocator}!\idxcode{operator==}}%
\begin{itemdecl}
template <class T1, class T2>
  bool operator==(const allocator<T1>&, const allocator<T2>&) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true}.
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{allocator}}%
\indexlibrary{\idxcode{allocator}!\idxcode{operator"!=}}%
\begin{itemdecl}
template <class T1, class T2>
  bool operator!=(const allocator<T1>&, const allocator<T2>&) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{false}.
\end{itemdescr}

\rSec2[lib.storage.iterator]{Raw storage iterator}

\pnum
\tcode{raw_storage_iterator} is provided to enable algorithms to store their
results into uninitialized memory. The formal template parameter
\tcode{OutputIterator} is required to have its \tcode{operator*} return an
object for which \tcode{operator\&} is defined and returns a pointer to
\tcode{T}, and is also required to satisfy the requirements of an output
iterator~(\ref{lib.output.iterators}).

\begin{codeblock}
namespace std {
  template <class OutputIterator, class T>
  class raw_storage_iterator
    : public iterator<output_iterator_tag,void,void,void,void> {
  public:
    explicit raw_storage_iterator(OutputIterator x);

    raw_storage_iterator<OutputIterator,T>& operator*();
    raw_storage_iterator<OutputIterator,T>& operator=(const T& element);
    raw_storage_iterator<OutputIterator,T>& operator++();
    raw_storage_iterator<OutputIterator,T>  operator++(int);
  };
}
\end{codeblock}

\indexlibrary{\idxcode{raw_storage_iterator}!constructor}%
\begin{itemdecl}
raw_storage_iterator(OutputIterator x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the iterator to point to the same value to which \tcode{x} points.
\end{itemdescr}

\indexlibrary{\idxcode{operator*}!\idxcode{raw_storage_iterator}}
\indexlibrary{\idxcode{raw_storage_iterator}!\idxcode{operator*}}
\begin{itemdecl}
raw_storage_iterator<OutputIterator,T>& operator*();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*this}
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{raw_storage_iterator}}
\indexlibrary{\idxcode{raw_storage_iterator}!\idxcode{operator=}}
\begin{itemdecl}
raw_storage_iterator<OutputIterator,T>& operator=(const T& element);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a value from \tcode{element} at the location to which the iterator points.

\pnum
\returns
A reference to the iterator.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{raw_storage_iterator}}
\indexlibrary{\idxcode{raw_storage_iterator}!\idxcode{operator++}}
\begin{itemdecl}
raw_storage_iterator<OutputIterator,T>& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Pre-increment:  advances the iterator and returns a reference to the updated iterator.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{raw_storage_iterator}}
\indexlibrary{\idxcode{raw_storage_iterator}!\idxcode{operator++}}
\begin{itemdecl}
raw_storage_iterator<OutputIterator,T> operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Post-increment:  advances the iterator and returns the old value of the iterator.
\end{itemdescr}

\rSec2[lib.temporary.buffer]{Temporary buffers}

\indexlibrary{\idxcode{get_temporary_buffer}}%
\begin{itemdecl}
template <class T>
  pair<T*, ptrdiff_t> get_temporary_buffer(ptrdiff_t n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Obtains a pointer to storage sufficient to store up to \tcode{n}
adjacent \tcode{T} objects.

\pnum
\returns
A \tcode{pair} containing the buffer's address and capacity (in the units of
\tcode{sizeof(T)}), or a pair of 0 values if no storage can be obtained.
\end{itemdescr}

\indexlibrary{\idxcode{return_temporary_buffer}}%
\begin{itemdecl}
template <class T> void return_temporary_buffer(T* p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Deallocates the buffer to which \tcode{p}
points.

\pnum
\requires
The buffer shall have been previously allocated by \tcode{get_temporary_buffer}.
\end{itemdescr}

\rSec2[lib.specialized.algorithms]{Specialized algorithms}

\pnum
All the iterators that are used as formal template parameters in the following
algorithms are required to  have their \tcode{operator*} return an object
for which \tcode{operator\&} is defined and returns a pointer to \tcode{T}.
In the algorithm \tcode{uninitialized_copy}, the formal template parameter
\tcode{InputIterator} is required to satisfy the requirements of an input
iterator~(\ref{lib.input.iterators}). In all of the following algorithms,
the formal template parameter \tcode{ForwardIterator} is required to satisfy the
requirements of a forward iterator~(\ref{lib.forward.iterators}), and also to
satisfy the requirements of a mutable iterator~(\ref{lib.iterator.requirements}),
and is required to have the property that no exceptions are thrown
from increment, assignment, comparison, or dereference of valid iterators.
In the following algorithms, if an exception is thrown there are no effects.

\rSec3[lib.uninitialized.copy]{\tcode{uninitialized_copy}}

\indexlibrary{\idxcode{uninitialized_copy}}%
\begin{itemdecl}
template <class InputIterator, class ForwardIterator>
  ForwardIterator
    uninitialized_copy(InputIterator first, InputIterator last,
                       ForwardIterator result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
for (; first != last; ++result, ++first)
    new (static_cast<void*>(&*result))
            typename iterator_traits<ForwardIterator>::value_type(*first);
\end{codeblock}

\pnum
\returns
\tcode{result}
\end{itemdescr}

\rSec3[lib.uninitialized.fill]{\tcode{uninitialized_fill}}

\indexlibrary{\idxcode{uninitialized_fill}}%
\begin{itemdecl}
template <class ForwardIterator, class T>
  void uninitialized_fill(ForwardIterator first, ForwardIterator last,
                          const T& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
for (; first != last; ++first)
    new (static_cast<void*>(&*first))
            typename iterator_traits<ForwardIterator>::value_type(x);
\end{codeblock}
\end{itemdescr}

\rSec3[lib.uninitialized.fill.n]{\tcode{uninitialized_fill_n}}

\indexlibrary{\idxcode{uninitialized_fill_n}}%
\begin{itemdecl}
template <class ForwardIterator, class Size, class T>
  void uninitialized_fill_n(ForwardIterator first, Size n, const T& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
for (; n--; ++first)
    new (static_cast<void*>(&*first))
            typename iterator_traits<ForwardIterator>::value_type(x);
\end{codeblock}
\end{itemdescr}

\rSec2[lib.auto.ptr]{Class template \tcode{auto_ptr}}

\pnum
Template \tcode{auto_ptr} stores a pointer to an object obtained via
\tcode{new} and deletes that object when it itself is destroyed (such as
when leaving block scope~\ref{stmt.dcl}).

\pnum
Template \tcode{auto_ptr_ref} holds a reference to an \tcode{auto_ptr}.
It is used by the \tcode{auto_ptr} conversions to allow \tcode{auto_ptr}
objects to be passed to and returned from functions.

\begin{codeblock}
namespace std {
  template <class Y> struct auto_ptr_ref {};

  template<class X> class auto_ptr {
  public:
    typedef X element_type;

    // \ref{lib.auto.ptr.cons} construct/copy/destroy:
    explicit auto_ptr(X* p =0) throw();
    auto_ptr(auto_ptr&) throw();
    template<class Y> auto_ptr(auto_ptr<Y>&) throw();
    auto_ptr& operator=(auto_ptr&) throw();
    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();
    auto_ptr& operator=(auto_ptr_ref<X> r) throw();
   ~auto_ptr() throw();

    // \ref{lib.auto.ptr.members} members:
    X& operator*() const throw();
    X* operator->() const throw();
    X* get() const throw();
    X* release() throw();
    void reset(X* p =0) throw();

    // \ref{lib.auto.ptr.conv} conversions:
    auto_ptr(auto_ptr_ref<X>) throw();
    template<class Y> operator auto_ptr_ref<Y>() throw();
    template<class Y> operator auto_ptr<Y>() throw();
  };
}
\end{codeblock}

\pnum
The \tcode{auto_ptr} provides a semantics of strict ownership. An \tcode{auto_ptr}
owns the object it holds a pointer to. Copying an \tcode{auto_ptr} copies the
pointer and transfers ownership to the destination. If more than one
\tcode{auto_ptr} owns the same object at the same time the behavior of the
program is undefined.
\enternote 
The uses of \tcode{auto_ptr} include providing temporary exception-safety
for dynamically allocated memory, passing ownership of dynamically allocated
memory to a function, and returning dynamically allocated memory from a function.
\tcode{auto_ptr} does not meet the \tcode{CopyConstructible} and \tcode{Assignable}
requirements for Standard Library container elements and thus instantiating
a Standard Library container with an \tcode{auto_ptr} results in
undefined behavior.
\exitnoteb

\rSec3[lib.auto.ptr.cons]{\tcode{auto_ptr} constructors}

\indexlibrary{\idxcode{auto_ptr}!\idxcode{auto_ptr}}%
\begin{itemdecl}
explicit auto_ptr(X* p =0) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\postconditions
\tcode{*this} holds the pointer \tcode{p}.
\end{itemdescr}

\indexlibrary{\idxcode{auto_ptr}!constructor}%
\begin{itemdecl}
auto_ptr(auto_ptr& a) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls \tcode{a.release()}.

\pnum
\postconditions
\tcode{*this} holds the pointer returned from \tcode{a.release()}.
\end{itemdescr}

\indexlibrary{\idxcode{auto_ptr}!constructor}%
\begin{itemdecl}
template<class Y> auto_ptr(auto_ptr<Y>& a) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{Y*} can be implicitly converted to \tcode{X*}.

\pnum
\effects
Calls \tcode{a.release()}.

\pnum
\postconditions
\tcode{*this} holds the pointer returned from \tcode{a.release()}.
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{auto_ptr}}%
\begin{itemdecl}
auto_ptr& operator=(auto_ptr& a) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The expression \tcode{delete get()} is well formed.

\pnum
\effects
\tcode{reset(a.release())}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{auto_ptr}!\idxcode{operator=}}%
\indexlibrary{\idxcode{operator=}!\idxcode{auto_ptr}}%
\begin{itemdecl}
template<class Y> auto_ptr& operator=(auto_ptr<Y>& a) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{Y*} can be implicitly converted to \tcode{X*}. The expression
\tcode{delete get()} is well formed.

\pnum
\effects
\tcode{reset(a.release())}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{auto_ptr}!destructor}%
\begin{itemdecl}
~auto_ptr() throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The expression \tcode{delete get()} is well formed.

\pnum
\effects
\tcode{delete get()}.
\end{itemdescr}

\rSec3[lib.auto.ptr.members]{\tcode{auto_ptr} members}

\indexlibrary{\idxcode{operator*}!\idxcode{auto_ptr}}%
\begin{itemdecl}
X& operator*() const throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{get() != 0}

\pnum
\returns
\tcode{*get()}
\end{itemdescr}

\indexlibrary{\idxcode{operator->}!\idxcode{auto_ptr}}%
\begin{itemdecl}
X* operator->() const throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{get()}
\end{itemdescr}

\indexlibrary{\idxcode{get}!\idxcode{auto_ptr}}%
\begin{itemdecl}
X* get() const throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The pointer \tcode{*this} holds.
\end{itemdescr}

\indexlibrary{\idxcode{release}!\idxcode{auto_ptr}}%
\begin{itemdecl}
X* release() throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{get()}

\pnum
\postcondition
\tcode{*this} holds the null pointer.
\end{itemdescr}

\indexlibrary{\idxcode{reset}!\idxcode{auto_ptr}}%
\begin{itemdecl}
void reset(X* p=0) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{get() != p} then \tcode{delete get()}.

\pnum
\postconditions
\tcode{*this} holds the pointer \tcode{p}.
\end{itemdescr}

\rSec3[lib.auto.ptr.conv]{\tcode{auto_ptr} conversions}

\indexlibrary{\idxcode{auto_ptr}!constructor}%
\begin{itemdecl}
auto_ptr(auto_ptr_ref<X> r) throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls \tcode{p.release()} for the \tcode{auto_ptr} \tcode{p} that \tcode{r} holds.

\pnum
\postconditions
\tcode{*this} holds the pointer returned from \tcode{release()}.
\end{itemdescr}

\indexlibrary{\idxcode{auto_ptr}!\idxcode{auto_ptr_ref}}%
\indexlibrary{\idxcode{auto_ptr_ref}!\idxcode{auto_ptr}}%
\begin{itemdecl}
template<class Y> operator auto_ptr_ref<Y>() throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An \tcode{auto_ptr_ref<Y>} that holds \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{auto_ptr_ref}!\idxcode{operator auto_ptr}}%
\indexlibrary{\idxcode{operator auto_ptr}!\idxcode{auto_ptr_ref}}%
\begin{itemdecl}
template<class Y> operator auto_ptr<Y>() throw();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls \tcode{release()}.

\pnum
\returns
An \tcode{auto_ptr<Y>} that holds the pointer returned from \tcode{release()}.
\end{itemdescr}

\indexlibrary{\idxcode{auto_ptr_ref}!\idxcode{operator=}}%
\indexlibrary{\idxcode{operator=}!\idxcode{auto_ptr_ref}}%
\begin{itemdecl}
auto_ptr& operator=(auto_ptr_ref<X> r) throw()
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls \tcode{reset(p.release())} for the \tcode{auto_ptr p}
that \tcode{r} holds a reference to.

\pnum
\returns
\tcode{*this}
\end{itemdescr}


\rSec2[lib.c.malloc]{C Library}

\pnum
Header \tcode{<cstdlib>} (Table~\ref{tab:util.hdr.cstdlib}):

\begin{libsyntab3}{cstdlib}{tab:util.hdr.cstdlib}
\functions  &   \tcode{calloc}  &   \tcode{malloc}      \\
            &   \tcode{free}    &   \tcode{realloc}     \\
\end{libsyntab3}

\pnum
The contents are the same as the Standard C library header
\tcode{<stdlib.h>,}
with the following changes:

\pnum
The functions \tcode{calloc()}\indexlibrary{\idxcode{calloc}},
\tcode{malloc()}\indexlibrary{\idxcode{malloc}}, and
\tcode{realloc()}\indexlibrary{\idxcode{realloc}} do not attempt to allocate
storage by calling \tcode{::operator new()}~(\ref{lib.support.dynamic}).
\indexlibrary{\idxcode{new}!\idxcode{operator}}%

\pnum
The function \tcode{free()}\indexlibrary{\idxcode{free}} does not attempt to
deallocate storage by calling
\tcode{::operator delete()}\indexlibrary{\idxcode{delete}!\tcode{operator}}.

\xref
ISO C clause 7.11.2.

\pnum
Header \tcode{<cstring>} (Table~\ref{tab:util.hdr.cstring}):

\begin{libsyntab3}{cstring}{tab:util.hdr.cstring}
\macro          &   \tcode{NULL}    &                   \\ \rowsep
\type           &   \tcode{size_t}  &                   \\ \rowsep
\functions      &   \tcode{memchr}  &   \tcode{memcmp}  \\
\tcode{memcpy}  &   \tcode{memmove} &   \tcode{memset}  \\
\end{libsyntab3}

\pnum
The contents are the same as the Standard C library header
\tcode{<string.h>}, with the change to \tcode{memchr()} specified
in~\ref{lib.c.strings}.

\xref
ISO C clause 7.11.2.

\rSec1[lib.date.time]{Date and time}

\pnum
Header \tcode{<ctime>} (Table~\ref{tab:util.hdr.ctime}):

\begin{libsyntab5}{ctime}{tab:util.hdr.ctime}

\macros             &
 \tcode{NULL}       &
                    &
                    &
                    \\ \rowsep
\types              &
 \tcode{size_t}     &
 \tcode{clock_t}    &
 \tcode{time_t}     &
                    \\ \rowsep
\struct             &
 \tcode{tm}         &
                    &
                    &
                    \\ \rowsep
\cspan{\functions}  \\
\tcode{asctime}     &
 \tcode{clock}      &
 \tcode{difftime}   &
 \tcode{localtime}  &
 \tcode{strftime}   \\
\tcode{ctime}       &
 \tcode{gmtime}     &
 \tcode{mktime}     &
 \tcode{time}       &
                    \\
\end{libsyntab5}

\pnum
The contents are the same as the Standard C library header
\tcode{<time.h>.}

\xref
ISO C clause 7.12, Amendment 1 clause 4.6.4.
